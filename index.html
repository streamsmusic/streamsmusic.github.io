<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Streams</title>
    <link id="favicon" rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="streams.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,0">    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registered:', registration);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed:', error);
                    });
            });
        }
    </script>
    <style>
        @font-face {
          font-family: 'Open Runde';
          font-style: normal;
          font-weight: 400;
          src: url('https://cdn.jsdelivr.net/gh/lauridskern/open-runde@main/src/web/OpenRunde-Regular.woff2') format('woff2');
        }

        @font-face {
          font-family: 'Open Runde';
          font-style: normal;
          font-weight: 500;
          src: url('https://cdn.jsdelivr.net/gh/lauridskern/open-runde@main/src/web/OpenRunde-Medium.woff2') format('woff2');
        }
        
        @font-face {
          font-family: 'Open Runde';
          font-style: normal;
          font-weight: 700;
          src: url('https://cdn.jsdelivr.net/gh/lauridskern/open-runde@main/src/web/OpenRunde-Semibold.woff2') format('woff2');
        }

        @font-face {
          font-family: 'Open Runde';
          font-style: normal;
          font-weight: 800;
          src: url('https://cdn.jsdelivr.net/gh/lauridskern/open-runde@main/src/web/OpenRunde-Bold.woff2') format('woff2');
        }

        @font-face {
          font-family: 'Inter Numeric';
          src: url('/assets/fonts/InterNumeric.ttf') format('truetype-variations');
          font-weight: 100 900; /* Define the supported variable weight range */
          font-style: normal;
        }
    
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', 'Inter', sans-serif, 'Apple Color Emoji';
            -webkit-tap-highlight-color: transparent;
        }
        
        *::-webkit-scrollbar {
            width: 8px; /* Thin scrollbar */
        }
        
        *::-webkit-scrollbar-track {
            background: transparent;
        }
        
        *::-webkit-scrollbar-thumb {
        	background-color: var(--search-background);
        	border-radius: 50px;
        }

        /* Set Font Faces */
        .material-symbols-rounded {
            font-variation-settings:
                'FILL' 1,
                'wght' 700,
                'GRAD' 0,
                'opsz' 24;
            vertical-align: middle;
        }

        :root {
            --edge-refraction-filter: url('#edge-refraction-only');
            --sun-shadow: 0 0 0 0 transparent;
            
            /* Dark Theme (Default) Variables */
            --background-app-dark: #000;
            --background-color-dark: #1c1c1c;
            --background-color-dark-tr: rgba(28, 28, 28, 0.7);
            --text-color-dark: #f9f9f9;
            --secondary-text-color-dark: rgba(255, 255, 255, 0.7);
            --accent-dark: #FF0436;
            --tonal-dark: rgba(255, 255, 255, 0.7);
            --modal-background-dark: rgba(51, 51, 51, 0.8);
            --modal-transparent-dark: rgba(51, 51, 51, 0.7);
            --search-background-dark: rgba(51, 51, 51, 0.5);
            --dark-overlay: rgba(51, 51, 51, 0.2);
            --dark-transparent: rgba(255, 255, 255, 0.1); 
            --glass-border-dark: rgba(100, 100, 100, 0.2);
            
            /* Light Theme Variables */
            --background-app-light: #fff;
            --background-color-light: #f0f0f0;
        	--background-color-light-tr: rgba(240, 240, 240, 0.7);
            --text-color-light: #333333;
            --secondary-text-color-light: rgba(0, 0, 0, 0.7);
            --accent-light: #FF0436;
            --tonal-light: rgba(0, 0, 0, 0.7);
            --modal-background-light: rgba(220, 220, 220, 0.8);
            --modal-transparent-light: rgba(240, 240, 240, 0.7);
            --search-background-light: rgba(240, 240, 240, 0.5);
            --light-overlay: rgba(220, 220, 220, 0.2);
            --light-transparent: rgba(255, 255, 255, 0.1); 
            --glass-border-light: rgba(200, 200, 200, 0.2);
            
            /* High Contrast Dark Theme Variables */
            --background-app-dark-highcontrast: #000;
            --background-color-dark-highcontrast: #1c1c1c;
            --background-color-dark-tr-highcontrast: #1c1c1c;
            --text-color-dark-highcontrast: #f9f9f9;
            --secondary-text-color-dark-highcontrast: #b3b3b3;
            --accent-dark-highcontrast: #ff7a95;
            --tonal-dark-highcontrast: #b3b3b3;
            --modal-background-dark-highcontrast: #333333;
            --modal-transparent-dark-highcontrast: #333333;
            --search-background-dark-highcontrast: #333333;
            --dark-overlay-highcontrast: #1c1c1c;
            --dark-transparent-highcontrast: #000000;
            
            /* High Contrast Light Theme Variables */
            --background-app-light-highcontrast: #fff;
            --background-color-light-highcontrast: #f0f0f0;
            --background-color-light-tr-highcontrast: #f0f0f0;
            --text-color-light-highcontrast: #333333;
            --secondary-text-color-light-highcontrast: #4d4d4d;
            --accent-light-highcontrast: #ad1332;
            --tonal-light-highcontrast: #4d4d4d;
            --modal-background-light-highcontrast: #dcdcdc;
            --modal-transparent-light-highcontrast: #f0f0f0;
            --search-background-light-highcontrast: #dcdcdc;
            --light-overlay-highcontrast: #f0f0f0;
            --light-transparent-highcontrast: #ffffff;
            
            /* Base Variables */
            --base-font-size: clamp(16px, 2vw + 1rem, 24px);
            
            /* Default to Dark Theme */
            --background-app: var(--background-app-dark);
            --background-color: var(--background-color-dark);
            --background-color-tr: var(--background-color-dark-tr);
            --background-color-tr-op: var(--background-color-light-tr);
            --text-color: var(--text-color-dark);
            --secondary-text-color: var(--secondary-text-color-dark);
            --accent: var(--accent-dark);
            --tonal: var(--tonal-dark);
            --modal-background: var(--modal-background-dark);
            --modal-transparent: var(--modal-transparent-dark);
            --search-background: var(--search-background-dark);
            --search-background-op: var(--search-background-light);
            --overlay-color: var(--dark-overlay);
            --overlay-color-op: var(--light-overlay);
            --transparent-color: var(--dark-transparent);
            --glass-border: var(--glass-border-dark);
        }
        
        body.light-theme {
            --background-app: var(--background-app-light);
            --background-color: var(--background-color-light);
            --background-color-tr: var(--background-color-light-tr);
            --background-color-tr-op: var(--background-color-dark-tr);
            --text-color: var(--text-color-light);
            --secondary-text-color: var(--secondary-text-color-light);
            --accent: var(--accent-light);
            --tonal: var(--tonal-light);
            --modal-background: var(--modal-background-light);
            --modal-transparent: var(--modal-transparent-light);
            --search-background: var(--search-background-light);
            --search-background-op: var(--search-background-dark);
            --overlay-color: var(--light-overlay);
            --overlay-color-op: var(--dark-overlay);
            --transparent-color: var(--light-transparent);
            --glass-border: var(--glass-border-light);
        	--polygol-cursor-visible: var(--polygol-cursor-light);
        }
        
        @media (prefers-contrast: more) {
            :root {
                --background-color-tr: var(--background-color-dark-tr-highcontrast);
                --background-color-tr-op: var(--background-color-light-tr-highcontrast);
                --secondary-text-color: var(--secondary-text-color-dark-highcontrast);
                --accent: var(--accent-dark-highcontrast);
                --tonal: var(--tonal-dark-highcontrast);
                --modal-background: var(--modal-background-dark-highcontrast);
                --modal-transparent: var(--modal-transparent-dark-highcontrast);
                --search-background: var(--search-background-dark-highcontrast);
                --search-background-op: var(--search-background-light-highcontrast);
                --overlay-color: var(--dark-overlay-highcontrast);
                --overlay-color-op: var(--light-overlay-highcontrast);
                --transparent-color: var(--dark-transparent-highcontrast);
                --glass-border: var(--accent-dark-highcontrast);
            }
            
            /* For light theme with high contrast */
            body.light-theme {
                --background-color-tr: var(--background-color-light-tr-highcontrast);
                --background-color-tr-op: var(--background-color-dark-tr-highcontrast);
                --secondary-text-color: var(--secondary-text-color-light-highcontrast);
                --accent: var(--accent-light-highcontrast);
                --tonal: var(--tonal-light-highcontrast);
                --modal-background: var(--modal-background-light-highcontrast);
                --modal-transparent: var(--modal-transparent-light-highcontrast);
                --search-background: var(--search-background-light-highcontrast);
                --search-background-op: var(--search-background-dark-highcontrast);
                --overlay-color: var(--light-overlay-highcontrast);
                --overlay-color-op: var(--dark-overlay-highcontrast);
                --transparent-color: var(--light-transparent-highcontrast);
                --glass-border: var(--accent-light-highcontrast);
            }

            /* Universal backdrop-filter removal for high contrast */
            * {
                backdrop-filter: none !important;
            }

            .tab-btn.active {
                color: var(--background-color) !important;
                background: var(--accent !important);
                border-radius: 12px;
                corner-shape: superellipse(1.5);
            }

            .toolbar .tab-btn.active .material-symbols-rounded {
                color: var(--background-color) !important;
            }
        }

        /* When animations are disabled */
        .reduce-animations * {
            /* Disable all animations */
            animation: none !important;
        
            /* Disable all transitions except opacity */
            transition: opacity 0.3s ease !important;
            transition-property: opacity !important;
        }
        
        /* Special handling for clickable elements */
        .reduce-animations [onclick],
        .reduce-animations button,
        .reduce-animations a,
        .reduce-animations input[type="button"],
        .reduce-animations input[type="submit"],
        .reduce-animations .clickable {
            /* Keep initial state but remove transition */
            transform: scale(1) !important;
            transition: opacity 0.3s ease !important;
        }
        
        /* Keep active state functional but without animation */
        .reduce-animations [onclick]:active,
        .reduce-animations button:active,
        .reduce-animations a:active,
        .reduce-animations input[type="button"]:active,
        .reduce-animations input[type="submit"]:active,
        .reduce-animations .clickable:active {
            /* Apply scale instantly without transition */
            transform: scale(0.98) !important;
            transition: none !important;
        }

        /* For all clickable elements */
        [onclick], 
        button, 
        a, 
        input[type="button"], 
        input[type="submit"],
        .clickable {
            cursor: pointer;
            transform: scale(1);
            transition: transform 0.15s cubic-bezier(0.2, 0, 0.38, 0.9);
        }
        
        /* Active effect (when clicking down) */
        [onclick]:active, 
        button:active, 
        a:active, 
        input[type="button"]:active, 
        input[type="submit"]:active,
        .clickable:active {
            transform: scale(0.96);
            transition: transform 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }

        input[type="color"] {
            -webkit-appearance: none;
            appearance: none;
            border: 1px solid var(--glass-border);
            width: 30px;
            height: 30px;
            padding: 0;
            background: none;
            border-radius: 999px;
            cursor: pointer;
            overflow: hidden;
        }
        
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        
        input[type="color"]::-webkit-color-swatch {
          border: none;
          border-radius: 999px;
        }
        
        input[type="color"]::-moz-color-swatch {
          border: 1px solid var(--glass-border);
          border-radius: 999px;
        }
        
        input[type="checkbox"] {
            appearance: none;
            width: 64px;
            height: 32px;
            background-color: rgba(150, 150, 150, 0.5);
            border-radius: 16px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s linear(0 0%, 0 1.8%, 0.01 3.6%, 0.03 6.35%, 0.07 9.1%, 0.13 11.4%, 0.19 13.4%, 0.27 15%, 0.34 16.1%, 0.54 18.35%, 0.66 20.6%, 0.72 22.4%, 0.77 24.6%, 0.81 27.3%, 0.85 30.4%, 0.88 35.1%, 0.92 40.6%, 0.94 47.2%, 0.96 55%, 0.98 64%, 0.99 74.4%, 1 86.4%, 1 100%);
            border: 1px solid var(--glass-border);
            cursor: pointer;
        }
        
        input[type="checkbox"]::before {
            content: '';
            position: absolute;
            width: 34px;
            height: 26px;
            background-color: white;
            border-radius: 36px;
            top: 50%;
            left: 2px;
            transform: translateY(-50%);
            box-sizing: border-box;
            transition: all 0.3s linear(0 0%, 0 1.8%, 0.01 3.6%, 0.03 6.35%, 0.07 9.1%, 0.13 11.4%, 0.19 13.4%, 0.27 15%, 0.34 16.1%, 0.54 18.35%, 0.66 20.6%, 0.72 22.4%, 0.77 24.6%, 0.81 27.3%, 0.85 30.4%, 0.88 35.1%, 0.92 40.6%, 0.94 47.2%, 0.96 55%, 0.98 64%, 0.99 74.4%, 1 86.4%, 1 100%);
        }
        
        input[type="checkbox"]:checked {
            background-color: var(--accent);
        }
        
        input[type="checkbox"]:checked::before {
            left: 26px;
        }

        select option {
            background-color: var(--background-color);
            color: var(--text-color);
            transition: background-color 0.2s, transform 0.1s;
        }

        .toolbar {
            padding: 0 5px;
            background-color: transparent;
            border: none;
            position: fixed;
            bottom: 0px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            transition: top 0.3s ease;
            width: 100%;
            flex-wrap: wrap;
            height: calc(140px + env(safe-area-inset-bottom));
        }

        .toolbar.hidden {
            display: none;
        }

        .toolbar-btns {
            max-width: 600px;
            width: calc(100vw - 20px);
            justify-self: center;
            pointer-events: auto;
            display: flex;
            justify-content: space-around;
            align-content: center;
            flex-direction: row;
            gap: 14px;
            margin: 90px 0 0 0;
        }

        @media (env(safe-area-inset-bottom) > 0px) {
            .toolbar-btns {
                margin: calc(env(safe-area-inset-bottom) - 90px) 0 0 0;
            }
        }

        .toolbar::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            backdrop-filter: blur(10px);
            background-color: var(--background-color-tr);
            mask-image: linear-gradient(to top, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 60%, rgba(0, 0, 0, 0) 100%);
            -webkit-mask-image: linear-gradient(to top, rgba(0, 0, 0, 1) 0%, rgba(0, 0, 0, 1) 60%, rgba(0, 0, 0, 0) 100%);
        }

        .tab-btn {
            background-color: transparent;
            color: var(--secondary-text-color);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(.3, 1.2, .64, 1) ! IMPORTANT;
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
            border: none;
            width: 100%;
        }

        .tab-btn.active {
            color: var(--accent);
            font-weight: bold;
        }

        .toolbar .tab-btn .material-symbols-rounded {
            transition: all 0.3s;
            color: var(--secondary-text-color);
            font-variation-settings: 'FILL' 0, 'wght' 500, 'GRAD' 0, 'opsz' 24;
        }

        .toolbar .tab-btn.active .material-symbols-rounded {
            color: var(--accent) !important;
            font-variation-settings: 'FILL' 1, 'wght' 700, 'GRAD' 0, 'opsz' 24;
        }
        
        body {
            background-color: var(--background-app);
            min-height: 100vh;
            display: flex;
            user-select: none;
            position: relative;
            overflow: hidden;
            transition: background-color 0.3s, color 0.3s, background-image 0.5s;
            color: var(--text-color);
        }

        .view-container {
            flex-grow: 1;
            width: 100%;
            padding: calc(12px + env(safe-area-inset-top)) 14px 180px 14px;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0;
        }

        .view-container::-webkit-scrollbar { width: 8px; }
        .view-container::-webkit-scrollbar-track { background: transparent; }
        .view-container::-webkit-scrollbar-thumb { background-color: var(--search-background); border-radius: 50px; }

        #now-playing-view {
            padding: 20px;
            display: none; /* Default hidden */
            align-items: center;
            justify-content: center;
            position: fixed; /* Fixed overlay for smooth transitions */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1005; /* Above normal content, below modals */
            background-color: var(--background-color);
            opacity: 0;
            transform: translateY(80%) scale(0.8); /* Slight slide up effect */
            transition: all 0.3s cubic-bezier(.3, 1.2, .64, 1) !important;
            pointer-events: none;
            border-radius: 50px;
            corner-shape: superellipse(1.5);
            overflow: clip;
        }

        #now-playing-view.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
            filter: none;
            border-radius: 0;
        }

        #bottom-miniplayer {
            position: fixed;
            bottom: calc(60px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 600px;
            height: 64px;
            background-color: var(--search-background);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            corner-shape: superellipse(1.5);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            padding: 8px;
            gap: 12px;
            z-index: 1001;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            box-shadow: 0 5px 50px -10px rgba(0, 0, 0, 0.2);
        }
        #bottom-miniplayer:active {
            transform: translateX(-50%) scale(1.05);
            transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }
        #bottom-miniplayer.hidden {
            bottom: 0;
            opacity: 0;
            pointer-events: none;
            width: 100%;
            max-width: 600px;
            height: 100%;
            backdrop-filter: none;
            background-color: transparent !important;
            filter: blur(10px);
            transform: translateX(-50%);
            transition: all 0.5s cubic-bezier(.3, 1.2, .64, 1);
        }
        #bottom-miniplayer.hidden .miniplayer-info, #bottom-miniplayer.hidden .miniplayer-controls {
            transform: scale(0);
            opacity: 0;
            transition: all 0.3s cubic-bezier(.3, 1.2, .64, 1);
        }
        #miniplayer-art {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            corner-shape: superellipse(1.5);
            box-shadow: 0 0 0 1px var(--glass-border);
            flex-shrink: 0;
            transition: all 0.5s cubic-bezier(.3, 1.2, .64, 1);
        }
        #bottom-miniplayer.hidden #miniplayer-art {
            width: 10%;
            height: 10%;
            filter: blur(10px) saturate(4);
            transform: scale(10) translateX(45%);
        }
        .miniplayer-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex-grow: 1;
            min-width: 0;
            color: var(--text-color);
            transition: all 0.3s cubic-bezier(.3, 1.2, .64, 1);
        }
        #miniplayer-title, #miniplayer-artist {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #miniplayer-title { font-weight: bold; font-size: 16px; }
        #miniplayer-artist { font-size: 16px; color: var(--secondary-text-color); }

        .miniplayer-controls { display: flex; align-items: center; gap: 14px; padding-right: 8px; transition: all 0.3s cubic-bezier(.3, 1.2, .64, 1); }
        .mini-control-btn .material-symbols-rounded {
            font-size: 28px;
        }        
        .mini-control-btn {
            background: none;
            border: none;
            color: var(--text-color);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .miniplayer-progress {
            position: absolute;
            bottom: 0;
            left: 4.5%;
            max-width: 90.5%;
            height: 2px;
            background-color: var(--accent);
            width: 0%; /* JS will control this */
            transition: width 0.25s ease;
            border-radius: 5px;
        }

        /* Responsive miniplayer */
        #miniplayer-prev-btn, #miniplayer-next-btn { display: none; }
        @media (min-width: 390px) {
            #miniplayer-next-btn { display: flex; }
        }

        @media (min-width: 600px) {
            #miniplayer-prev-btn, #miniplayer-next-btn { display: flex; }
        }

        /* Generic Grid for Home/Library/Search */
        .page-content-wrapper {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            height: 0;
        }
        .section-title-fy {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 10px;
        }
        .section-subtitle {
            font-size: 14px;
            padding: 8px 12px;
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            width: fit-content;
            border-radius: 24px;
            margin-bottom: 20px;
        }
        .item-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 14px;
            padding-bottom: 125px;
        }
        @media (max-width: 480px) {
            .item-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }
        .item-card {
            background-color: transparent; /* Cards will be minimal */
            border-radius: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 10px;
            cursor: pointer;
            transform: scale(1);
            transition: all 0.15s cubic-bezier(0.2, 0, 0.38, 0.9);
        }
        .item-card-art {
            width: 100%;
            aspect-ratio: 1 / 1;
            box-shadow: 0 0 0 1px var(--glass-border);
            border-radius: 12px;
            corner-shape: superellipse(1.5);
            object-fit: cover;
        }
        .item-card-info { padding: 0 0 4px 0; }
        .item-card-title { font-weight: 500; }
        .item-card-subtitle { font-size: 14px; color: var(--secondary-text-color); }
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .item-card:active {
            transform: scale(0.96);
            transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }

        .library-controls {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px;
            flex-direction: row;
            justify-content: center;
            align-content: center;
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            top: calc(70px + env(safe-area-inset-top));
        }

        #library-controls {
            top: calc(20px + env(safe-area-inset-top));
        }

        @media (max-width: 470px) {
            #library-controls {
                flex-wrap: wrap-reverse;
            }

            #library-view {
                padding-top: calc(130px + env(safe-area-inset-top)) !important;
            }
        }

        @media (max-width: 330px) {
            #tidal-controls {
                flex-wrap: wrap-reverse;
            }

            #tidal-view {
                padding-top: calc(130px + env(safe-area-inset-top)) !important;
            }
        }

        .search-container {
            position: relative;
            flex-grow: 1;
            min-width: 200px;
            margin-bottom: 10px;
        }

        .library-search-input {
            width: 100%;
            padding: 10px 15px 10px 40px;
            border-radius: 25px;
            border: 1px solid var(--glass-border);
            background: var(--search-background);
            color: var(--text-color);
            backdrop-filter: blur(8px);
            font-size: 14px;
            outline: none;

        }
        
        .search-icon {
            font-size: 22px;
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text-color);
            pointer-events: none;
        }

        .filter-container, .view-controls, .library-actions {
            display: flex;
            gap: 10px;
        }

        .filter-container .filter-btn, .filter-container .filter-btn-sc {
            padding: 8px 18px;
            border-radius: 50px;
            text-wrap-mode: nowrap;
        }

        .filter-container .filter-btn:active, .filter-container .filter-btn-sc:active {
            transform: scale(1);
            padding: 8px 20px;
            filter: brightness(1.5);
        }

        .filter-container .filter-btn.active, .filter-container .filter-btn-sc.active {
            background: var(--accent);
            color: var(--background-color);
            font-weight: 500;
        }
        
        .filter-container .filter-btn .material-symbols-rounded, .filter-container .filter-btn-sc .material-symbols-rounded{
            font-size: 22px;
        }
        
        .action-btn {
            background-color: var(--search-background);
            color: var(--text-color);
            border: none;
            border-radius: 50px;
            padding: 12px 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border);
            font-weight: 500;
        }

        .library-action-btn {
            background-color: var(--search-background);
            backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border);
            color: var(--text-color);
            border-radius: 50px;
            padding: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 46px;
            aspect-ratio: 1 / 1;
        }

        .library-action-btn.active {
            background-color: var(--accent);
            color: var(--background-color);
        }

          @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, 20px); }
            10% { opacity: 1; transform: translate(-50%, 0); }
            90% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
          }
        
        .music-list::-webkit-scrollbar,
        #lyrics-queue-panel::-webkit-scrollbar,
        .lyrics-container::-webkit-scrollbar {
            width: 4px;
        }
                
        .music-list::-webkit-scrollbar-track,
        #lyrics-queue-panel::-webkit-scrollbar-track,
        .lyrics-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, .0);
        }
        
        .music-list::-webkit-scrollbar-thumb,
        #lyrics-queue-panel::-webkit-scrollbar-thumb,
        .lyrics-container::-webkit-scrollbar-thumb {
            background: var(--modal-transparent);
            border-radius: 4px;
        } 

        #queue-list-container {
            gap: 10px;
            display: flex;
            flex-direction: column;
        }
        
        .upload-btn {
            background-color: var(--search-background);
            color: var(--text-color);
            backdrop-filter: blur(8px);
            border-radius: 25px;
            padding: 10px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex; 
            align-items: center;
            border: 1px solid var(--glass-border);
            gap: 6px;
        }
        
        .music-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            flex-grow: 1;
            border-radius: 10px;
        }

        .music-item.dragging, .album-section.dragging, .queue-item.dragging {
          opacity: 0.5;
          background-color: var(--modal-background);
          box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
          position: relative;
          z-index: 1000;
          transition: transform 0.1s ease;
          border-radius: 12px;
        }
        
        .music-item {
            padding: 8px 12px;
            background-color: transparent;
            border-bottom: 1px solid var(--modal-background);
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.3s ease;
            cursor: grab;
            touch-action: pan-y;
            overflow: hidden;
            min-height: fit-content;
            position: relative;
            corner-shape: superellipse(1.5);
        }

        .music-item.current-track, .item-card.current-track {
            background-color: var(--accent) !important;
            color: var(--background-color) !important;
            transition: all 0.3s ease;
        }
        .music-item.current-track .song-artist, 
        .music-item.current-track .album-artist,
        .music-item.current-track .track-number {
            color: var(--background-color) !important;
            opacity: 0.8;
        }

        .queue-item {
            padding: 8px 1px;
            background-color: transparent;
            border: none;
            border-radius: 0;
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.3s ease;
            cursor: grab;
            touch-action: pan-y;
            overflow: hidden;
            min-height: fit-content;
            position: relative;
            box-shadow: none;
        }
        
        .music-item.active {
            background-color: var(--background-color) !important;
            font-weight: bold;
            border-radius: 40px;
            transition: all 0.3s ease;
        }

        .queue-item.active {
            background-color: var(--search-background) !important;
            font-weight: bold;
            border-radius: 16px;
            transition: all 0.3s ease;
            padding: 5px 1px;
            border: 1px solid var(--glass-border);
            margin: 3px 0;
            backdrop-filter: blur(8px);
        }

        /* Quality/Explicit Badges in lists */
        .meta-badges {
            display: flex;
            gap: 4px;
            margin-top: 2px;
        }
        .badge {
            font-size: 9px;
            padding: 1px 4px;
            border-radius: 4px;
            background: var(--glass-border);
            color: var(--secondary-text-color);
            font-weight: bold;
            text-transform: uppercase;
        }
        .badge.explicit { background-color: var(--accent); color: var(--background-color); }
        
        /* Search History Pills */
        .history-pill {
            padding: 8px 16px;
            background: var(--search-background);
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            border: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            gap: 8px;
        }
            
        .album-art {
            border-radius: 12px;
            corner-shape: superellipse(1.5);
            background-color: var(--modal-transparent);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: transform 0.3s cubic-bezier(.3,1.2,.64,1), opacity 0.3s ease;
            max-width: 600px;
            max-height: 600px;
            aspect-ratio: 1 / 1;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.05);
            margin-top: 60px;
            outline: 1px solid var(--glass-border);
            transform: scale(1);
            height: calc(100vw - 30px);
        }

        #now-playing-view.paused .album-art {
            transform: scale(0.8);
        }

        .album-art.fade-out {
            opacity: 0;
            transform: scale(0.95);
        }
        
        .album-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 12px;
            corner-shape: superellipse(1.5);
        }

        /* Generic Modal Styling */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: var(--overlay-color);
            z-index: 1007;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
            display: flex;
        }

        #drawer-overlay {
            display: flex !important;
        }
        
        .music-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-color);
            text-align: left;
            max-width: 600px;
            width: 100%;
            transition: opacity 0.3s ease;
        }
        
        .music-text {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 4px;
            min-width: 0;
            padding-right: 16px;
            width: 0
        }
        
        .music-title {
            font-size: 1.1rem;
            word-wrap: break-word;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
        }
        
        .music-artist {
            color: var(--secondary-text-color);
            font-size: 1.1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.3;
            font-weight: 500;
        }
        
        .more-button {
            margin-left: 14px;
            background: var(--search-background) !important;
            width: 28px !important;
            height: 28px !important;
        }
        
        .quality-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 500;
            margin-top: 5px;
            background: var(--search-background);
            color: var(--text-color);
        }
        
        .quality-lossless {
            background: rgba(189, 214, 255, .2);
            color: #bdd6ff;
        }
        
        .quality-enhanced {
            background: rgba(144, 238, 144, .2);
            color: #90ee90;
        }
        
        .quality-normal {
            background: rgba(255, 255, 255, .2);
            color: var(--text-color);
        }
                
        .player-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            max-width: 600px;
            box-sizing: border-box;
            width: 100%;
            justify-content: space-evenly;
            margin-bottom: 80px;
            transition: opacity 0.3s ease;
        }
        
        .player-controls button:nth-child(2),
        .player-controls button:nth-child(3),
        .player-controls button:nth-child(4) {
            order: 1; /* Middle group gets priority */
        }
        
        .player-controls button:nth-child(1) {
            order: 0; /* Shuffle on the left */
        }
        
        .player-controls button:nth-child(5) {
            order: 2; /* Repeat on the right */
        }
                
        .control-btn {
            background: transparent;
            border: none;
            color: var(--text-color);
            width: 50px;
            height: 50px;
            border-radius: 35px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 0;
        }
        
        .control-btn.play-pause {
            background-color: transparent;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            border-radius: 35px;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 0;
        }
        
        .control-btn.play-pause.playing {
            border-radius: 35px;
            corner-shape: superellipse(1.5);
        }
        
        .progress-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 600px;
            transition: opacity 0.3s ease;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--search-background);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.25s ease;
            backdrop-filter: blur(8px);
            box-shadow: var(--sun-shadow), 0 0 0 1px var(--glass-border);
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: var(--secondary-text-color);
            border-radius: 25px;
            width: 0%;
            transition: all 0.25s ease;
            border: 1px solid var(--glass-border);
        }
        
        .time-info {
            display: flex;
            justify-content: space-between;
            color: var(--secondary-text-color);
            font-variant-numeric: tabular-nums;
            font-size: 0.9rem;
        }

        #player-status {
            font-weight: 600;
        }
        
        .controls-container {
            display: flex;
            align-items: center;
            gap: 12px;
            position: fixed;
            bottom: 30px;
            z-index: 10;
        }
        
        .controls-container span {
            color: var(--text-color);
            font-size: 18px;
        }

        #visualizerCanvas {
            width: 24px;
            height: 24px;
            vertical-align: middle;
        }

        .lyrics-button, .queue-button, .more-button, .controls-container-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            width: 37px;
            height: 37px;
            color: var(--text-color);
            border-radius: 50%;
            transition: all 0.2s;
        }

        .goto-btn {
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            cursor: pointer;
            padding: 10px 16px;
            color: var(--text-color);
            border-radius: 25px;
            transition: background 0.2s ease;
            backdrop-filter: blur(8px);
        }

        .lyrics-button.active, .queue-button.active {
            background: var(--text-color);
            color: var(--background-color);
            border-radius: 50%;
        }

        .lyrics-button.active .material-symbols-rounded, .queue-button.active .material-symbols-rounded {
            color: var(--background-color);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--search-background);
            border-radius: 25px;
            padding: 5px 10px 5px 10px;
            backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border);
            height: 37px;
            width: 100px;
        }
        
        .volume-control span {
            color: var(--text-color);
            font-size: 20px;
        }
        
        .volume-slider {
            width: 100%;
            height: 25px;
            -webkit-appearance: none;
            background: rgba(0, 0, 0, .0);
            outline: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: var(--secondary-text-color);
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid var(--glass-border);
            transition: width 0.3s, height 0.3s, transform 0.3s;
        }

        .volume-slider::-webkit-slider-thumb:active {
            width: 21px;
            height: 21px;
            transform: scale(1.1);
        }

        .volume-slider::-moz-range-thumb {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: 1px solid var(--glass-border);
            transition: width 0.3s, height 0.3s, transform 0.3s;
        }

        .volume-slider::-moz-range-thumb:active {
            width: 21px;
            height: 21px;
            transform: scale(1.1);
        }
        
        .album-section {
            padding: 20px 0 10px;
            border-top: 1.5px solid var(--glass-border);
        }

        .album-section::after {
          content: '';
          position: absolute;
          left: 0;
          right: 0;
          height: 2px;
          background: transparent;
          transition: background 0.3s;
        }
        
        .album-section.drag-over::after {
          background: var(--text-color);
        }
        
        .album-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            cursor: grab;
            position: relative;
        }
        
        .album-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 25px;
            corner-shape: superellipse(1.5);
            object-fit: cover;
            box-shadow: 0 0 0 1px var(--glass-border);
        }
        
        .album-info {
            color: var(--text-color);
        }
        
        .album-name {
            font-weight: 600;
            font-size: 1.1em;
        }
        
        .album-artist, .album-year {
            color: var(--text-color);
            font-size: 0.9em;
        }
        
        .album-songs {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .song-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .track-number {
            color: var(--secondary-text-color);
            min-width: 25px;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }
        
        .album-actions {
            position: absolute;
            right: 10px;
            top: 10px;
        }
        
        .delete-album {
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        
        .song-title {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .drag-placeholder {
          height: 2px;
          background-color: var(--text-color);
          transition: all 0.2s ease;
        }
        
        @keyframes pulse {
          0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
          70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
          100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }
        
        .music-item.dragging, .album-section.dragging, .queue-item.dragging {
          animation: pulse 1.5s infinite;
        }
        
        .background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -9999;
        }
                        
        #distortion-container {
            position: fixed;
            inset: 0;
            overflow: hidden;
            z-index: -9998;
            filter: blur(clamp(25px, 2.5vw, 100px)) brightness(0.6);
            scale: 1.3;
            opacity: 1;
        }

        body.light-theme #distortion-container {
            opacity: 0.6; /* 60% opacity for light theme */
            filter: blur(clamp(25px, 2.5vw, 100px)) saturate(3) brightness(1);
        }

        html.high-contrast #distortion-container {
            display: none !important; /* Do NOT display for high contrast */
        }

        #distortionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        @keyframes rotate {
            from {
                transform: scale(1.42) rotate(0deg);
            }
            to {
                transform: scale(1.42) rotate(360deg);
            }
        }
        
        .search-container {
            position: relative;
        }
        
        .search-input {
            width: 100%;
            padding: 10px 15px 10px 40px;
            border-radius: 25px;
            border: 1px solid var(--glass-border);
            background: var(--search-background);
            color: var(--text-color);
            backdrop-filter: blur(8px);
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
            flex-grow: 1;
        }
        
        .search-input:focus {
            border-color: var(--modal-background);
        }
        
        .search-input::placeholder {
            color: var(--secondary-text-color);
        }
        
        .search-icon {
            font-size: 20px;
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text-color);
            pointer-events: none;
            z-index: 1;
        }

        .filter-container {
            display: flex;
            gap: 0;
            justify-content: center;
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            border-radius: 50px;
            backdrop-filter: blur(8px);
            padding: 4px;
        }
        
        .filter-btn, .filter-btn-sc {
            flex: 1;
            padding: 8px 10px;
            border-radius: 50px;
            border: none;
            background: transparent;
            color: var(--secondary-text-color);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .filter-btn.active, .filter-btn-sc.active {
            background: var(--accent);
            color: var(--background-color);
        }

        .filter-separator {
            width: 3px;
            background: var(--search-background);
            border-radius: 5px;
            margin: 10px 5px;
        }
        
        #shuffleBtn.active, #repeatBtn.active {
            backdrop-filter: blur(8px);
            background: var(--search-background);
        }
                
        .material-symbols-rounded {
          font-variation-settings:
          'FILL' 1,
          'wght' 700,
          'GRAD' 0,
          'opsz' 24;
          vertical-align: middle;
        }
        
        .no-results {
            color: var(--text-color);
            text-align: center;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .no-results .material-symbols-rounded {
            font-size: 48px;
        }
        
        .no-results p {
            font-size: 14px;
        }
        
        /* For all clickable elements */
        [onclick], 
        button, 
        a, 
        input[type="button"], 
        input[type="submit"],
        .clickable {
          cursor: pointer;
          transform: scale(1);
          transition: all 0.15s cubic-bezier(0.2, 0, 0.38, 0.9);
        }
        
        /* Active effect (when clicking down) */
        [onclick]:active, 
        button:active, 
        a:active, 
        input[type="button"]:active, 
        input[type="submit"]:active,
        .clickable:active {
          transform: scale(0.96);
          transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
          filter: brightness(1.5);
        }

        @media (min-width: 560px) {
            .controls-container {
                position: fixed;
                bottom: 30px;
                right: 30px;
            }

            #lyrics-queue-panel {
                transform-origin: right bottom !important;
            }
        }
        
        @media (max-width: 800px) {
            .player-controls {
                gap: 15px;
            }
        }

        @media (min-width: 600px) {
            .drawer {
                left: 5vw !important;
                width: 90vw !important;
                border: 1px solid var(--glass-border);
            }
        }

        @media (min-width: 800px) {
            .drawer {
                left: 15vw !important;
                width: 70vw !important;
                border: 1px solid var(--glass-border);
            }
        }

        @media (min-width: 1000px) {
            .drawer {
                left: 25vw !important;
                width: 50vw !important;
                border: 1px solid var(--glass-border);
            }
        }

        @media (max-width: 560px) {
            #now-playing-view {
                padding: 0 10px 0 10px;
            }

            .music-info, .progress-container, .player-controls {
                padding: 0 10px !important;
            }
            
            .now-playing-wrapper {
                gap: 4vh !important;
            }

            .drawer {
                height: calc(100% - 80px); /* Full height minus top toolbar */
            }

            .player-controls {
                margin-bottom: 110px;
            }

            .controls-container {
                gap: 5px;
                bottom: 40px;
                width: 90%;
                justify-content: space-evenly;
                padding: 0 10px;
                max-width: 600px;
                width: 100%;
                transform: translateX(-50%);
                left: 50%;
            }

            .volume-control {
                background: none;
                border: 1px solid transparent;
                backdrop-filter: none;
                box-shadow: none;
                padding: 0;
            }
            
            @media (max-height: 760px) {
                .now-playing-wrapper {
                    gap: 2vh !important;
                }

                .player-controls {
                    margin-bottom: 95px;
                }
            }
        }
        
        /* When animations are disabled */
        .reduce-animations * {
            /* Disable all animations */
            animation: none !important;
        
            /* Disable all transitions except opacity */
            transition: opacity 0.3s ease !important;
            transition-property: opacity !important;
        }
        
        /* Special handling for clickable elements */
        .reduce-animations [onclick],
        .reduce-animations button,
        .reduce-animations a,
        .reduce-animations input[type="button"],
        .reduce-animations input[type="submit"],
        .reduce-animations .clickable {
            /* Keep initial state but remove transition */
            transform: scale(1) !important;
            transition: opacity 0.3s ease !important;
        }
        
        /* Keep active state functional but without animation */
        .reduce-animations [onclick]:active,
        .reduce-animations button:active,
        .reduce-animations a:active,
        .reduce-animations input[type="button"]:active,
        .reduce-animations input[type="submit"]:active,
        .reduce-animations .clickable:active {
            /* Apply scale instantly without transition */
            transform: scale(0.98) !important;
            transition: none !important;
            filter: brightness(1.5) !important;
        }
        
        /* Adjust for background image with light/dark theme */
        body[style*="background-image"] .music-title,
        body[style*="background-image"] .music-artist,
        body[style*="background-image"] .music-album,
        body[style*="background-image"] .time-info {
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        body.light-theme[style*="background-image"] .music-title,
        body.light-theme[style*="background-image"] .music-artist,
        body.light-theme[style*="background-image"] .music-album,
        body.light-theme[style*="background-image"] .time-info {
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* Lyrics and Queue styles */
        .sidebar-back-btn {
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(8px);
            color: var(--text-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            padding: 8px 15px;
            border-radius: 25px;
            width: fit-content;
        }

        .lyrics-container {
            height: 100%;
            overflow-y: auto;
            scroll-behavior: smooth;
            scroll-padding-top: 30vh;
            padding-bottom: 70vh; /* Ensures last line can also scroll to the sweet spot */
        }

        .lyrics-container p {
            white-space: pre-wrap;
            transition: all 0.4s ease-out; /* Smooth transition for filter and opacity */
            margin: 18px 0;
            padding: 0 10px;
            border-radius: 14px;
            corner-shape: superellipse(1.5);
            cursor: pointer;
            font-size: 1.8rem;
            font-weight: 600;
            line-height: 1.6; /* Improves readability */
        }

        .lyrics-container p.lyric-aside {
            font-size: 1.25rem;
            font-weight: normal;
            color: var(--secondary-text-color);
            margin: -10px 0 18px 0;
            opacity: 0.8;
            cursor: default;
        }

        .lyrics-container #lyric-line-0 {
            padding-top: 30vh;
        }

        .lyrics-container p.active {
            background: var(--search-background);
            scale: 0.96;
        }
 
        .queue-item .song-info {
            display: flex;
            align-items: center;
            width: 100%;
            gap: 8px;
        }
        
        .queue-item .song-title {
            flex-grow: 1;
        }
        
        .queue-item .song-artist-queue {
            color: var(--secondary-text-color);
            font-size: 0.9em;
            flex-shrink: 0;
            max-width: 100px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            box-shadow: none;
        }
        
        .remove-from-queue-btn {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            cursor: pointer;
            padding: 10px 5px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            opacity: 0.5;
        }
        
        .queue-list-container {
            display: flex;
            flex-direction: column;
            gap: 10px; /* This adds the required space between queue items */
            padding-bottom: 50vh;
        }

        .more-options-menu {
            position: absolute;
            background-color: var(--search-background);
            border-radius: 35px;
            corner-shape: superellipse(1.5);
            padding: 8px 10px;
            backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border);
            z-index: 100;
            width: 200px;
            box-shadow: var(--sun-shadow), 0 4px 20px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(10px) scale(0.95) scaleY(0.9);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: bottom;
        }

        .more-options-menu.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .context-menu {
            position: fixed;
            background-color: var(--search-background);
            border-radius: 35px;
            corner-shape: superellipse(1.5);
            padding: 8px 10px;
            backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border);
            z-index: 10001;
            min-width: 180px;
            box-shadow: var(--sun-shadow), 0 4px 20px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateY(10px) scale(0.95) scaleY(0.9);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top;
            white-space: nowrap;
        }

        .context-menu.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-radius: 12px;
            corner-shape: superellipse(1.5);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .menu-item .material-symbols-rounded {
            font-size: 20px;
        }

        .menu-separator {
            height: 1px;
            background-color: var(--glass-border);
            margin: 8px 0;
        }

        .view-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .now-playing-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 2vh;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100%;
            max-width: 100vw;
            box-sizing: border-box;
            padding: 5px;
        }

        .player-column {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 2vh;
            max-width: 600px;
            transition: max-width 0.4s ease;
        }
        
        #lyrics-queue-panel {
            height: 100%;
            max-height: 100vh;
            flex-shrink: 0;
            padding: 5px 5px 5px 20px;
            display: none;
            flex-direction: column;
            gap: 15px;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            pointer-events: none;
            overflow: auto;
            transform: translateX(20px) scale(0.9) scaleX(0.9);
            z-index: 5;
            width: 50%;
            transform-origin: right;
            filter: blur(1px);
            align-items: flex-start;
            justify-content: center;
        }
        
        #lyrics-queue-panel.visible {
            display: flex;
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
            filter: none;
        }

        @media (min-width: 1251px) {
            .lyrics-container {
                width: 100%;
                max-width: 600px;
                height: 70vh;
            }

            .now-queue {
                width: 100%;
                max-width: 600px;
                height: 70vh;
            }
        }

        @media (max-width: 1250px) {
            #lyrics-queue-panel {
                height: calc(100vh - 160px);
                flex-shrink: 0;
                padding: 15px;
                display: flex;
                flex-direction: column;
                gap: 15px;
                opacity: 0;
                transform: translateX(20px);
                transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
                pointer-events: none;
                overflow: auto;
                position: absolute;
                top: 50%;
                transform: translateY(-50%) scale(0.9) scaleY(0.9);
                z-index: 5;
                width: 100%;
                max-width: -webkit-fill-available;
                transform-origin: bottom;
                filter: blur(1px);
                margin: 0 2vw;
                align-items: center;
                justify-content: start;
            }

            #now-playing-view.panel-is-open .now-playing-wrapper > *:not(.controls-container):not(#moreOptionsMenu):not(.hitpoint-drawer-handle-player) {
                opacity: 0;
            }
            
            #lyrics-queue-panel.visible {
                opacity: 1;
                transform: translateY(-50%);
                pointer-events: auto;
                filter: none;
                padding: 0 10px;
            }

            .lyrics-container {
                width: 100%;
                max-width: none;
            }

            .now-queue {
                width: 100%;
                max-width: none;
            }
        }

        /* --- Grid View Styles --- */
        .music-list.grid-view {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            align-content: start;
        }

        .music-list.grid-view .music-item {
            height: max-content;
        }

        .music-list.grid-view .album-section {
            padding: 0;
            border-top: none; /* No dividers in grid view */
            display: flex;
            flex-direction: column;
            cursor: pointer; /* Albums are clickable in grid view */
        }
        
        .music-list.grid-view .album-header {
            margin-bottom: 8px;
            flex-direction: column;
            gap: 8px;
            cursor: default; /* No dragging albums in grid view */
        }

        .music-list.grid-view .album-thumbnail {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
        }

        .music-list.grid-view .album-info {
            width: 100%;
            text-align: left;
        }

        .music-list.grid-view .album-name {
            font-size: 1em;
            white-space: normal;
        }
        
        .music-list.grid-view .album-artist {
            font-size: 0.85em;
        }
        
        .music-list.grid-view .album-year {
            display: none; /* Hide year in grid view for space */
        }

        .music-list.grid-view .album-songs {
            display: none; /* Hide individual songs in album grid view */
        }

        /* Song-level grid view */
        .music-list.grid-view.songs-mode .music-item,
        .music-list.grid-view.artists-mode .music-item {
             padding: 8px;
             display: flex;
             flex-direction: column;
             gap: 8px;
             align-items: center;
             text-align: center;
        }
        .music-list.grid-view.songs-mode .song-info,
        .music-list.grid-view.artists-mode .song-info {
            flex-direction: column;
            gap: 8px;
        }
        .music-list.grid-view.songs-mode .album-thumbnail,
        .music-list.grid-view.artists-mode .album-thumbnail {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
            margin-right: 0;
        }
        .music-list.grid-view.songs-mode .song-title,
        .music-list.grid-view.artists-mode div[style*="font-size: 1em;"] {
            white-space: normal;
        }

        .item-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-bottom: 125px;
        }
        .album-section-list {
            border-radius: 12px;
            cursor: pointer;
            padding: 10px;
        }
        .album-header-list {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* --- Song Context Menu Styles --- */
        .music-item .song-actions,
        .album-header .song-actions {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-text-color);
            background: none;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
            transition: opacity 0.2s, background-color 0.2s;
            z-index: 5;
        }

        /* App Drawer Styles */
        .drawer {
            position: fixed;
            bottom: -100%; /* Initially hidden */
            left: 0;
            width: 100%;
            background-color: var(--search-background); 
            z-index: 1008;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            backdrop-filter: blur(10px);
            border-top: 1px solid var(--glass-border);
            border-radius: 50px 50px 0 0;
            corner-shape: superellipse(1.5);
            transform-origin: bottom;
            will-change: transform, opacity, bottom;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
            max-height: calc(100% - 80px);
        }

        .drawer.open {
            bottom: 0;
        }

        .drawer-handle {
            width: 50px;
            height: 5px;
            background-color: var(--secondary-text-color);
            border-radius: 3px;
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            cursor: grab;
        }

        .hitpoint-drawer-handle-player {
            padding: 10px;
            position: absolute;
            top: env(safe-area-inset-top);
            left: 50%;
            transform: translateX(-50%);
            cursor: grab;
            z-index: 2;
        }

        .drawer-handle-player {
            width: 75px;
            height: 5px;
            background-color: var(--overlay-color-op);
            border-radius: 3px;
        }

        .drawer-content {
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            user-select: none;
            padding: 20px 20px 0 20px;
        }
        
        .drawer-content::-webkit-scrollbar { width: 4px; }
        .drawer-content::-webkit-scrollbar-track { background: transparent; }
        .drawer-content::-webkit-scrollbar-thumb { background: var(--modal-transparent); border-radius: 4px; }
        
        .drawer-header {
            padding: 40px 20px 10px 20px;
            text-align: center;
        }
        #drawer-title { font-size: 1.5rem; }
        #drawer-subtitle { color: var(--secondary-text-color); }

        .highlight-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-bottom: 40px;
        }
        .highlight-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));
            border: 1px solid var(--glass-border);
            border-radius: 35px;
            corner-shape: superellipse(1.5);
            padding: 10px 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(.3, 1.2, .64, 1);
            backdrop-filter: saturate(0) blur(8px);
        }
        .highlight-card:active {
            transform: scale(0.96);
            transition: all 0.1s cubic-bezier(0.2, 0, 0.38, 0.9);
            filter: brightness(1.5);
        }
        .highlight-card img {
            width: 40px;
            height: 40px;
            scale: 1.1;
            border-radius: 14px;
            corner-shape: superellipse(1.5);
            box-shadow: 0 0 0 1px var(--glass-border);
            flex-shrink: 0;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        @media (max-width: 400px) {
            .highlight-card img {
                display: none;
            }
        }
        .highlight-card-info {
            flex-grow: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        .highlight-card-label {
            font-size: 12px;
            color: var(--secondary-text-color);
        }
        .highlight-card-title {
            font-size: 1rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .highlight-card-subtitle {
            color: var(--secondary-text-color);
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .highlight-card-play {
            margin-left: auto;
            font-size: 36px;
            transition: all 0.3s cubic-bezier(.3,1.2,.64,1);
        }
        
        .song-item-actions {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            margin-left: auto;
            padding: 5px;
            border-radius: 50%;
            cursor: pointer;
        }

        .loading-message {
            position: absolute;
            left: 50%;
            top: 50%;
        }

        #drawer-delete-playlist-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s, background-color 0.2s;
            color: var(--text-color);
        }

        /* Radio Mode Styles */
        body.radio-mode .queue-button {
            display: none;
        }

        body.radio-mode #prevBtn, body.radio-mode #miniplayer-prev-btn {
            pointer-events: none;
            opacity: 0.5;
        }

        body.radio-mode #shuffleBtn, body.radio-mode #repeatBtn {
            display: none;
        }

        body.radio-mode .now-queue {
            display: none;
        }
        
        /* Hide queue controls in radio mode */
        .radio-locked .remove-from-queue-btn {
            display: none !important;
        }
        .radio-locked .queue-item {
            cursor: default !important;
        }

        /* Playlist Edit Mode Styles */
        .playlist-drag-handle {
            display: none;
            color: var(--secondary-text-color);
            cursor: grab;
            margin-right: 10px;
            touch-action: none;
        }
        
        .edit-mode .playlist-drag-handle {
            display: flex;
            align-items: center;
        }

        .edit-mode .song-item-actions {
            color: var(--accent); /* Red delete icon in edit mode */
            opacity: 1;
        }

        .edit-mode .music-item {
            padding-left: 5px; /* Make room for handle */
        }
        
        /* Browse Pills */
        .genre-pill {
            padding: 10px 20px;
            background: var(--search-background);
            border: 1px solid var(--glass-border);
            border-radius: 25px;
            color: var(--text-color);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(8px);
        }

        /* Toast Notification */
        #toast-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast-message {
            background-color: var(--modal-background);
            color: var(--text-color);
            padding: 12px 24px;
            border-radius: 25px;
            corner-shape: superellipse(1.5);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            text-align: left;
            width: fit-content;
        }

        .toast-message.show {
            opacity: 1;
        }
    </style>
</head>
<body data-app-name="STREAMS">
    <svg style="position: absolute; width: 0; height: 0;">
        <filter id="albumArtDistortion">
            <feTurbulence 
                id="turbulence"
                type="turbulence" 
                baseFrequency="0.01 0.02" 
                numOctaves="1" 
                seed="0"
            />
            <feGaussianBlur stdDeviation="30" result="blurredTurbulence"/>
            <feDisplacementMap 
                id="displacement"
                in="SourceGraphic" 
                in2="blurredTurbulence" 
                scale="0" 
                xChannelSelector="R" 
                yChannelSelector="G"
            />
        </filter>
    </svg>

    <svg style="display: none">
        <filter id="edge-refraction-only" color-interpolation-filters="linearRGB">
            <!-- Part 1: Generate the edge turbulence pattern -->
            <feTurbulence type="fractalNoise" baseFrequency="0.04" numOctaves="2" result="turbulence"></feTurbulence>
            <feMorphology in="SourceGraphic" operator="erode" radius="4" result="eroded"></feMorphology>
            <feComposite in="SourceGraphic" in2="eroded" operator="out" result="border_mask"></feComposite>
            <feComposite in="turbulence" in2="border_mask" operator="in" result="edge_turbulence"></feComposite>
    
            <!-- Part 2: Create the two displacement passes -->
            <feDisplacementMap in="SourceGraphic" in2="edge_turbulence" scale="15" xChannelSelector="R" yChannelSelector="G" result="disp_positive"></feDisplacementMap>
            <feDisplacementMap in="SourceGraphic" in2="edge_turbulence" scale="-15" xChannelSelector="R" yChannelSelector="G" result="disp_negative"></feDisplacementMap>
    
            <!-- Part 3: Create masks to isolate the correct halves of each pass -->
            <!-- Mask for the Top-Left Half -->
            <feFlood flood-color="white" width="50%" height="50%" x="0" y="0" result="topLeftRect"></feFlood>
            <!-- Mask for the Bottom-Right Half -->
            <feFlood flood-color="white" width="50%" height="50%" x="50%" y="50%" result="bottomRightRect"></feFlood>
    
            <!-- Part 4: Apply the masks -->
            <!-- Isolate the correctly refracted top-left from the positive pass -->
            <feComposite in="disp_positive" in2="topLeftRect" operator="in" result="topLeft_part"></feComposite>
            <!-- Isolate the correctly refracted bottom-right from the negative pass -->
            <feComposite in="disp_negative" in2="bottomRightRect" operator="in" result="bottomRight_part"></feComposite>
    
            <!-- 
               Part 5: Merge the perfectly isolated parts.
               Because there is no overlap, 'lighten' works perfectly, but you could also use feMerge.
            -->
            <feBlend in="topLeft_part" in2="bottomRight_part" mode="lighten" result="blended_image"></feBlend>
            
            <!-- Part 6: Adjust final opacity -->
            <feComponentTransfer in="blended_image">
                <feFuncA type="linear" slope="0.95"></feFuncA>
            </feComponentTransfer>
        </filter>
    </svg>

    <div class="toolbar">
        <div class="toolbar-btns">
            <button class="tab-btn active" data-view="home">
                <span class="material-symbols-rounded">Home</span>
                Home
            </button>
            <button class="tab-btn" data-view="tidal" id="tidal-tab" style="display: none;">
                <span class="material-symbols-rounded">grid_view</span>
                Browse
            </button>
            <button class="tab-btn" data-view="radio">
                <span class="material-symbols-rounded">wifi_tethering</span>
                Radio
            </button>
            <button class="tab-btn" data-view="library">
                <span class="material-symbols-rounded">books_movies_and_music</span>
                Library
            </button>
            <button class="tab-btn" data-view="search">
                <span class="material-symbols-rounded">search</span>
                Search
            </button>
        </div>
    </div>

    <div id="home-view" class="view-container">
        <!-- Home page content will be rendered here -->
        <div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>
    </div>
    <div id="library-view" class="view-container" style="display: none; padding-top: calc(80px + env(safe-area-inset-top));">
        <div class="page-content-wrapper">
            <div class="library-controls" id="library-controls">
                <div class="filter-container">
                    <button class="filter-btn active" data-filter="albums">Albums</button>
                    <button class="filter-btn" data-filter="artists">Artists</button>
                    <button class="filter-btn" data-filter="songs">Songs</button>
                    <button class="filter-btn" data-filter="playlists">Playlists</button>
                </div>
                <div class="view-controls">
                    <button id="sortBtn" class="library-action-btn"><span class="material-symbols-rounded">history</span><span id="sort-mode-display"></span></button>
                </div>
                 <div class="library-actions">
                    <button class="library-action-btn" id="uploadBtn" style="display: none"><span class="material-symbols-rounded">add</span></button>
                    <button class="library-action-btn" id="manageFoldersBtn"><span class="material-symbols-rounded">more_horiz</span></button>
                </div>
            </div>
            <div id="library-grid" class="item-grid" style="padding-bottom: 240px;">
                <!-- Library content will be rendered here -->
            </div>
             <input type="file" accept="audio/*" style="display: none" id="musicUpload" multiple webkitdirectory>
        </div>
    </div>
    <div id="radio-view" class="view-container" style="display: none;">
        <div class="page-content-wrapper">
            <div class="search-container" style="position: absolute; top: calc(20px + env(safe-area-inset-top)); width: 90%; z-index: 1; left: 50%; transform: translateX(-50%);">
                <span class="material-symbols-rounded search-icon" style="padding-left: 2px;">play_circle</span>
                <input type="text" id="radioSearchInput" placeholder="Start a station" class="library-search-input" style="box-shadow: var(--sun-shadow), 0 0 15px rgba(0, 0, 0, 0.05); padding: 12px 17px 12px 42px;">
            </div>
            
            <div id="radio-suggestions" style="padding-top: 70px;">
                <h3 class="section-title" style="font-size: 1.2rem;">Stations for You</h3>
                <div id="radio-grid" class="item-grid">
                    <!-- Dynamic stations based on library -->
                </div>
            </div>
        </div>
    </div>
    <div id="tidal-view" class="view-container" style="display: none; calc(20px + env(safe-area-inset-top));">
        <div class="page-content-wrapper">
            <div class="library-controls" id="tidal-controls">
                <div class="filter-container" id="tidal-filter-container">
                    <button class="filter-btn-sc" data-filter="albums">Albums</button>
                    <button class="filter-btn-sc" data-filter="artists">Artists</button>
                    <button class="filter-btn-sc active" data-filter="tracks">Songs</button>
                    <button class="filter-btn-sc" data-filter="playlists">Playlists</button>
                </div>
                <div class="search-container" id="tidal-offline-search-container" style="display: none; max-width: 246px; margin: 0px;">
                    <span class="material-symbols-rounded search-icon">search</span>
                    <input type="text" id="tidalOfflineSearchInput" placeholder="Search your history" class="library-search-input">
                </div>
                <div class="library-actions">
                    <button class="library-action-btn" id="tidalOfflineToggle">
                        <span class="material-symbols-rounded">history</span>
                    </button>
                </div>
            </div>
            
            <div class="search-container" id="tidal-search-container" style="position: absolute; top: calc(20px + env(safe-area-inset-top)); width: 90%; z-index: 1; left: 50%; transform: translateX(-50%);">
                <span class="material-symbols-rounded search-icon" style="padding-left: 2px;">search</span>
                <input type="text" id="tidalSearchInput" placeholder="Search" class="library-search-input" style="box-shadow: var(--sun-shadow), 0 0 15px rgba(0, 0, 0, 0.05); padding: 12px 17px 12px 42px;">
            </div>
            
            <div id="tidal-browse-container" style="padding-top: calc(124px + env(safe-area-inset-top)); padding-bottom: 240px; display: none;">
                <h3 class="section-title" style="font-size: 1.2rem;">Popular</h3>
                <div id="tidal-trending-grid" class="item-grid"></div>
            </div>
            
            <div id="tidal-results-grid" class="item-grid" style="padding-top: calc(124px + env(safe-area-inset-top)); padding-bottom: 240px;">
                <!-- tidal search/offline results will be rendered here -->
            </div>
        </div>
    </div>
    <div id="search-view" class="view-container" style="display: none;">
        <div class="page-content-wrapper">
            <div class="search-container" style="position: absolute; top: calc(20px + env(safe-area-inset-top)); width: 90%; z-index: 1; left: 50%; transform: translateX(-50%);">
                <span class="material-symbols-rounded search-icon" style="padding-left: 2px;">search</span>
                <input type="text" id="searchInput" placeholder="Search your Library" class="library-search-input" style="box-shadow: var(--sun-shadow), 0 0 15px rgba(0, 0, 0, 0.05); padding: 12px 17px 12px 42px;">
            </div>
            <div id="search-results-grid" class="item-grid" style="padding-top: calc(60px + env(safe-area-inset-top));">
                <!-- Search results will be rendered here -->
            </div>
        </div>
    </div>
    <div id="now-playing-view" class="view-container" style="display: none;">
        <div id="distortion-container">
            <canvas id="distortionCanvas"></canvas>
        </div>
        <div class="now-playing-wrapper">
            <div class="hitpoint-drawer-handle-player"><div class="drawer-handle-player"></div></div>
            <div class="album-art">
                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPgSURBVHhe7cEBAQAAAIIg/69uSEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcqAFFFQAB8Dl/nAAAAABJRU5ErkJggg==" alt="Album Art" id="albumArtImg">
            </div>
            <div class="music-info">
                <div class="music-text">
                    <div class="music-title">No song playing</div>
                    <div class="music-artist">&nbsp;</div>
                </div>
                <canvas id="visualizerCanvas"></canvas>
                <button class="more-button">
                    <span class="material-symbols-rounded" style="font-size: 18px;">more_horiz</span>
                </button>
            </div>
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress"></div>
                </div>
                <div class="time-info">
                    <span id="currentTime">&nbsp;</span>
                    <span id="player-status"></span>
                    <span id="duration">&nbsp;</span>
                </div>
            </div>
            <div class="player-controls">
                <button class="control-btn" id="prevBtn">
                    <span class="material-symbols-rounded" style="font-size: 36px;">fast_rewind</span>
                </button>
                <button class="control-btn play-pause" id="playPauseBtn">
                    <span class="material-symbols-rounded" id="playPauseIcon" style="font-size: 50px; font-variation-settings: 'FILL' 1, 'wght' 700, 'GRAD' 0, 'opsz' 48;">play_arrow</span>
                </button>
                <button class="control-btn" id="nextBtn">
                    <span class="material-symbols-rounded" style="font-size: 36px;">fast_forward</span>
                </button>
            </div>
            <div class="controls-container">
                <button class="controls-container-btn" id="shuffleBtn">
                    <span class="material-symbols-rounded">shuffle</span>
                </button>
                <button class="controls-container-btn" id="repeatBtn">
                    <span class="material-symbols-rounded">repeat</span>
                </button>
                <google-cast-launcher id="castBtn" style="width: 18px; height: 18px; margin: 9px; --connected-color: var(--accent); --disconnected-color: var(--text-color);"></google-cast-launcher>
                <button class="lyrics-button">
                    <span class="material-symbols-rounded" style="font-size: 18px;">tooltip_2</span>
                </button>
                <button class="queue-button">
                    <span class="material-symbols-rounded" style="font-size: 18px;">format_list_bulleted</span>
                </button>
            </div>
            <div id="moreOptionsMenu" class="more-options-menu">
                <div class="menu-item" id="menuFullscreenBtn">
                    <span class="material-symbols-rounded">expand_content</span>
                    <span>Fullscreen</span>
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" id="menuEditMetadata">
                    <span class="material-symbols-rounded">edit</span>
                    <span>Edit Info</span>
                </div>
                <div class="menu-item" id="menuSaveToLibrary">
                    <span class="material-symbols-rounded">arrow_circle_down</span>
                    <span>Own</span>
                </div>
                <div class="menu-item" id="menuAddToPlaylist">
                    <span class="material-symbols-rounded">playlist_add</span>
                    <span>Add to Playlist</span>
                </div>
                <div class="menu-separator"></div>
                <div class="menu-item" id="menuCrossfade">
                    <span class="material-symbols-rounded">swap_horiz</span>
                    <span>Crossfade</span>
                    <span id="crossfadeStatus" style="margin-left: auto; font-size: 0.8em; color: var(--secondary-text-color);">Off</span>
                </div>
                <div class="menu-item" id="menuEqualizer">
                    <span class="material-symbols-rounded">equalizer</span>
                    <span>Equalizer</span>
                </div>
                <div class="menu-item" id="menuSleepTimer">
                    <span class="material-symbols-rounded">timer</span>
                    <span>Sleep Timer</span>
                </div>
                <div class="menu-item" id="menuDeleteSong" style="background: rgba(255, 107, 107, 0.5);border: 1px solid var(--glass-border);border-radius: 50px;corner-shape: round;justify-content: center;box-shadow: var(--sun-shadow);margin-top: 10px;">
                    <span class="material-symbols-rounded">delete</span>
                    <span>Delete Song</span>
                </div>
            </div>
        </div>
        <div id="lyrics-queue-panel" class="hidden">
            <!-- Lyrics or Queue content will be rendered here by JS -->
        </div>
    </div>

    <div id="bottom-miniplayer" class="hidden">
        <div class="miniplayer-progress"></div>
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPgSURBVHhe7cEBAQAAAIIg/69uSEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcqAFFFQAB8Dl/nAAAAABJRU5ErkJggg==" alt="mini-art" id="miniplayer-art">
        <div class="miniplayer-info">
            <div id="miniplayer-title">No song playing</div>
            <div id="miniplayer-artist"></div>
        </div>
        <div class="miniplayer-controls">
            <button id="miniplayer-prev-btn" class="mini-control-btn"><span class="material-symbols-rounded">fast_rewind</span></button>
            <button id="miniplayer-play-btn" class="mini-control-btn"><span class="material-symbols-rounded" style="font-size: 32px; font-variation-settings: 'FILL' 1, 'wght' 700, 'GRAD' 0, 'opsz' 48;">play_arrow</span></button>
            <button id="miniplayer-next-btn" class="mini-control-btn"><span class="material-symbols-rounded">fast_forward</span></button>
        </div>
    </div>

    <!-- Manage Folders Modal -->
    <div id="manageFoldersModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 50px; corner-shape: superellipse(1.5); width: 90%; max-width: 450px; backdrop-filter: blur(10px); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 15px;">Settings</h2>
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <label for="tidalToggle">Enable Streaming</label>
                    <input type="checkbox" id="tidalToggle">
                </div>
                <div style="display: flex; flex-direction: column; gap: 5px;">
                    <label for="prefAudioQuality" style="font-size: 14px; color: var(--secondary-text-color);">Streaming Quality</label>
                    <select id="prefAudioQuality" class="library-search-input" style="padding: 8px 15px;">
                        <option value="LOSSLESS">Highest</option>
                        <option value="HIGH">320kbps</option>
                        <option value="LOW">96kbps</option>
                    </select>
                </div>
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <label for="explicitToggle">Hide Explicit Content</label>
                    <input type="checkbox" id="explicitToggle">
                </div>
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <label for="smartCacheToggle">Intelligent Cache</label>
                    <input type="checkbox" id="smartCacheToggle" checked>
                </div>
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <label for="streamOnlyToggle">Don't save songs to temporary storage</label>
                    <input type="checkbox" id="streamOnlyToggle">
                </div>
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <label for="lrclibToggle">Search LRCLIB for lyrics</label>
                    <input type="checkbox" id="lrclibToggle">
                </div>
            </div>

            <div class="menu-separator" style="margin: 15px 0;"></div>
                
            <h3 style="font-size: 1rem; margin-bottom: 10px;">Cloud Library</h3>
            <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px;">
                <input type="text" id="gDriveClientId" placeholder="Paste Google Client ID here" class="library-search-input" style="padding: 8px 15px;">
                <div style="display: flex; gap: 10px;">
                    <button id="gDriveLoginBtn" class="filter-btn">
                        <span class="material-symbols-rounded" style="font-size: 18px; margin-right: 5px;">login</span> Login
                    </button>
                    <button id="gDriveSyncBtn" class="filter-btn active" style="flex: 1; display: none;">
                        <span class="material-symbols-rounded" style="font-size: 18px; margin-right: 5px;">sync</span> Sync Library
                    </button>
                </div>
                <small id="gDriveStatus" style="color: var(--secondary-text-color); font-size: 11px;">Not connected</small>
            </div>
                
            <h3 style="font-size: 1rem; margin-bottom: 10px;">Local Library</h3>
            <div style="display: flex; gap: 10px;">
                <button id="exportLibraryBtn" class="filter-btn" style="flex: 1;">
                    <span class="material-symbols-rounded" style="font-size: 18px; vertical-align: middle; margin-right: 5px;">upload</span> Export
                </button>
                <button id="importLibraryBtn" class="filter-btn" style="flex: 1;">
                    <span class="material-symbols-rounded" style="font-size: 18px; vertical-align: middle; margin-right: 5px;">download</span> Import
                </button>
                <input type="file" id="importLibraryInput" accept=".json" style="display: none;">
            </div>

            <div style="display: flex; justify-content: flex-end; margin-top: 25px; gap: 10px;">
                <button id="saveIntegrations" class="filter-btn active">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Song Modal -->
    <div id="editModal" class="modal-overlay">
        <div id="editModalContent" style="background: var(--modal-background); padding: 25px; border-radius: 50px; corner-shape: superellipse(1.5); width: 90%; max-width: 400px; backdrop-filter: blur(10px); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Edit Song Info</h2>
            <input type="hidden" id="editSongId">
            <div style="display: flex; flex-direction: column; gap: 15px;">
                <input type="text" id="editTitle" placeholder="Title" class="search-input" style="padding-left: 15px;">
                <input type="text" id="editArtist" placeholder="Artist" class="search-input" style="padding-left: 15px;">
                <input type="text" id="editAlbum" placeholder="Album" class="search-input" style="padding-left: 15px;">
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 25px;">
                <button id="cancelEdit" class="filter-btn">Cancel</button>
                <button id="saveEdit" class="filter-btn active">Save</button>
            </div>
        </div>
    </div>

    <!-- Manual Lyrics Search Modal -->
    <div id="manualLyricsSearchModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 50px; corner-shape: superellipse(1.5); width: 90%; max-width: 450px; backdrop-filter: blur(10px); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Lyrics Search</h2>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <input type="text" id="manualLyricsSearchInput" placeholder="Artist - Title" class="search-input" style="padding-left: 15px;">
                <button id="manualLyricsSearchBtn" class="filter-btn active" style="flex-shrink: 0;"><span class="material-symbols-rounded" style="font-size: 18px;">arrow_forward</span></button>
            </div>
            <div id="manualLyricsResults" style="max-height: 250px; overflow-y: auto;">
                <!-- Search results will be populated here -->
            </div>
            <div style="display: flex; justify-content: flex-end; margin-top: 25px;">
                <button id="closeManualLyricsModal" class="filter-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- Sleep Timer Modal -->
    <div id="sleepTimerModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 50px; corner-shape: superellipse(1.5); width: 90%; max-width: 300px; backdrop-filter: blur(10px); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Sleep Timer</h2>
            <p style="margin-bottom: 15px; color: var(--secondary-text-color);">Playback will stop after:</p>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button class="filter-btn" onclick="setSleepTimer(15)">15 Minutes</button>
                <button class="filter-btn" onclick="setSleepTimer(30)">30 Minutes</button>
                <button class="filter-btn" onclick="setSleepTimer(60)">1 Hour</button>
            </div>
            <div class="menu-separator"></div>
            <button id="cancelSleepTimer" class="filter-btn active" style="width: 100%;">Cancel Timer</button>
        </div>
    </div>

    <!-- Playlist Modal -->
    <div id="playlistModal" class="modal-overlay">
         <div style="background: var(--modal-background); padding: 25px; border-radius: 50px; corner-shape: superellipse(1.5); width: 90%; max-width: 400px; backdrop-filter: blur(10px); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Add to playlist</h2>
            <div id="playlistList" style="max-height: 200px; overflow-y: auto; margin-bottom: 15px;"></div>
            <div class="menu-separator"></div>
            <input type="text" id="newPlaylistName" placeholder="Create new playlist" class="search-input" style="padding-left: 15px; margin-bottom: 10px;">
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button id="closePlaylistModal" class="filter-btn">Cancel</button>
                <button id="createPlaylistBtn" class="filter-btn active">Create & Add</button>
            </div>
        </div>
    </div>
    
    <!-- Equalizer Modal -->
    <div id="equalizerModal" class="modal-overlay">
        <div style="background: var(--modal-background); padding: 25px; border-radius: 50px; corner-shape: superellipse(1.5); width: 90%; max-width: 400px; backdrop-filter: blur(10px); border: 1px solid var(--glass-border);">
            <h2 style="margin-bottom: 20px;">Equalizer</h2>
            
            <div id="eq-bands-container" style="display: flex; flex-direction: column; gap: 20px; margin-bottom: 25px;">
                <!-- Bass Slider -->
                <div class="eq-band">
                    <label for="bass-slider" style="display: block; margin-bottom: 5px; color: var(--secondary-text-color);">Bass</label>
                    <input type="range" id="bass-slider" class="volume-slider" min="-10" max="10" value="0" step="1">
                </div>
                <!-- Mid Slider -->
                <div class="eq-band">
                    <label for="mid-slider" style="display: block; margin-bottom: 5px; color: var(--secondary-text-color);">Mid</label>
                    <input type="range" id="mid-slider" class="volume-slider" min="-10" max="10" value="0" step="1">
                </div>
                <!-- Treble Slider -->
                <div class="eq-band">
                    <label for="treble-slider" style="display: block; margin-bottom: 5px; color: var(--secondary-text-color);">Treble</label>
                    <input type="range" id="treble-slider" class="volume-slider" min="-10" max="10" value="0" step="1">
                </div>
            </div>

            <div style="display: flex; justify-content: space-between; gap: 10px;">
                <button id="resetEq" class="filter-btn">Reset</button>
                <button id="closeEqModal" class="filter-btn active">Close</button>
            </div>
        </div>
    </div>

    <div id="songContextMenu" class="context-menu">
        <div class="menu-item" id="menuAddToQueueNext">
            <span class="material-symbols-rounded">playlist_play</span>
            <span>Play Next</span>
        </div>
        <div class="menu-item" id="menuAddToQueueLast">
            <span class="material-symbols-rounded">playlist_add</span>
            <span>Add to Queue</span>
        </div>
    </div>

    <div id="drawer" class="drawer">
        <div class="drawer-handle"></div>
        <div class="drawer-header">
            <h2 id="drawer-title"></h2>
            <p id="drawer-subtitle"></p>
        </div>
        <div class="drawer-content" id="drawer-content">
            <!-- Content will be injected here -->
        </div>
    </div>
    <div id="drawer-overlay" class="modal-overlay"></div>

    <div id="toast-container"></div>

    <script>
        const musicList = document.querySelector('.music-list');
        const musicUpload = document.getElementById('musicUpload');
        const audioPlayer = new Audio();
        const playPauseBtn = document.getElementById('playPauseBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const progressBar = document.querySelector('.progress-bar');
        const progress = document.querySelector('.progress');
        const currentTimeDisplay = document.getElementById('currentTime');
        const durationDisplay = document.getElementById('duration');
        const musicTitle = document.querySelector('.music-title');
        const musicArtist = document.querySelector('.music-artist');
        const albumArtImg = document.getElementById('albumArtImg');
        const playPauseIcon = document.getElementById('playPauseIcon');
        const volumeIcon = document.getElementById('volumeIcon');
        const body = document.body;
        const menuBtn = document.createElement('button');
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

        let activeView = 'home'; // 'home', 'library', 'search', 'nowPlaying'
        let isPanelVisible = false;
        let panelContent = null; // 'lyrics' or 'queue'
        let libraryScrollPosition = 0;
        let isFullscreen = false;
        let lastMainView = 'home'; // To remember where to return after playback ends
        let lastScrollPosition = 0; // To remember scroll position when entering Now Playing
        let scrollPositions = { home: 0, library: 0, search: 0 };
        const viewContainers = document.querySelectorAll('.view-container');
        const tabBtns = document.querySelectorAll('.tab-btn');
        const miniplayer = document.getElementById('bottom-miniplayer');
        const miniplayerArt = document.getElementById('miniplayer-art');
        const miniplayerTitle = document.getElementById('miniplayer-title');
        const miniplayerArtist = document.getElementById('miniplayer-artist');
        const miniplayerPlayBtn = document.getElementById('miniplayer-play-btn');
        const miniplayerProgress = document.querySelector('.miniplayer-progress');
        const toolbar = document.querySelector('.toolbar');
        
        const drawer = document.getElementById('drawer');
        const drawerContent = document.getElementById('drawer-content');
        const drawerOverlay = document.getElementById('drawer-overlay');
        let isDrawerOpen = false;
        let closeDrawerTimeout = null;
        
        let listenAgainIndex = parseInt(localStorage.getItem('listenAgainIndex') || '0');
        let currentMediaSessionArtBlobUrl = null;
        let lastOriginalImageUrl = null;
        let lastResizedImageUrl = null;
        let distortionCanvas, ctx;
        let currentResizedArt = new Image();
        let oldResizedArt = new Image();
        let blobs = [];
        let animationFrameId;
        let backgroundRotation = 0;
        let currentBeatIntensity = 0; // The smoothly animated intensity used for rendering
        let noise; // This will hold our noise generator function
        let beatIntensity = 0;
        let isTransitioning = false;
        let transitionProgress = 0;
        const TRANSITION_DURATION = 15; // in frames (approx. 0.25 seconds)
        let visualizerFrameId = null;
        let visualizerDraw = () => {};
        let songs = [];
        let currentSongId = null;
        let isPlayerLoading = false;
        let playbackLoader = null; // Controls the abort signal for the current track load
        let db;
        let sessionPlayedIds = new Set(); // Track all songs played/queued to prevent repeats
        let lastSongStartTime = 0;
        let consecutiveRapidSkips = 0;
        let directoryHandles = []; // For File System Access API
        let isShuffleEnabled = false;
        let repeatMode = 'none'; // 'none', 'all', or 'one'
        let playQueue = [];
        let isQueueUserModified = false;
        let currentQueueIndex = -1;
        let isAutoplayEnabled = false;
        let autoplaySongIds = new Set(); // Use a Set for efficient add/delete/check operations
        let searchTimeout;
        let searchInput;
        let longPressTimer;
        let isLongPress = false;
        const LONG_PRESS_DURATION = 500;
        let isDragging = false;
        let draggedItem = null;
        let isDraggingAlbum = false;
        let touchStartY = 0;
        let initialY = 0;
        let touchTarget = null;
        let hls = null; // To hold the Hls.js instance
        let castSession = null;
        let castPlayer = null;
        let castController = null;
        let audioContext;
        let analyser;
        let isVisualizerInitialized = false;
        let source;
        let currentFilter = 'albums'; // 'albums', 'artists', 'songs'
        let editModal, editSongId, editTitle, editArtist, editAlbum, saveEdit, cancelEdit, equalizerModal, manageFoldersModal;
        let crossfadeEnabled = false;
        let sleepTimerId = null;
        let eqBass, eqMid, eqTreble; // Add these for the EQ
        let beatDetector, tempoEstimator;
        let songBPM = 0, lastBpmAlignedBeatTime = 0;
        let playlists = [];
        let playlistModal, sleepTimerModal;
        let currentSortMode = 'dateAdded'; // 'dateAdded', 'alpha'
        let activeAlbum = null; // Will store { artist, name } of the selected album
        let isFetchingQueue = false; // Lock to prevent overlapping fetches
        let isPlaylistEditMode = false; // Track edit state for playlist drawer

        function handleSystemPreferences() {
            // 1. Theme (Light/Dark)
            const updateTheme = () => {
                const storedTheme = localStorage.getItem('theme');
                const systemLight = window.matchMedia('(prefers-color-scheme: light)').matches;
                // If stored is explicit 'light', OR (not stored AND system is light)
                if (storedTheme === 'light' || (!storedTheme && systemLight)) {
                    document.body.classList.add('light-theme');
                } else {
                    document.body.classList.remove('light-theme');
                }
            };
            updateTheme();
            window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', updateTheme);

            // 2. Reduced Motion
            const updateMotion = () => {
                const shouldReduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                if (shouldReduce) document.body.classList.add('reduce-animations');
                else document.body.classList.remove('reduce-animations');
            };
            updateMotion();
            window.matchMedia('(prefers-reduced-motion: reduce)').addEventListener('change', updateMotion);

            // 3. High Contrast
            const updateContrast = () => {
                const highContrast = window.matchMedia('(prefers-contrast: more)').matches;
                if (highContrast) document.documentElement.classList.add('high-contrast');
                else document.documentElement.classList.remove('high-contrast');
            };
            updateContrast();
            window.matchMedia('(prefers-contrast: more)').addEventListener('change', updateContrast);
        }
        
        // Initialize immediately
        handleSystemPreferences();

        function showToast(message) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast-message';
            toast.textContent = message;
            container.appendChild(toast);
            
            // Trigger reflow
            void toast.offsetWidth; 
            
            requestAnimationFrame(() => toast.classList.add('show'));
            
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        async function showConfirmDialog(message) {
            // Simple wrapper for native confirm to match async/await pattern
            return new Promise(resolve => resolve(window.confirm(message)));
        }

        function toggleQueueLoading(show) {
            const container = document.querySelector('.queue-list-container');
            // If queue panel isn't rendered yet but we are loading, we might need to render the empty shell first
            if (!container && show && isPanelVisible && panelContent === 'queue') {
                renderQueue(); // Force render if missing
            }
            
            const targetContainer = document.querySelector('.queue-list-container');
            if (!targetContainer) return;
        
            const existingLoader = document.getElementById('queue-loader');
            
            if (show) {
                if (!existingLoader) {
                    const loader = document.createElement('div');
                    loader.id = 'queue-loader';
                    loader.style.cssText = 'padding: 15px; text-align: center; color: var(--secondary-text-color); display: flex; align-items: center; justify-content: center; gap: 10px;';
                    loader.innerHTML = `<svg width="20" height="20" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg><span>Fetching music...</span>`;
                    targetContainer.appendChild(loader);
                    loader.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            } else {
                if (existingLoader) existingLoader.remove();
            }
        }

        // --- tidal variables ---
        let tidalClientId = '';
        let istidalEnabled = false;
        let tidalSearchTimeout;
        let tidalSearchAbortController = null;
        let tidalSearchOffset = 0;
        let currentlyPlayingSong = null;
        let istidalOfflineMode = false;
        let tidalFilter = 'tracks';
        let lasttidalSearchResults = []; // To store API results for filtering
        let browseContext = [];
        let currentDrawerContext = []; // To store full objects for drawer context
        const tidal_CACHE_LIMIT = 200 * 1024 * 1024; // 200MB
        let prefAudioQuality = 'LOSSLESS';
        let enableSmartCache = true;
        let enableStreamOnly = false;
        let hideExplicitContent = false;
        let searchHistory = JSON.parse(localStorage.getItem('searchHistory') || '[]');
        let localSongLookup = new Map();
        let isrcToLocalSongMap = new Map();
        let isRadioMode = false;
        let radioSeed = null; // { type: 'artist'|'track', query: '...' }
        const GENRES = ["Pop", "Hip-Hop", "R&B", "Electronic", "Rock", "Indie", "K-Pop", "J-Pop", "Classical", "Jazz", "Metal", "Alternative", "Country"];
        let currentEndpointIndex = 0;
        let hifiApiBaseUrl = "https://tidal.kinoplus.online"; // Default fallback
        const hifiApiEndpoints = [
            "https://aether.squid.wtf",
            "https://zeus.squid.wtf",
            "https://kraken.squid.wtf",
            "https://wolf.qqdl.site",
            "https://maus.qqdl.site",
            "https://vogel.qqdl.site",
            "https://katze.qqdl.site",
            "https://hund.qqdl.site",
            "https://phoenix.squid.wtf",
            "https://shiva.squid.wtf",
            "https://chaos.squid.wtf",
            "https://tidal.kinoplus.online"
        ];
        let sortedApiEndpoints = [...hifiApiEndpoints]; // Default to unsorted list

        async function findFastestHifiEndpoint() {
            const promises = hifiApiEndpoints.map(async (endpoint) => {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 2000); // 2-second timeout
                const startTime = performance.now();
                try {
                    await fetch(`${endpoint}`, { signal: controller.signal });
                    const endTime = performance.now();
                    clearTimeout(timeoutId);
                    return { endpoint, latency: endTime - startTime };
                } catch (error) {
                    clearTimeout(timeoutId);
                    return { endpoint, latency: Infinity };
                }
            });

            const results = await Promise.all(promises);
            
            // Sort by latency (lowest first)
            const validResults = results.filter(r => r.latency !== Infinity).sort((a, b) => a.latency - b.latency);
            
            if (validResults.length > 0) {
                console.log(`Fastest Hi-Fi endpoint: ${validResults[0].endpoint} (${validResults[0].latency.toFixed(2)}ms)`);
                sortedApiEndpoints = validResults.map(r => r.endpoint);
                hifiApiBaseUrl = sortedApiEndpoints[0];
                currentEndpointIndex = 0;
            } else {
                console.warn("No responsive Hi-Fi endpoints found, using default order.");
            }
        }

        // Wrapper to fetch from HiFi API with automatic failover
        async function fetchHifi(path, options = {}, retries = 0) {
            try {
                const url = `${hifiApiBaseUrl}${path}`;
                const response = await fetch(url, options);
                
                // If 5xx Server Error or 429 Too Many Requests, throw to trigger failover
                if (!response.ok && (response.status >= 500 || response.status === 429)) {
                    throw new Error(`API Error ${response.status}`);
                }
                
                return response;
            } catch (err) {
                // Don't retry if the user cancelled the action (AbortError)
                if (err.name === 'AbortError') throw err;
        
                // If we haven't tried all servers yet, switch and retry
                if (retries < sortedApiEndpoints.length - 1) {
                    currentEndpointIndex = (currentEndpointIndex + 1) % sortedApiEndpoints.length;
                    hifiApiBaseUrl = sortedApiEndpoints[currentEndpointIndex];
                    console.warn(`API Error (${err.message}). Switching to: ${hifiApiBaseUrl}`);
                    
                    return fetchHifi(path, options, retries + 1);
                }
                
                // If all servers failed, throw the final error
                console.error("All API endpoints failed.");
                throw err;
            }
        }

        // --- LRCLIB variables ---
        let isLrclibEnabled = false;
        let lastLrclibSearchResults = [];
        
        function sanitize(str) {
            if (!str) return '';
            return str.toString().replace(/</g, "<").replace(/>/g, ">");
        }
        
        function getExplicitBadge(isExplicit) {
            return isExplicit ? ' ' : '';
        }

        function openModal(modal) {
            if (modal) modal.classList.add('visible');
        }
        
        function closeModal(modal) {
            if (modal) modal.classList.remove('visible');
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

function openDrawer(title, subtitle, contentHtml, context = {}) {
    clearTimeout(closeDrawerTimeout);

    const drawerTitleEl = document.getElementById('drawer-title');
    const drawerSubtitleEl = document.getElementById('drawer-subtitle');

    drawerTitleEl.textContent = sanitize(title);
    
    // Check the context to see if we should add edit buttons
    if (context.type === 'playlist' && context.id) {
        drawerSubtitleEl.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                <span>${sanitize(subtitle)}</span>
                <button id="drawer-edit-playlist-btn" data-playlist-id="${context.id}" title="Edit Order" style="background:var(--search-background);border:1px solid var(--glass-border);border-radius:20px;padding:5px 12px;cursor:pointer;color:var(--text-color);display:flex;align-items:center;gap:5px;">
                    Edit
                </button>
                <button id="drawer-rename-playlist-btn" data-playlist-id="${context.id}" title="Rename" style="background:none;border:none;cursor:pointer;color:var(--text-color); display:flex;">
                    <span class="material-symbols-rounded">drive_file_rename_outline</span>
                </button>
                <button id="drawer-delete-playlist-btn" data-playlist-id="${context.id}" title="Delete" style="background:none;border:none;cursor:pointer;color:var(--text-color); display:flex;">
                    <span class="material-symbols-rounded">delete_forever</span>
                </button>
            </div>
        `;
    } else {
        // Otherwise, just show the normal subtitle
        drawerSubtitleEl.textContent = sanitize(subtitle);
    }

    drawerContent.innerHTML = contentHtml;
    drawer.classList.add('open');
    drawerOverlay.classList.add('visible');
    isDrawerOpen = true;
}

function closeDrawer() {
    drawer.classList.remove('open');
    drawerOverlay.classList.remove('visible');
    isDrawerOpen = false;
    // Reset edit mode when closing drawer
    isPlaylistEditMode = false; 
    
    // Clear content after animation
    closeDrawerTimeout = setTimeout(() => {
        drawer.style.transform = '';
        drawerContent.innerHTML = '';
    }, 400);
}

// --- Google Drive Sync Logic ---
let tokenClient;
let gAccessToken = null;
let gTokenExpiry = 0;
let tokenRequestResolver = null; // Promise resolver for async auth
const SYNC_FILENAME = 'streams_library_metadata.json';

function initGoogleClient(clientId) {
    if (tokenClient) return;
    
    tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: clientId,
        scope: 'https://www.googleapis.com/auth/drive.file',
        callback: (response) => {
            if (response.error !== undefined) {
                console.error(response);
                showToast("Google Auth Error");
                return;
            }
            
            // 1. Save Token & Expiry (Persistent Session)
            gAccessToken = response.access_token;
            // expires_in is in seconds. Buffer by removing 60s to be safe.
            gTokenExpiry = Date.now() + (response.expires_in * 1000) - 60000;
            
            localStorage.setItem('gDriveToken', gAccessToken);
            localStorage.setItem('gDriveExpiry', gTokenExpiry);
            
            updateDriveUI(true);

            // 2. Resolve pending promise if we were waiting for a token
            if (tokenRequestResolver) {
                tokenRequestResolver(gAccessToken);
                tokenRequestResolver = null;
            }
        },
    });
}

function updateDriveUI(isConnected) {
    if (isConnected) {
        document.getElementById('gDriveStatus').textContent = "Connected. Ready to sync.";
        document.getElementById('gDriveLoginBtn').style.display = 'none';
        document.getElementById('gDriveSyncBtn').style.display = 'flex';
        document.getElementById('gDriveClientId').disabled = true;
    } else {
        document.getElementById('gDriveStatus').textContent = "Not connected";
        document.getElementById('gDriveLoginBtn').style.display = 'flex';
        document.getElementById('gDriveSyncBtn').style.display = 'none';
        document.getElementById('gDriveClientId').disabled = false;
    }
}

// Async helper to ensure we have a valid token before syncing
function getValidToken() {
    return new Promise((resolve, reject) => {
        // 1. Check if current token is valid
        if (gAccessToken && Date.now() < gTokenExpiry) {
            resolve(gAccessToken);
            return;
        }

        // 2. If no client (config missing), fail
        if (!tokenClient) {
            const clientId = document.getElementById('gDriveClientId').value.trim();
            if(clientId) initGoogleClient(clientId);
            else {
                showToast("Configure Google Client ID first");
                reject("No Client ID");
                return;
            }
        }

        // 3. Token expired or missing: Request new one (Popup)
        console.log("Token expired or missing, requesting new one...");
        tokenRequestResolver = resolve;
        // 'hint' can speed up re-auth if they are already signed in
        tokenClient.requestAccessToken({ prompt: '' }); 
    });
}

document.getElementById('gDriveLoginBtn').addEventListener('click', () => {
    const clientId = document.getElementById('gDriveClientId').value.trim();
    if (!clientId) return showToast("Please enter a Google Client ID");
    
    initGoogleClient(clientId);
    tokenClient.requestAccessToken();
});

async function syncLibraryToDrive(interactive = false) {
    // Auto-sync shouldn't trigger popup if completely logged out, 
    // but if we have a client ID and had a session, we try.
    if (!interactive && !gAccessToken) return;

    if (interactive) showToast("Syncing with Drive...");
    else console.log("Auto-syncing library...");
    
    try {
        // Ensure we have a valid token (handles refresh/popup)
        await getValidToken(); 
        // Token is now in gAccessToken

        // 1. Export local data
        const tx = db.transaction(['songs', 'playlists', 'playHistory'], 'readonly');
        const [songsData, playlistsData, historyData] = await Promise.all([
            promiseIDBRequest(tx.objectStore('songs').getAll()),
            promiseIDBRequest(tx.objectStore('playlists').getAll()),
            promiseIDBRequest(tx.objectStore('playHistory').getAll())
        ]);

        let mergedSongs = songsData;
        let mergedPlaylists = playlistsData;
        let mergedHistory = historyData;

        // 2. Find existing file
        const q = `name = '${SYNC_FILENAME}' and trashed = false`;
        const searchRes = await fetch(`https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(q)}`, {
            headers: { 'Authorization': `Bearer ${gAccessToken}` }
        });
        const searchData = await searchRes.json();
        const file = searchData.files && searchData.files.length > 0 ? searchData.files[0] : null;

        if (file) {
            // 3. Download cloud data
            const downloadRes = await fetch(`https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`, {
                headers: { 'Authorization': `Bearer ${gAccessToken}` }
            });
            
            if (downloadRes.ok) {
                const cloudData = await downloadRes.json();
                
                // 4. Merge Logic (Union of Local and Cloud)
                
                // Merge Songs (Deduplicate by ID for Tidal, Artist+Name for Local)
                const songMap = new Map();
                const getSongKey = (s) => {
                    if (s.storage === 'tidal') return `tidal:${s.id}`;
                    // Clean up strings to ensure good matching for local files
                    return `local:${(s.artist||'').toLowerCase().trim()}:${(s.name||'').toLowerCase().trim()}`;
                };

                // Add Cloud first
                if (cloudData.songs) cloudData.songs.forEach(s => songMap.set(getSongKey(s), s));
                // Overwrite/Add Local (Local takes priority for metadata edits like lyrics)
                songsData.forEach(s => songMap.set(getSongKey(s), s));
                mergedSongs = Array.from(songMap.values());

                // Merge Playlists (ID based merge)
                const plMap = new Map();
                if (cloudData.playlists) cloudData.playlists.forEach(p => plMap.set(p.id, p));
                playlistsData.forEach(p => plMap.set(p.id, p));
                mergedPlaylists = Array.from(plMap.values());

                // Merge History (Union by timestamp)
                const histMap = new Map();
                if (cloudData.history) cloudData.history.forEach(h => histMap.set(h.timestamp, h));
                historyData.forEach(h => histMap.set(h.timestamp, h));
                mergedHistory = Array.from(histMap.values()).sort((a,b) => b.timestamp - a.timestamp).slice(0, 1000);

                // 5. Update Local Database with Merged Data
                await restoreFromData({ songs: mergedSongs, playlists: mergedPlaylists, history: mergedHistory });
                console.log("Local library updated with merged Cloud data.");
            }
        }

        // 6. Upload Merged Data (Push back to Cloud)
        const finalExport = {
            timestamp: Date.now(),
            songs: mergedSongs,
            playlists: mergedPlaylists,
            history: mergedHistory
        };

        const fileContent = JSON.stringify(finalExport);
        const metadata = {
            name: SYNC_FILENAME,
            mimeType: 'application/json'
        };

        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', new Blob([fileContent], { type: 'application/json' }));

        let uploadUrl = 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart';
        let method = 'POST';

        if (file) {
            uploadUrl = `https://www.googleapis.com/upload/drive/v3/files/${file.id}?uploadType=multipart`;
            method = 'PATCH';
        }

        const uploadRes = await fetch(uploadUrl, {
            method: method,
            headers: { 'Authorization': `Bearer ${gAccessToken}` },
            body: form
        });

        if (uploadRes.ok) {
            if (interactive) showToast("Library synced (Merged).");
            const statusEl = document.getElementById('gDriveStatus');
            if (statusEl) statusEl.textContent = `Last sync: ${new Date().toLocaleTimeString()}`;
        } else {
            throw new Error("Upload failed");
        }

    } catch (e) {
        console.error("Drive Sync Error:", e);
        if (interactive) showToast("Sync failed. See console.");
    }
}

async function restoreTidalDownloads(importedSongs) {
    const tidalSongs = importedSongs.filter(s => s.storage === 'tidal');
    if (tidalSongs.length === 0) return;

    // Only run if streaming is enabled and stream-only is OFF
    if (!istidalEnabled || (typeof enableStreamOnly !== 'undefined' && enableStreamOnly)) return;

    showToast(`Downloading ${tidalSongs.length} items...`);
    
    let downloadedCount = 0;
    // Process sequentially to be gentle on network/API
    for (const song of tidalSongs) {
        try {
            // Check if already cached
            const tx = db.transaction('tidalCache', 'readonly');
            const exists = await promiseIDBRequest(tx.objectStore('tidalCache').get(song.id));
            
            if (!exists) {
                const result = await processAndCacheAudio(song);
                if (result) downloadedCount++;
            }
        } catch (e) {
            console.warn(`Restoration download skipped for ${song.name}`);
        }
    }
    if (downloadedCount > 0) {
        showToast(`Finished downloading ${downloadedCount} songs.`);
    }
}

// Helper to reuse import logic
async function restoreFromData(data) {
    const tx = db.transaction(['songs', 'playlists', 'playHistory'], 'readwrite');
    
    tx.objectStore('songs').clear();
    tx.objectStore('playlists').clear();
    tx.objectStore('playHistory').clear();

    const songStore = tx.objectStore('songs');
    for (const song of data.songs) songStore.put(song);
    
    if (data.playlists) {
        const plStore = tx.objectStore('playlists');
        for (const pl of data.playlists) plStore.put(pl);
    }
    if (data.history) {
        const histStore = tx.objectStore('playHistory');
        for (const h of data.history) histStore.put(h);
    }

    await new Promise((resolve, reject) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
        tx.onabort = () => reject(new Error('Transaction aborted'));
    });
    
    await loadSongsAndPlaylists();
    if (activeView === 'library') renderLibraryPage();
    if (activeView === 'home') renderHomePage();
    restoreTidalDownloads(data.songs);
}
        
let syncDebounceTimer;
function triggerAutoSync() {
    if (!gAccessToken) return;
    clearTimeout(syncDebounceTimer);
    syncDebounceTimer = setTimeout(() => {
        syncLibraryToDrive(false); // Silent sync
    }, 5000); // Wait 5 seconds after last change
}

function setupDrawerInteractions() {
    let startY = 0;
    let currentY = 0;
    let isDragging = false;
    const handle = document.querySelector('.drawer-handle');
    const drawer = document.getElementById('drawer');

    const startDrag = (y) => {
        if (!isDrawerOpen) return;
        isDragging = true;
        startY = y;
        drawer.style.transition = 'none';
    };

    const moveDrag = (y) => {
        if (!isDragging) return;
        currentY = y;
        const deltaY = currentY - startY;
        if (deltaY > 0) { // Only allow dragging down
            drawer.style.transform = `translateY(${deltaY}px)`;
        }
    };

    const endDrag = () => {
        if (!isDragging) return;
        isDragging = false;
        drawer.style.transition = '';
        drawer.style.transform = ''; // Reset transform to allow CSS transition
        
        const deltaY = currentY - startY;
        if (deltaY > 100) { // Close threshold
            closeDrawer();
        } else {
            drawer.style.bottom = '0';
        }
    };

    handle.addEventListener('mousedown', (e) => startDrag(e.clientY));
    document.addEventListener('mousemove', (e) => moveDrag(e.clientY));
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('mouseleave', endDrag);

    handle.addEventListener('touchstart', (e) => startDrag(e.touches[0].clientY), { passive: true });
    document.addEventListener('touchmove', (e) => moveDrag(e.touches[0].clientY), { passive: true });
    document.addEventListener('touchend', endDrag);

    document.getElementById('drawer-overlay').addEventListener('click', closeDrawer);
}

function setupSwipeGestures() {
    // 1. Swipe Up on Miniplayer to Open
    const miniplayer = document.getElementById('bottom-miniplayer');
    let miniStartY = 0;
    
    miniplayer.addEventListener('touchstart', (e) => {
        miniStartY = e.touches[0].clientY;
    }, { passive: true });

    miniplayer.addEventListener('touchend', (e) => {
        const miniEndY = e.changedTouches[0].clientY;
        const deltaY = miniEndY - miniStartY;
        
        // Threshold of 30px for swipe up
        if (deltaY < -30) {
            setView('now-playing');
        }
    }, { passive: true });

    // 2. Swipe Down on Main Player to Close
    const mainPlayer = document.getElementById('now-playing-view');
    let mainStartY = 0;
    let isInteractingWithSlider = false;
    let isInteractingWithScrollable = false;

    mainPlayer.addEventListener('touchstart', (e) => {
        mainStartY = e.touches[0].clientY;
        // Ignore swipe if touching volume/progress sliders
        isInteractingWithSlider = e.target.closest('input[type="range"]') !== null;
        
        // Ignore swipe if interacting with the queue/lyrics panel to prevent conflict with scrolling
        isInteractingWithScrollable = e.target.closest('#lyrics-queue-panel') !== null;
    }, { passive: true });

    mainPlayer.addEventListener('touchend', (e) => {
        if (isInteractingWithSlider || isInteractingWithScrollable) return;

        const mainEndY = e.changedTouches[0].clientY;
        const deltaY = mainEndY - mainStartY;
        
        // Threshold of 60px for swipe down
        if (deltaY > 60) {
            // Logic: If panel (queue/lyrics) is open, close it first.
            // If panel is closed, minimize the player.
            if (isPanelVisible) {
                closePanel();
            } else {
                setView(lastMainView); // Return to previous view (Home/Library etc)
            }
        }
    }, { passive: true });
}

        function getLowResArtUrl(highResUrl) {
            if (!highResUrl || !highResUrl.includes('resources.tidal.com')) {
                return highResUrl;
            }
            return highResUrl.replace(/\/\d+x\d+\.jpg$/, '/80x80.jpg');
        }

        function getHighResArtwork(coverUuid, size = 640) {
            if (!coverUuid) {
                return generateRandomGradient();
            }
            const formattedUuid = coverUuid.replace(/-/g, '/');
            const imageUrl = `https://resources.tidal.com/images/${formattedUuid}/${size}x${size}.jpg`;
            return imageUrl;
        }
            
function renderSearchResults() {
    const searchGrid = document.getElementById('search-results-grid');
    const query = document.getElementById('searchInput').value.toLowerCase();
    if (!query) {
        searchGrid.innerHTML = '';
        return;
    }

    const results = songs.filter(s => 
        s.name.toLowerCase().includes(query) ||
        s.artist.toLowerCase().includes(query) ||
        s.album.toLowerCase().includes(query)
    );

    if (results.length === 0) {
        searchGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>No results found for "${query}"</p></div>`;
        return;
    }
    
    // For now, just show a list of matching songs
    const resultsHtml = results.map(song => `
        <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
             <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; scale: 1.2; border-radius: 8px; margin-right: 10px;">
                <div>
                    <div class="song-title" style="white-space: normal;">${sanitize(song.name)}${getExplicitBadge(song.explicit)}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                </div>
            </div>
        </div>
    `).join('');
    searchGrid.className = 'item-list'; // Search results are a list
    searchGrid.innerHTML = resultsHtml;

    requestAnimationFrame(() => {
        const searchView = document.getElementById('search-view');
        searchView.scrollTop = scrollPositions.search;
    });
}

function renderRadioPage() {
    const grid = document.getElementById('radio-grid');
    grid.innerHTML = '';
    
    // 1. Feature: Create radio stations from user's top artists
    // Use a Set to get unique artists from the library
    const libraryArtists = [...new Set(songs.map(s => s.artist).filter(Boolean))];
    const suggestions = shuffleArray(libraryArtists).slice(0, 32);

    if (suggestions.length === 0) {
        grid.innerHTML = `<div class="no-results"><p>Own some songs to get personalized stations.</p></div>`;
        return;
    }

    const html = suggestions.map(artist => {
        // Find art for this artist
        const song = songs.find(s => s.artist === artist);
        return `
        <div class="item-card" onclick="startRadio('artist', '${sanitize(artist)}')">
            <div style="position: relative;">
                <img src="${song.albumArt}" class="item-card-art" style="border-radius: 50%; corner-shape: round;">
                <div style="position: absolute; bottom: 5px; right: 5px; background: var(--text-color); color: var(--background-color); border-radius: 50%; padding: 20px;">
                    <span class="material-symbols-rounded" style="font-size: 20px; display:block;">radio</span>
                </div>
            </div>
            <div class="item-card-info" style="text-align: center;">
                <div class="item-card-title">${sanitize(artist)} Radio</div>
                <div class="item-card-subtitle">Station</div>
            </div>
        </div>`;
    }).join('');

    grid.innerHTML = html;
}

async function startRadio(type, query) {
    if (!istidalEnabled) return showToast("Enable Streaming for Radio");
    
    isRadioMode = true;
    radioSeed = { type, query };
    document.body.classList.add('radio-mode');
    
    playQueue = [];
    currentQueueIndex = -1;
    
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
    
    showToast(`Starting ${query} Radio`);
    
    await appendRadioTracks();
    
    if (playQueue.length > 0) {
        const firstSong = playQueue[0];
        if (firstSong.storage === 'tidal') {
            playtidalTrack(firstSong.id);
        }
    }
    
    setView('now-playing');
}

async function appendRadioTracks() {
    if (isFetchingQueue) return; 
    isFetchingQueue = true;
    toggleQueueLoading(true);

    const query = radioSeed.query;
    
    // 1. Randomness: Use a large offset, but fetch MORE items (limit 100) to get a better shuffle pool
    let offset = Math.floor(Math.random() * 500); 
    let searchPath = `/search/?s=${encodeURIComponent(query)}&limit=100&offset=${offset}`;

    try {
        let res = await fetchHifi(searchPath);
        let data = await res.json();
        let rawItems = (data.data || data).items || [];

        // FALLBACK: If random offset was too deep (no results), try offset 0 once
        if (rawItems.length === 0 && offset > 0) {
            console.log("Radio seed offset too deep, retrying at 0...");
            searchPath = `/search/?s=${encodeURIComponent(query)}&limit=100&offset=0`;
            res = await fetchHifi(searchPath);
            data = await res.json();
            rawItems = (data.data || data).items || [];
        }
        
        // If STILL no items, we simply return. 
        // We do NOT switch to random genres or "mixes" as requested.
        if (rawItems.length === 0) {
            console.log("No tracks found for Radio seed.");
            isFetchingQueue = false;
            toggleQueueLoading(false);
            return;
        }
        
        let mappedTracks = rawItems.map(track => {
            const safeArtist = (track.artist && track.artist.name) ? track.artist.name : (track.artist || "Unknown Artist");
            const safeAlbum = (track.album && track.album.title) ? track.album.title : (track.album || "Unknown Album");
            const safeCover = (track.album && track.album.cover) ? track.album.cover : null;
            const safeColor = (track.album && track.album.vibrantColor) ? track.album.vibrantColor : null;

            return {
                id: track.id,
                name: track.title || "Unknown Title",
                artist: safeArtist,
                album: safeAlbum,
                albumArt: getHighResArtwork(safeCover),
                storage: 'tidal',
                duration: track.duration,
                audioQuality: track.audioQuality,
                vibrantColor: safeColor
            };
        });
        
        // 2. Heavy Shuffling: Shuffle the raw mapped result immediately
        shuffleArray(mappedTracks);

        // 3. Deduplication Logic
        const currentQueueIds = new Set(playQueue.map(s => s.id));
        
        // Filter out songs ALREADY in the queue (Strict)
        let candidates = mappedTracks.filter(t => !currentQueueIds.has(t.id));

        // Separate into "Fresh" (never played this session) and "Repeats"
        let freshTracks = candidates.filter(t => !sessionPlayedIds.has(t.id));
        let repeatTracks = candidates.filter(t => sessionPlayedIds.has(t.id));

        let finalSelection = [];

        // If we have plenty of fresh tracks, just use them
        if (freshTracks.length >= 20) {
            finalSelection = freshTracks;
        } else {
            // If running low on fresh tracks, mix in repeats to ensure radio flows
            console.log(`Radio mixing: ${freshTracks.length} fresh, ${repeatTracks.length} repeats`);
            finalSelection = [...freshTracks, ...repeatTracks];
        }

        // 4. Final Shuffle: Mix the fresh and repeats together so repeats don't clump at the end
        shuffleArray(finalSelection);

        if (finalSelection.length > 0) {
            // Take a reasonable chunk (e.g., 25 songs) to add to queue
            playQueue.push(...finalSelection.slice(0, 25));
            if (isPanelVisible && panelContent === 'queue') renderQueue();
        }
        
    } catch (e) {
        console.error("Radio fetch failed", e);
    } finally {
        isFetchingQueue = false;
        toggleQueueLoading(false);
    }
}

        function rendertidalSearchResults(totalItems = 0) {
            const resultsGrid = document.getElementById('tidal-results-grid');
            if (lasttidalSearchResults.length === 0) {
                resultsGrid.innerHTML = '<div class="no-results" style="grid-column: 1 / -1;"><p>No results found.</p></div>';
                return;
            }

            let resultsHtml = '';
            switch (tidalFilter) {
                case 'artists':
                    resultsGrid.className = 'item-grid';
                    resultsHtml = lasttidalSearchResults.map(artist => `
                        <div class="item-card" data-artist-id="${artist.id}" data-artist-name="${sanitize(artist.name)}">
                            <img src="${getHighResArtwork(artist.picture, 320)}" class="item-card-art" style="border-radius: 50%; corner-shape: round;">
                            <div class="item-card-info" style="text-align: center;"><div class="item-card-title">${sanitize(artist.name)}</div></div>
                        </div>`).join('');
                    break;
                case 'albums':
                    resultsGrid.className = 'item-grid';
                     resultsHtml = lasttidalSearchResults.map(album => `
                        <div class="item-card" data-album-id="${album.id}" data-album-name="${sanitize(album.title)}" data-album-artist-name="${sanitize(album.artists[0].name)}">
                            <img src="${getHighResArtwork(album.cover)}" class="item-card-art">
                            <div class="item-card-info"><div class="item-card-title">${sanitize(album.title)}</div><div class="item-card-subtitle">${sanitize(album.artists[0].name)}</div></div>
                        </div>`).join('');
                    break;
                case 'playlists':
                    resultsGrid.className = 'item-grid';
                    resultsHtml = lasttidalSearchResults.map(playlist => {
                        const playlistId = playlist.uuid || playlist.id;
                        const playlistTitle = playlist.title || playlist.name || 'Unknown Playlist';
                        const playlistImage = playlist.image || playlist.squareImage || playlist.cover;
                        const trackCount = playlist.numberOfTracks || playlist.numberOfItems || 0;
                        
                        const playlistArt = playlistImage ? getHighResArtwork(playlistImage) : null;
                        return `
                        <div class="item-card" data-playlist-id="${playlistId}" data-playlist-title="${sanitize(playlistTitle)}">
                            ${getPlaylistArtPlaceholder(playlistArt ? [playlistArt] : [])}
                            <div class="item-card-info">
                                <div class="item-card-title">${sanitize(playlistTitle)}</div>
                                <div class="item-card-subtitle">${trackCount}songs</div>
                            </div>
                        </div>`;
                    }).join('');
                    break;
                case 'tracks':
                default:
                    resultsGrid.className = 'item-grid';
                    resultsHtml = lasttidalSearchResults.map(track => {
                        // Feature 5: Badges
                        const explicitBadge = track.explicit ? `<span class="badge explicit">E</span>` : '';
                        
                        return `
                        <div class="item-card" data-track-id="${track.id}">
                            <img src="${getHighResArtwork(track.album.cover)}" class="item-card-art">
                            <div class="item-card-info">
                                <div class="item-card-title">${sanitize(track.title)}${getExplicitBadge(track.explicit)}</div>
                                <div class="item-card-subtitle">${sanitize(track.artist.name)}</div>
                            </div>
                        </div>`;
                    }).join('');
                    break;
            }
            resultsGrid.innerHTML = resultsHtml;
            
            if (lasttidalSearchResults.length > 0 && lasttidalSearchResults.length < totalItems) {
                resultsGrid.insertAdjacentHTML('beforeend', `<div style="grid-column: 1 / -1; text-align: center; padding: 20px;">
                                              <button id="loadMoreBtn" class="action-btn">Load More</button>
                                          </div>`);
            }
        }

function setView(viewName) {
    const isNowPlaying = (viewName === 'now-playing');
    const previousView = activeView;

    // Smart Navigation State Tracking
    if (isNowPlaying) {
        if (previousView !== 'now-playing') {
            lastMainView = previousView;
        }
    } else {
        lastMainView = viewName;
    }

    // Handle Search State Persistence
    if (previousView === 'search' && !isNowPlaying && viewName !== 'search') {
        document.getElementById('searchInput').value = '';
        renderSearchResults(); 
    }

    activeView = viewName;

    // --- Transition Logic ---
    const nowPlayingEl = document.getElementById('now-playing-view');

    if (isNowPlaying) {
        // OPENING PLAYER
        body.style.backgroundColor = 'var(--background-color)';
        if (!animationFrameId) animateCanvas();
        if (!visualizerFrameId && visualizerDraw) visualizerDraw();

        // 1. Ensure Player is display:flex but invisible
        nowPlayingEl.style.display = 'flex';
        
        // 2. Force reflow to enable transition
        void nowPlayingEl.offsetWidth; 

        // 3. Add visible class to trigger fade in
        nowPlayingEl.classList.add('visible');

        // Note: We leave the underlying view (e.g. Home) visible behind the player 
        // to ensure the transition looks smooth (no white flash). 
        // Since the player is fixed/z-indexed, it covers it.

    } else {
        // CLOSING PLAYER or SWITCHING TABS
        if (previousView === 'now-playing') {
            // We are closing the player.
            // 1. Remove visible class to trigger fade out
            nowPlayingEl.classList.remove('visible');

            // 2. Wait for transition, then display: none
            setTimeout(() => {
                if (activeView !== 'now-playing') {
                    nowPlayingEl.style.display = 'none';
                    
                    // Stop heavy animations after fade out is done
                    if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                    if (visualizerFrameId) { cancelAnimationFrame(visualizerFrameId); visualizerFrameId = null; }
                }
            }, 300); // Match CSS transition duration
            
            body.style.backgroundColor = '';
        } else {
            // Switching between normal tabs (Home -> Library) - Instant switch
            // Ensure player is hidden if we weren't in it
            nowPlayingEl.style.display = 'none';
            nowPlayingEl.classList.remove('visible');
            body.style.backgroundColor = '';
        }

        // Render target view immediately
        viewContainers.forEach(container => {
            // Skip now-playing in this loop as we handled it manually above
            if (container.id === 'now-playing-view') return;

            const isVisible = container.id === `${viewName}-view`;
            container.style.display = isVisible ? 'flex' : 'none';

            if (isVisible) {
                if (scrollPositions[viewName] !== undefined) {
                    container.scrollTop = scrollPositions[viewName];
                }
                
                if (viewName === 'library') { renderLibraryPage(); } 
                else if (viewName === 'home') { renderHomePage(); } 
                else if (viewName === 'radio') renderRadioPage();
                else if (viewName === 'tidal') rendertidalPage();
                else if (viewName === 'search') { renderSearchResults(); }
            }
        });
    }
    
    // Tab State
    tabBtns.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.view === viewName);
    });

    if (isNowPlaying && currentSongId) {
        const song = currentlyPlayingSong; 
        if (song) updatePlayerUI(song);
    }
    
    // Toolbar: Always hide when in Now Playing view
    toolbar.classList.toggle('hidden', isNowPlaying);
    
    updateMiniplayerUI(currentlyPlayingSong, audioPlayer.paused ? 'paused' : 'playing');

    document.getElementById('distortion-container').classList.toggle('active', isNowPlaying);
    if (isVisualizerInitialized && isNowPlaying && audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
    }
}
     
const initDB = () => {
    return new Promise((resolve, reject) => {
        // DB version bumped to 7
        const request = indexedDB.open('music-tidal-DB', 7);

        request.onerror = (event) => {
            console.error('IndexedDB error:', event.target.error);
            reject(event.target.error);
        };

        request.onupgradeneeded = (event) => {
            db = event.target.result;
            if (!db.objectStoreNames.contains('musicFiles')) {
                db.createObjectStore('musicFiles', { keyPath: 'id' });
            }
            if (!db.objectStoreNames.contains('songs')) {
                const songStore = db.createObjectStore('songs', { keyPath: 'id' });
                songStore.createIndex('albumArtist', 'albumArtist');
                // Add new index for play count
                songStore.createIndex('playCount', 'playCount');
            } else {
                // Ensure playCount index exists on existing stores
                const songStore = event.target.transaction.objectStore('songs');
                if (!songStore.indexNames.contains('playCount')) {
                    songStore.createIndex('playCount', 'playCount');
                }
            }
            if (!db.objectStoreNames.contains('playlists')) {
                db.createObjectStore('playlists', { keyPath: 'id', autoIncrement: true });
            }
            if (!db.objectStoreNames.contains('config')) {
                db.createObjectStore('config', { keyPath: 'key' });
            }
            // Create new store for play history
            if (!db.objectStoreNames.contains('playHistory')) {
                db.createObjectStore('playHistory', { keyPath: 'timestamp' });
            }
            if (!db.objectStoreNames.contains('tidalCache')) {
                const cacheStore = db.createObjectStore('tidalCache', { keyPath: 'id' });
                cacheStore.createIndex('timestamp', 'timestamp');
            }
        };

        request.onsuccess = (event) => {
            db = event.target.result;
            resolve();
        };
    });
};

function promiseIDBRequest(request) {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

function createPlayQueue() {
    if (isShuffleEnabled) {
        let availableSongs = [...songs];
        let currentSong = null;
        
        if (currentSongId) {
            currentSong = availableSongs.find(s => s.id === currentSongId);
            availableSongs = availableSongs.filter(s => s.id !== currentSongId);
        }
        
        for (let i = availableSongs.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableSongs[i], availableSongs[j]] = [availableSongs[j], availableSongs[i]];
        }
        
        return currentSong ? [currentSong, ...availableSongs] : availableSongs;
    }
    
    return [...songs];
}

function resetPlayer() {
    audioPlayer.pause();
    audioPlayer.currentTime = 0;
    currentSongId = null;
    currentlyPlayingSong = null; // Clear the currently playing song object
    updateMiniplayerUI(null);
    playQueue = [];
    currentQueueIndex = -1;

    isShuffleEnabled = false;
    updateShuffleButtonState();

    const defaultImage = "/streams/favicon.png";
    const defaultImageBig = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPgSURBVHhe7cEBAQAAAIIg/69uSEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcqAFFFQAB8Dl/nAAAAABJRU5ErkJggg==";

    albumArtImg.src = defaultImageBig;

    updateAllBackgrounds('');
    
    musicTitle.textContent = 'No song playing';
    musicArtist.innerHTML = '&nbsp;';
    
    updateTimeDisplays();
    playPauseIcon.textContent = 'play_arrow';
    playPauseBtn.classList.remove('playing');
    document.title = 'Streams';
    updateFavicon(defaultImage);

    // Revoke any existing blob URL to prevent memory leaks
    if (currentMediaSessionArtBlobUrl) {
        URL.revokeObjectURL(currentMediaSessionArtBlobUrl);
        currentMediaSessionArtBlobUrl = null;
    }

    if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = null;
        navigator.mediaSession.playbackState = 'none';
    }

    connectAudioGraph();
    document.querySelector('.lyrics-button').style.display = ''; // Ensure lyrics button is visible on reset
    
    if (activeView === 'now-playing') {
        setView(lastMainView);
    }
}
    
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return "--:--";
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function isDataSaver() {
            if (navigator.connection) {
                if (navigator.connection.saveData) return true;
                if (['slow-2g', '2g', '3g'].includes(navigator.connection.effectiveType)) return true;
            }
            return false;
        }
        
        async function saveBlobToLocalFile(id, blob) {
            const tx = db.transaction('musicFiles', 'readwrite');
            tx.objectStore('musicFiles').put({ id: id, file: blob });
            await tx.done;
        }

        async function repairLocalFile(tidalSong, localId) {
            try {
                const cached = await processAndCacheAudio(tidalSong);
                if (cached && cached.blob) {
                    const tx = db.transaction(['musicFiles', 'tidalCache', 'songs'], 'readwrite');
                    tx.objectStore('musicFiles').put({ id: localId, file: cached.blob });
                    tx.objectStore('tidalCache').delete(tidalSong.id);
                    
                    // Update metadata: change storage from 'filesystem' to 'indexeddb'
                    const songStore = tx.objectStore('songs');
                    const songReq = songStore.get(localId);
                    songReq.onsuccess = () => {
                        const songData = songReq.result;
                        if (songData) {
                            songData.storage = 'indexeddb';
                            // Store the actual tidal ID in the local metadata for reference
                            songData.cloudId = tidalSong.id;
                            songStore.put(songData);
                        }
                    };
                    
                    await tx.done;

                    // Update in-memory song object
                    const memorySong = songs.find(s => s.id === localId);
                    if (memorySong) memorySong.storage = 'indexeddb';
                    if (currentlyPlayingSong && currentlyPlayingSong.id === localId) {
                        currentlyPlayingSong.storage = 'indexeddb';
                    }

                    console.log(`Successfully repaired and migrated local file ID: ${localId}`);
                }
            } catch (e) {
                console.error("Self-healing repair failed:", e);
            }
        }

        async function recoverMissingLocalSong(song) {
            if (!istidalEnabled) return null;
            
            const strategies = [
                song.isrc,
                `${song.artist} ${song.name}`.replace(/[^\w\s]/gi, '')
            ].filter(Boolean);

            for (const query of strategies) {
                console.log(`Recovery attempt [${query}] for ${song.name}`);
                try {
                    const searchRes = await fetchHifi(`/search/?s=${encodeURIComponent(query)}&limit=10`);
                    const searchJson = await searchRes.json();
                    const items = (searchJson.data || searchJson).items || [];
                    
                    if (items.length === 0) continue;

                    // Improved matching: Priority to ISRC, then exact title+artist
                    const match = items.find(t => t.isrc === song.isrc) || 
                                  items.find(t => t.title?.toLowerCase() === song.name.toLowerCase()) ||
                                  items[0];
                    
                    if (!match) continue;
                    
                    const tidalSong = {
                        id: match.id,
                        name: match.title || match.name,
                        artist: match.artist?.name || match.artist || "Unknown",
                        album: match.album?.title || match.album || "Unknown",
                        storage: 'tidal',
                        isrc: match.isrc
                    };
                    
                    const streamInfo = await resolveTidalUrl(tidalSong);
                    if (streamInfo && streamInfo.url) {
                        // iOS and Cast can handle direct streams without CORS silencing
                        if (isIOS || castSession) {
                            if (!castSession && !isDataSaver()) repairLocalFile(tidalSong, song.id);
                            return streamInfo.url;
                        }
                    }
                    
                    // Desktop/Android MUST use Blobs to avoid "outputs zeroes" CORS error
                    const cached = await processAndCacheAudio(tidalSong);
                    if (cached && cached.blob) {
                        // Save to DB and return local Blob URL
                        await saveBlobToLocalFile(song.id, cached.blob);
                        return URL.createObjectURL(cached.blob);
                    }
                } catch (e) {
                    console.warn(`Strategy ${query} failed:`, e);
                }
            }
            return null;
        }

// Function to update the songs array based on the DOM order
function updateSongsArrayFromDOM() {
  const newSongsOrder = [];
  const albumOrder = [];
  
  document.querySelectorAll('.album-section').forEach((albumSection, albumIndex) => {
    const albumName = albumSection.querySelector('.album-name').textContent;
    const albumArtist = albumSection.querySelector('.album-artist').textContent;
    
    albumOrder.push({
      name: albumName,
      index: albumIndex
    });
    
    albumSection.querySelectorAll('.music-item').forEach((musicItem, songIndex) => {
      const songId = parseFloat(musicItem.dataset.id);
      const song = songs.find(s => s.id === songId);
      
      if (song) {
        song.trackNumber = songIndex + 1;
        song.albumOrder = albumIndex;
        newSongsOrder.push(song);
      }
    });
  });
  
  songs = newSongsOrder;
  
  updatePlayQueue();
  
  saveSongs();
}

function loadAndPlaySong(song) {
    if (!song) return;
    playSong(song);
}
        
function updatePageTitle() {
    if (currentSongId) {
        const song = currentlyPlayingSong;
        if (song) {
            const currentTime = formatTime(audioPlayer.currentTime);
            document.title = `${currentTime} | ${sanitize(song.name)}${getExplicitBadge(song.explicit)}  ${sanitize(song.artist)}`;
        }
    } else {
        document.title = 'Streams'; // Default title when no song is playing
    }
}

function setupLongPressListeners(container) {
    let longPressTimer;
    let isLongPress = false;
    let startX, startY;
    let moved = false; // Flag to track if the touch/mouse has moved significantly
    const LONG_PRESS_DURATION = 500;
    const MOVE_THRESHOLD = 10; // Pixels a user can move before it's considered a scroll

    const handlePressStart = (e) => {
        const musicItem = e.target.closest('.music-item[data-id], .item-card[data-id]');
        if (!musicItem) return;

        startX = e.touches ? e.touches[0].clientX : e.clientX;
        startY = e.touches ? e.touches[0].clientY : e.clientY;
        isLongPress = false;
        moved = false; // Reset on new touch start

        longPressTimer = setTimeout(() => {
            if (!moved) { // Only trigger long press if user hasn't scrolled
                isLongPress = true;
                const songId = parseFloat(musicItem.dataset.id);
                openSongContextMenu(musicItem, songId);
            }
        }, LONG_PRESS_DURATION);
    };

    const handlePressMove = (e) => {
        // If the timer has already been cleared (e.g., by a long press), we don't need to do anything
        if (!longPressTimer) return;

        const currentX = e.touches ? e.touches[0].clientX : e.clientX;
        const currentY = e.touches ? e.touches[0].clientY : e.clientY;

        // Check if the movement exceeds our threshold
        if (Math.abs(currentX - startX) > MOVE_THRESHOLD || Math.abs(currentY - startY) > MOVE_THRESHOLD) {
            moved = true; // It's a scroll
            clearTimeout(longPressTimer); // Cancel the long press timer
            longPressTimer = null;
        }
    };

    const handlePressEnd = (e) => {
        clearTimeout(longPressTimer);

        // If it was a long press, stop the event from bubbling up as a click
        if (isLongPress) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        
        // If the touch moved, it was a scroll, not a click, so do nothing.
        if (moved) {
            return;
        }

        // This is a regular click/tap
        const musicItem = e.target.closest('.music-item[data-id], .item-card[data-id]');
        if (musicItem) {
            const songId = parseFloat(musicItem.dataset.id);
            const song = songs.find(s => s.id === songId);
            if (song) {
                const contextSongs = Array.from(container.querySelectorAll('.music-item[data-id], .item-card[data-id]'))
                    .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                    .filter(Boolean);
                playSong(song, contextSongs.length > 0 ? contextSongs : [song]);
            }
        }
    };
    
    // Handle right-click (contextmenu) events
    const handleContextMenu = (e) => {
        const musicItem = e.target.closest('.music-item[data-id], .item-card[data-id]');
        if (musicItem) {
            e.preventDefault();
            const songId = parseFloat(musicItem.dataset.id);
            openSongContextMenu(musicItem, songId);
        }
    };

    // Remove old listeners to prevent duplicates if this function is called multiple times
    container.removeEventListener('mousedown', handlePressStart);
    container.removeEventListener('touchstart', handlePressStart, { passive: true });
    container.removeEventListener('mousemove', handlePressMove);
    container.removeEventListener('touchmove', handlePressMove, { passive: true });
    container.removeEventListener('mouseup', handlePressEnd);
    container.removeEventListener('touchend', handlePressEnd);
    container.removeEventListener('mouseleave', handlePressEnd); // Handle mouse leaving the element
    container.removeEventListener('touchcancel', handlePressEnd); // Handle cancelled touches
    container.removeEventListener('contextmenu', handleContextMenu);

    // Add new listeners
    container.addEventListener('mousedown', handlePressStart);
    container.addEventListener('touchstart', handlePressStart, { passive: true });
    container.addEventListener('mousemove', handlePressMove);
    container.addEventListener('touchmove', handlePressMove, { passive: true });
    container.addEventListener('mouseup', handlePressEnd);
    container.addEventListener('touchend', handlePressEnd);
    container.addEventListener('mouseleave', handlePressEnd);
    container.addEventListener('touchcancel', handlePressEnd);
    container.addEventListener('contextmenu', handleContextMenu);
}
        
        function isAudioFile(file) {
            const allowedTypes = [
                'audio/mpeg', 'audio/wav', 'audio/wave', 'audio/x-wav', 'audio/flac', 
                'audio/ogg', 'audio/opus', 'audio/x-m4a', 'audio/aac', 'audio/webm', 'audio/x-flac'
            ];
            const allowedExtensions = /\.(mp3|wav|flac|ogg|opus|m4a|aac)$/i;
            
            return allowedTypes.includes(file.type) || (file.name && file.name.match(allowedExtensions));
        }
        
function generateRandomGradient() {
    const colors = [
        '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeead',
        '#d4a5a5', '#9b59b6', '#3498db', '#e74c3c', '#2ecc71',
        '#f1c40f', '#1abc9c', '#e67e22', '#7f8c8d', '#2c3e50'
    ];
    
    const color1 = colors[Math.floor(Math.random() * colors.length)];
    let color2;
    do {
        color2 = colors[Math.floor(Math.random() * colors.length)];
    } while (color1 === color2);
    
    const angle = Math.floor(Math.random() * 360);
    
    const canvas = document.createElement('canvas');
    canvas.width = 500;
    canvas.height = 500;
    const ctx = canvas.getContext('2d');
    
    const gradient = ctx.createLinearGradient(0, 0, 500, 500);
    gradient.addColorStop(0, color1);
    gradient.addColorStop(1, color2);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 500, 500);
    
    return canvas.toDataURL('image/jpeg', 0.9);
}

function getPlaylistArtPlaceholder(imageUrls, className = "item-card-art") {
    const validUrls = (imageUrls || []).filter(u => {
        return u && typeof u === 'string' && u.length > 20 && !u.includes('undefined') && !u.endsWith('null/640x640.jpg');
    }).slice(0, 4);
    
    if (validUrls.length >= 4) {
        return `
        <div class="${className}" style="display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; overflow: hidden; padding: 0; gap: 0; border: none; aspect-ratio: 1/1;">
            <img src="${validUrls[0]}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 0; box-shadow: none; border: none; outline: none; display: block;">
            <img src="${validUrls[1]}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 0; box-shadow: none; border: none; outline: none; display: block;">
            <img src="${validUrls[2]}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 0; box-shadow: none; border: none; outline: none; display: block;">
            <img src="${validUrls[3]}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 0; box-shadow: none; border: none; outline: none; display: block;">
        </div>`;
    }
    
    const fallback = validUrls.length > 0 ? validUrls[0] : generateRandomGradient();
    return `<img src="${fallback}" class="${className}">`;
}

function updateLocalSongLookup(songsToAdd, options = {}) {
    if (options.clear) {
        localSongLookup.clear();
        console.log("Local song lookup map cleared.");
    }
    if (!Array.isArray(songsToAdd)) return; // Safety check

    for (const song of songsToAdd) {
        const uniqueKey = `${(song.artist || '').toLowerCase().trim()}::${(song.name || '').toLowerCase().trim()}`;
        // Only add the song if this key doesn't already exist.
        // This prioritizes the first-added version in case of library inconsistencies.
        if (!localSongLookup.has(uniqueKey)) {
            localSongLookup.set(uniqueKey, song);
        }
    }
}
        
async function preloadSongs(files) {
    const allowedTypes = [
        'audio/mpeg',        // MP3
        'audio/wav',         // WAV
        'audio/flac',        // FLAC
        'audio/ogg',         // OGG
        'audio/opus',        // OPUS
        'audio/x-m4a',       // M4A
        'audio/aac',         // AAC
        'audio/webm',        // WEBM audio
        'audio/x-flac'       // Alternative FLAC MIME type
    ];

    const filesArray = Array.from(files).filter(file => 
        allowedTypes.includes(file.type) || 
        file.name.match(/\.(mp3|wav|flac|ogg|opus|m4a|aac)$/i)
    );
    
    if (filesArray.length === 0) {
        console.warn('No valid audio files found');
        return;
    }

    for (const file of filesArray) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            
            await new Promise((resolve, reject) => {
                const transaction = db.transaction(['musicFiles'], 'readwrite');
                const store = transaction.objectStore('musicFiles');
                
                const song = {
                    id: Date.now() + Math.random(),
                    file: new Blob([arrayBuffer], { type: file.type })
                };
                
                const request = store.put(song);
                
                transaction.oncomplete = () => resolve();
                transaction.onerror = (event) => reject(event.target.error);
            });
        } catch (error) {
            console.error('Error processing file:', error);
        }
    }
}

function updateFavicon(albumArt) {
  if (!albumArt) return;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const size = 32; 
  const radius = 10;

  canvas.width = size;
  canvas.height = size;

  const img = new Image();
  if (!albumArt.startsWith('data:')) {
    img.crossOrigin = 'anonymous';
  }

  img.onload = function() {
    ctx.clearRect(0, 0, size, size);
    ctx.beginPath();
    if (ctx.roundRect) {
        ctx.roundRect(0, 0, size, size, radius);
    } else { // Fallback for older browsers
        ctx.rect(0, 0, size, size);
    }
    ctx.closePath();
    ctx.clip();
    ctx.drawImage(img, 0, 0, size, size);

    const roundedImageURL = canvas.toDataURL('image/png');
    const existingFavicon = document.getElementById('favicon');
    if (existingFavicon) {
        existingFavicon.href = roundedImageURL;
    }
  };

  img.onerror = function() {
    console.error('Error loading album art for favicon');
  };
  img.src = getLowResArtUrl(albumArt);
}

async function loadSong(song) {
    playSong(song);
}
        
async function extractMetadata(file) {
    return new Promise((resolve) => {
        new jsmediatags.Reader(file)
            .read({
                onSuccess: async function(tag) {
                    let albumArt;
                    if (tag.tags.picture) {
                        const { data, format } = tag.tags.picture;
                        const base64String = data.reduce((acc, curr) => acc + String.fromCharCode(curr), '');
                        albumArt = `data:${format};base64,${btoa(base64String)}`;
                    } else {
                        albumArt = generateRandomGradient();
                    }

                    let lyricsText = null;
                    let lrcData = null;
                    let foundSyncedLyrics = false;
                    const lrcCandidates = [
                        tag.tags.USLT?.lyrics,
                        (typeof tag.tags.lyrics === 'object' ? tag.tags.lyrics.lyrics : tag.tags.lyrics),
                        tag.tags.LYRICS
                    ];
                    for (const candidate of lrcCandidates) {
                        if (candidate) {
                            const parsed = parseLRC(candidate);
                            if (parsed) {
                                lrcData = parsed;
                                lyricsText = candidate;
                                foundSyncedLyrics = true;
                                break;
                            }
                        }
                    }
                    if (!foundSyncedLyrics) {
                        lyricsText = lrcCandidates.find(text => typeof text === 'string' && text.trim() !== '') || null;
                    }

                    const parseComplexTag = (rawTag) => {
                        if (!rawTag) return null;
                        const value = rawTag.data || rawTag;
                        if (typeof value === 'object' && value.no) {
                            return parseInt(value.no, 10);
                        }
                        const parsed = parseInt(String(value).split('/')[0], 10);
                        return isNaN(parsed) ? null : parsed;
                    };

                    const discNumber = parseComplexTag(tag.tags.DISCNUMBER || tag.tags.disk || tag.tags.TPOS);
                    const trackNumber = parseComplexTag(tag.tags.TRACKNUMBER || tag.tags.track);
                    
                    const albumArtist = tag.tags.TPE2?.data || tag.tags.album_artist || tag.tags.artist || 'Unknown Artist';

                    const genreTag = tag.tags.TCON || tag.tags.genre;
                    const genre = genreTag ? (genreTag.data || genreTag) : null;
                    const bpmTag = tag.tags.TBPM || tag.tags.bpm;
                    const bpm = bpmTag ? (bpmTag.data || bpmTag) : null;

                    resolve({
                        title: tag.tags.title || file.name.replace(/\.[^/.]+$/, ""),
                        artist: tag.tags.artist || 'Unknown Artist',
                        album: tag.tags.album || 'Unknown Album',
                        albumArtist: albumArtist,
                        year: tag.tags.year || '',
                        albumArt: albumArt,
                        trackNumber: trackNumber,
                        discNumber: discNumber,
                        lyrics: lyricsText,
                        lrcData: lrcData,
                        genre: genre,
                        bpm: bpm
                    });
                },
                onError: (error) => {
                    console.error("jsmediatags ERROR for:", file.name, error);
                    resolve({
                        title: file.name.replace(/\.[^/.]+$/, ""),
                        artist: 'Unknown Artist',
                        album: 'Unknown Album',
                        albumArtist: 'Unknown Artist',
                        year: '',
                        albumArt: generateRandomGradient(),
                        trackNumber: null,
                        discNumber: null,
                        lyrics: null,
                        lrcData: null,
                        genre: null,
                        bpm: null
                    });
                }
            });
    });
}
        
async function addSongs(files, storageType) {
    const newSongs = [];
    const songFilesToStore = [];

    for (let fileHandleOrFile of files) {
        try {
            const file = storageType === 'filesystem' ? await fileHandleOrFile.getFile() : fileHandleOrFile;
            if (!isAudioFile(file)) continue;

            const metadata = await extractMetadata(file);
            const newSongId = Date.now() + Math.random();

            newSongs.push({
                id: newSongId,
                name: metadata.title,
                artist: metadata.artist,
                album: metadata.album,
                albumArtist: metadata.albumArtist,
                storage: storageType,
                handleName: file.name,
                dateAdded: Date.now(),
                year: metadata.year,
                albumArt: metadata.albumArt,
                trackNumber: metadata.trackNumber,
                discNumber: metadata.discNumber,
                lyrics: metadata.lyrics,
                lrcData: metadata.lrcData,
                genre: metadata.genre,
                playCount: 0 // Initialize playCount
            });

            if (storageType === 'indexeddb') {
                songFilesToStore.push({ id: newSongId, file: file });
            }

        } catch (error) {
            console.error("Could not process file:", fileHandleOrFile.name, error);
        }
    }

    if (newSongs.length > 0) {
        songs.push(...newSongs);
        processAndSortSongs();
        await saveSongs();

        if (songFilesToStore.length > 0) {
            const tx = db.transaction(['musicFiles'], 'readwrite');
            songFilesToStore.forEach(item => tx.objectStore('musicFiles').put(item));
            await tx.done;
        }
    }

    // Re-render the current view to show the new songs
    if (activeView === 'library') {
        renderLibraryPage();
    } else if (activeView === 'home') {
        renderHomePage();
    }
    updateLocalSongLookup(newSongs);
}

async function scanForNewSongs() {
    if (directoryHandles.length === 0) return false;

    console.log("Scanning for new songs in existing directories...");
    const filesToAdd = [];
    
    const existingSongNames = new Set(songs.map(s => s.handleName));

    for (const handle of directoryHandles) {
        try {
            for await (const entry of handle.values()) {
                if (entry.kind === 'file' && isAudioFile({ name: entry.name }) && !existingSongNames.has(entry.name)) {
                    filesToAdd.push(entry);
                }
            }
        } catch (e) {
            console.error(`Could not scan directory "${handle.name}". It may need to be re-added.`, e);
        }
    }

    if (filesToAdd.length > 0) {
        console.log(`Found ${filesToAdd.length} new songs. Adding them to the library...`);
        await addSongs(filesToAdd, 'filesystem');
        return true; 
    }
    
    console.log("No new songs found.");
    return false;
}

function parseLRC(lrcText) {
    if (!lrcText || !lrcText.includes('[')) return null;

    let allEntries = [];
    const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;
    // This regex will find any text enclosed in () or []
    const asideRegex = /(\[.*?\]|\(.*?\))/;

    const lines = lrcText.split('\n');

    lines.forEach(line => {
        const timeMatches = [...line.matchAll(timeRegex)];
        if (timeMatches.length === 0) return;

        const rawText = line.substring(timeMatches[timeMatches.length - 1].index + timeMatches[timeMatches.length - 1][0].length).trim();
        if (!rawText) return;

        timeMatches.forEach(match => {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            
            // Split the line by asides, keeping the delimiters.
            // e.g., "Hello (world)" becomes ["Hello ", "(world)"]
            const parts = rawText.split(asideRegex).filter(Boolean);
            
            parts.forEach(part => {
                const text = part.trim();
                if (!text) return;

                // If the part matches the aside format, classify it as 'aside'
                if (asideRegex.test(text)) {
                    const cleanedAsideText = text.slice(1, -1);
                    allEntries.push({ time, text: cleanedAsideText, type: 'aside' });
                } else {
                    allEntries.push({ time, text, type: 'line' });
                }
            });
        });
    });

    allEntries.sort((a, b) => a.time - b.time);

    return allEntries.length > 0 ? { lyrics: allEntries } : null;
}
        
async function loadSongsFromStorage() {
    try {
        const tx = db.transaction(['songs'], 'readonly');
        const songStore = tx.objectStore('songs');
        const songsRequest = songStore.getAll();
        
        const loadedSongs = await new Promise((resolve, reject) => {
            songsRequest.onsuccess = () => resolve(songsRequest.result);
            songsRequest.onerror = (e) => reject(e.target.error);
        });
        
        songs = loadedSongs || [];
        processAndSortSongs();
        updatePlayQueue();
    } catch (error) {
        console.error('Error loading songs from storage:', error);
    }
}
        
async function saveSongs() {
    const transaction = db.transaction(['songs'], 'readwrite');
    const store = transaction.objectStore('songs');
    
    return new Promise((resolve, reject) => {
        transaction.onerror = (event) => {
            console.error("Transaction error while saving songs:", event.target.error);
            reject(event.target.error);
        }
        
        store.clear();
        songs.forEach(song => {
            const songToStore = {
                id: song.id, name: song.name, artist: song.artist, album: song.album,
                albumArtist: song.albumArtist, year: song.year, albumArt: song.albumArt, 
                trackNumber: song.trackNumber, discNumber: song.discNumber,
                lyrics: song.lyrics, lrcData: song.lrcData, storage: song.storage,
                handleName: song.handleName, dateAdded: song.dateAdded,
                genre: song.genre,
                playCount: song.playCount || 0,
                bpm: song.bpm
            };
            store.add(songToStore);
        });
        
        transaction.oncomplete = () => {
            console.log(`Songs saved. Total count: ${songs.length}`);
            triggerAutoSync();
            resolve();
        };
    });
}

async function migrateToFSA() {
    if (directoryHandles.length === 0) return;

    const songsToMigrate = songs.filter(s => s.storage === 'indexeddb');
    if (songsToMigrate.length === 0) {
        console.log("No songs to migrate.");
        return;
    }

    console.log(`Starting migration for ${songsToMigrate.length} songs...`);
    const blobIdsToDelete = [];
    let migrationOccurred = false;

    for (const song of songsToMigrate) {
        let foundInHandles = false;
        for (const handle of directoryHandles) {
            try {
                await handle.getFileHandle(song.handleName);
                foundInHandles = true;
                break;
            } catch (e) { /* Not in this handle */ }
        }
        
        if (foundInHandles) {
            song.storage = 'filesystem';
            blobIdsToDelete.push(song.id);
            migrationOccurred = true;
            console.log(`Migrated "${song.name}" to File System Access.`);
        } else {
            console.warn(`Could not find "${song.handleName}" in the directory. It will remain in browser storage.`);
        }
    }

    if (migrationOccurred) {
        if (blobIdsToDelete.length > 0) {
            const deleteTx = db.transaction('musicFiles', 'readwrite');
            blobIdsToDelete.forEach(id => deleteTx.objectStore('musicFiles').delete(id));
            await deleteTx.done;
        }
        
        await saveSongs();
        alert(`Migrated ${blobIdsToDelete.length} items to use direct file access.`);
    }
}

// Helper function to find a song object from a string like "Artist - Title"
function findSongByString(artistTitleString, additionalSongs = []) {
    if (!artistTitleString) return null;

    const fullLibrary = [...songs, ...additionalSongs];
    const cleanInput = artistTitleString.trim().toLowerCase();

    // --- New, More Robust Matching Logic ---

    // 1. First, try for a perfect "Artist - Title" match.
    const lastHyphenIndex = cleanInput.lastIndexOf(' - ');
    if (lastHyphenIndex > 0) {
        const artist = cleanInput.substring(0, lastHyphenIndex).trim();
        const title = cleanInput.substring(lastHyphenIndex + 3).trim();
        const perfectMatch = fullLibrary.find(song =>
            song.artist.toLowerCase() === artist && song.name.toLowerCase() === title
        );
        if (perfectMatch) return perfectMatch;
    }

    // 2. If no perfect match, fall back to a more flexible "contains" search.
    // This is great for when the AI returns just a title or a slightly incorrect format.
    const partialMatch = fullLibrary.find(song => 
        song.name.toLowerCase().includes(cleanInput) || 
        cleanInput.includes(song.name.toLowerCase())
    );
    if (partialMatch) return partialMatch;

    return null; // Return null if no match is found after all attempts.
}

        /**
         * Takes an image source URL and creates a new, small, downscaled version of it.
         * This is the key to the performance improvement, as the animation loop
         * will only ever process these small images.
         * @param {string} src - The source URL of the high-resolution image.
         * @param {number} maxSize - The maximum width or height of the output image.
         * @returns {Promise<HTMLImageElement>} A promise that resolves with the new, loaded, resized image.
         */
        function createResizedImage(src, maxSize) {
            return new Promise((resolve, reject) => {
                const highResImage = new Image();
                highResImage.crossOrigin = 'Anonymous';
                highResImage.onload = () => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    let { width, height } = highResImage;

                    // Calculate new dimensions while maintaining aspect ratio
                    if (width > height) {
                        if (width > maxSize) {
                            height *= maxSize / width;
                            width = maxSize;
                        }
                    } else {
                        if (height > maxSize) {
                            width *= maxSize / height;
                            height = maxSize;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;

                    // Draw the high-res image onto the small canvas
                    context.drawImage(highResImage, 0, 0, width, height);
                    
                    // Create a new Image object from the small canvas data
                    const resizedImage = new Image();
                    resizedImage.onload = () => resolve(resizedImage);
                    resizedImage.onerror = reject;
                    resizedImage.src = canvas.toDataURL('image/jpeg', 0.8); // Use JPEG for better compression
                };
                highResImage.onerror = reject;
                highResImage.src = src;
            });
        }

        /**
         * A self-contained 3D Perlin noise generator.
         * Using a third dimension (z) for time allows the blob shapes to continuously evolve.
         */
        function createNoiseGenerator() {
            const p = new Uint8Array(512);
            for (let i = 0; i < 256; i++) p[i] = i;
            for (let i = 255; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [p[i], p[j]] = [p[j], p[i]];
            }
            for (let i = 0; i < 256; i++) p[i + 256] = p[i];

            const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
            const lerp = (a, b, t) => a + t * (b - a);
            const grad = (hash, x, y, z) => {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            };

            return (x, y, z) => {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
                x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
                const u = fade(x), v = fade(y), w = fade(z);
                const a = p[X] + Y, b = p[X + 1] + Y;
                const a1 = p[a] + Z, a2 = p[a + 1] + Z;
                const b1 = p[b] + Z, b2 = p[b + 1] + Z;

                return lerp(
                    lerp(
                        lerp(grad(p[a1], x, y, z), grad(p[b1], x - 1, y, z), u),
                        lerp(grad(p[a2], x, y - 1, z), grad(p[b2], x - 1, y - 1, z), u),
                    v),
                    lerp(
                        lerp(grad(p[a1 + 1], x, y, z - 1), grad(p[b1 + 1], x - 1, y, z - 1), u),
                        lerp(grad(p[a2 + 1], x, y - 1, z - 1), grad(p[b2 + 1], x - 1, y - 1, z - 1), u),
                    v),
                w) * 0.5 + 0.5; // Return in 0-1 range
            };
        }

        /**
         * Initializes a LOW-RESOLUTION canvas and starts the animation. The canvas element
         * itself will be stretched by CSS to fill the screen.
         */
        function initDistortionCanvas() {
            // This constant defines our rendering resolution. 0.25 means 25% of the screen size.
            // A lower number means better performance but a more pixelated (though blurred) source.
            const RENDER_SCALE = 0.25;

            distortionCanvas = document.getElementById('distortionCanvas');
            if (!distortionCanvas) {
                console.error("Distortion Canvas not found in the DOM.");
                return;
            }
            
            ctx = distortionCanvas.getContext('2d'); 
            if (!ctx) {
                console.error("Failed to get 2D context from the canvas.");
                return;
            }
            
            noise = createNoiseGenerator();

            currentResizedArt.crossOrigin = 'Anonymous';
            oldResizedArt.crossOrigin = 'Anonymous';
            currentResizedArt.onerror = () => console.error("Failed to load current resized album art image.");
            oldResizedArt.onerror = () => console.error("Failed to load old resized album art image for transition.");

            const resizeCanvas = () => {
                // Set the canvas's actual drawing buffer size to be a fraction of the window size.
                // For a 1920x1080 screen, this creates a tiny 480x270 canvas to draw on.
                distortionCanvas.width = window.innerWidth * RENDER_SCALE;
                distortionCanvas.height = window.innerHeight * RENDER_SCALE;

                // The CSS `width: 100%` will stretch this small buffer to fill the screen.
                
                if (currentResizedArt.src) {
                    setTimeout(initBlobs, 100);
                }
            };
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        }

        /**
         * Asynchronously loads, resizes, and initiates a smooth transition for new album art.
         * This version includes a full state reset when imageUrl is empty, fixing the bug after resetPlayer.
         * @param {string} imageUrl - The URL of the new high-resolution album art.
         */
        async function loadAlbumArtForCanvas(imageUrl) {
            // If imageUrl is empty, it's a hard reset call from resetPlayer().
            if (!imageUrl) {
                // Clear both image sources to prevent any drawing.
                currentResizedArt.src = '';
                oldResizedArt.src = '';
                // Clear the blobs array.
                blobs = [];
                // Explicitly stop any ongoing transition and reset its progress.
                isTransitioning = false;
                transitionProgress = 0;
                return; // End the function here.
            }

            // The rest of the function only runs if we have a valid imageUrl.
            if (currentResizedArt.src && currentResizedArt.dataset.originalUrl === imageUrl) return;

            try {
                if (currentResizedArt.complete && currentResizedArt.src) {
                    oldResizedArt = currentResizedArt;
                }

                const smallImageUrl = getLowResArtUrl(imageUrl);
                const newResized = await createResizedImage(smallImageUrl, 64);
                newResized.dataset.originalUrl = imageUrl;
                currentResizedArt = newResized;

                // Start a new transition.
                isTransitioning = true;
                transitionProgress = 0;
                initBlobs();

            } catch (error) {
                console.error("Failed to resize and load album art:", error);
            }
        }

        /**
         * Creates blobs with density and size optimized for the device type.
         * On mobile, it uses fewer, larger blobs for better performance and visual clarity.
         * On desktop, it uses many smaller blobs for a dense, active background.
         */
        function initBlobs() {
            if (!distortionCanvas || !ctx || !currentResizedArt.complete) return;
            blobs = [];
            const { width: imgWidth, height: imgHeight } = currentResizedArt;
            const { width: canvasWidth, height: canvasHeight } = distortionCanvas;
            
            // --- Conditional Parameters for Mobile vs. Desktop ---
            let blobCount;
            let minRadiusMultiplier, radiusVariance;
            const maxSpeed = 0.5;

            if (isMobile) {
                // Mobile Configuration: Fewer, larger blobs.
                blobCount = 3;
                // Radius will be between 40% and 60% of the smaller canvas dimension to fill the screen.
                minRadiusMultiplier = 0.4; 
                radiusVariance = 0.2;
            } else {
                // Desktop Configuration: More, smaller blobs.
                blobCount = 15;
                // Radius will be between 15% and 25% of the smaller canvas dimension.
                minRadiusMultiplier = 0.15;
                radiusVariance = 0.1;
            }

            for (let i = 0; i < blobCount; i++) { // Use the dynamically set blobCount
                
                // Use the dynamic multipliers to calculate the radius for the current device.
                const radius = (Math.random() * radiusVariance + minRadiusMultiplier) * Math.min(canvasWidth, canvasHeight);

                // This logic for assigning a unique part of the album art remains the same.
                const sourceSize = Math.min(imgWidth, imgHeight) * (Math.random() * 0.3 + 0.3);
                const sourceX = Math.random() * (imgWidth - sourceSize);
                const sourceY = Math.random() * (imgHeight - sourceSize);

                blobs.push({
                    x: Math.random() * canvasWidth,
                    y: Math.random() * canvasHeight,
                    vx: (Math.random() - 0.5) * maxSpeed,
                    vy: (Math.random() - 0.5) * maxSpeed,
                    radius: radius,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.002,
                    sourceX: sourceX,
                    sourceY: sourceY,
                    sourceSize: sourceSize,
                    time: Math.random() * 1000,
                    warpAmount: 0,
                    baseWarp: radius * 0.1,
                    contrast: 1,
                    scale: 1,
                });
            }
        }

        /**
         * Draws a single blob, adding animations based on the global beat intensity.
         * Each blob will now pulse in size and get a rotational "kick" on the beat.
         * @param {CanvasRenderingContext2D} context - The canvas context to draw on.
         * @param {object} blob - The blob object containing its properties.
         * @param {HTMLImageElement} imageToDraw - The pre-resized album art.
         * @param {number} currentBeatIntensity - The global beat intensity (0 to 1).
         */
        function drawOrganicBlob(context, blob, imageToDraw, currentBeatIntensity) {
            context.save();
            
            // --- Apply Beat Animations ---
            // 1. Calculate an effective scale for the blob (base size + beat pulse).
            const effectiveScale = 1 + currentBeatIntensity * 0.05; // 5% size increase on beat
            // 2. Calculate an effective rotation (base rotation + beat kick).
            const effectiveRotation = blob.rotation + currentBeatIntensity * 0.075; // Add a rotational nudge

            context.translate(blob.x, blob.y);
            context.rotate(effectiveRotation); // Use the animated rotation
            
            context.beginPath();
            const points = 20;
            const noiseFrequency = 1.8;
            const noiseSpeed = 0.004;
            
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const x = Math.cos(angle);
                const y = Math.sin(angle);
                const noiseVal = noise((x + 1) * noiseFrequency, (y + 1) * noiseFrequency, blob.time * noiseSpeed);
                
                // Use the animated scale to calculate the radius for this frame
                const radius = blob.radius * effectiveScale + (noiseVal * blob.radius * 0.3);

                const pointX = x * radius;
                const pointY = y * radius;
                if (i === 0) context.moveTo(pointX, pointY);
                else context.lineTo(pointX, pointY);
            }
            context.closePath();
            context.clip();
            
            // The liquid strip effect (unchanged)
            const totalWarp = blob.baseWarp + Math.sin(blob.time * 0.1) * (blob.baseWarp * 0.5);
            const numStrips = 30;
            const stripWidth = (blob.radius * 2 * effectiveScale) / numStrips; // Use effectiveScale here too
            for (let i = 0; i < numStrips; i++) {
                const stripX = -blob.radius * effectiveScale + i * stripWidth;
                const sinInput = (i / numStrips) * Math.PI + blob.time * 0.1;
                const yOffset = Math.sin(sinInput) * totalWarp;
                
                context.drawImage(
                    imageToDraw,
                    blob.sourceX + (blob.sourceSize / numStrips) * i, blob.sourceY,
                    blob.sourceSize / numStrips, blob.sourceSize,
                    stripX, -blob.radius * effectiveScale + yOffset,
                    stripWidth + 1, blob.radius * 2 * effectiveScale
                );
            }

            context.restore();
        }

        /**
         * The animation loop, now featuring a global canvas distortion on beat
         * and passing the beat intensity down to each blob for synchronized animation.
         */
        function animateCanvas() {
            animationFrameId = requestAnimationFrame(animateCanvas);
            if (!ctx) return;
            
            const { width: canvasWidth, height: canvasHeight } = distortionCanvas;
            
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // --- Beat Effect Logic ---
            const BEAT_DECAY_SPEED = 0.95; // Controls how fast the effect fades out (closer to 1 is slower)

            // If a beat is active, smoothly decay the intensity on every frame.
            if (beatIntensity > 0.001) {
                beatIntensity *= BEAT_DECAY_SPEED;
            } else {
                beatIntensity = 0; // Clamp to zero to prevent tiny residual values
            }

            // --- Background Rotation and Drawing (Unchanged) ---
            backgroundRotation += 0.002;
            if (isTransitioning) {
                transitionProgress += 1 / TRANSITION_DURATION;
                if (transitionProgress >= 1) {
                    transitionProgress = 1; isTransitioning = false; oldResizedArt = new Image();
                }
            }
            const drawRotatingBackground = (image) => {
                const scale = 1.5; // Draw larger to prevent corners from appearing during rotation
                ctx.save();
                ctx.translate(canvasWidth / 2, canvasHeight / 2);
                ctx.rotate(backgroundRotation);
                ctx.drawImage(image, 
                    -canvasWidth * scale / 2, -canvasHeight * scale / 2, 
                    canvasWidth * scale, canvasHeight * scale
                );
                ctx.restore();
            };
            if (isTransitioning && oldResizedArt.complete && oldResizedArt.src) {
                ctx.globalAlpha = 1 - transitionProgress;
                drawRotatingBackground(oldResizedArt);
            }
            if (currentResizedArt.complete && currentResizedArt.src) {
                ctx.globalAlpha = isTransitioning ? transitionProgress : 1;
                drawRotatingBackground(currentResizedArt);
            }
            ctx.globalAlpha = 1;
            
            // --- Update and Draw Blobs ---
            blobs.forEach(blob => {
                // Blob movement logic is unchanged
                blob.x += blob.vx;
                blob.y += blob.vy;
                blob.rotation += blob.rotationSpeed;
                const radius = blob.radius * (1 + beatIntensity * 0.1); // Use an effective radius for wrapping
                if (blob.x - radius > canvasWidth) { blob.x = -radius; } 
                else if (blob.x + radius < 0) { blob.x = canvasWidth + radius; }
                if (blob.y - radius > canvasHeight) { blob.y = -radius; } 
                else if (blob.y + radius < 0) { blob.y = canvasHeight + radius; }

                blob.time += 0.1;

                // --- Draw Blobs with Transition and Beat Intensity ---
                // Pass the decaying `beatIntensity` to the drawing function
                if (isTransitioning && oldResizedArt.complete && oldResizedArt.src) {
                    ctx.globalAlpha = 1 - transitionProgress;
                    drawOrganicBlob(ctx, blob, oldResizedArt, beatIntensity);
                }
                if (currentResizedArt.complete && currentResizedArt.src) {
                    ctx.globalAlpha = isTransitioning ? transitionProgress : 1;
                    drawOrganicBlob(ctx, blob, currentResizedArt, beatIntensity);
                }
                ctx.globalAlpha = 1;
            });

            // 3. If a beat was active, restore the canvas from the global distortion.
            if (beatIntensity > 0.001) {
                ctx.restore();
            }
        }
        
        /**
         * Triggers the global beat effect by setting the intensity to its maximum.
         * The animateCanvas function will handle the decay and animation.
         */
        function triggerBeatEffect() {
            beatIntensity = 1;
        }
        
async function createResizedImageURL(imageUrl, width, height) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        if (!imageUrl.startsWith('data:')) {
            img.crossOrigin = 'Anonymous';
        }
        
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            resolve(canvas.toDataURL('image/jpeg', 0.8)); 
        };
        
        img.onerror = (err) => {
            console.error("Failed to load image for resizing.", err);
            reject(imageUrl); 
        };
        
        img.src = imageUrl;
    });
}

async function updateAllBackgrounds(imageUrl) {
    loadAlbumArtForCanvas(imageUrl);
}

class BeatDetector {
    constructor(frequencyBands, historySize = 40, minThreshold = 8) {
        this.frequencyBands = frequencyBands;
        this.historySize = historySize;
        this.minFluxThreshold = minThreshold;
        this.fluxHistories = this.frequencyBands.map(() => []);
        this.lastEnergies = new Array(this.frequencyBands.length).fill(0);
    }

    update(dataArray) {
        let isBeat = false;
        for (let i = 0; i < this.frequencyBands.length; i++) {
            const band = this.frequencyBands[i];
            const history = this.fluxHistories[i];
            
            let currentEnergy = 0;
            for (let j = band[0]; j <= band[1]; j++) currentEnergy += dataArray[j];
            currentEnergy /= (band[1] - band[0] + 1);

            const flux = Math.max(0, currentEnergy - this.lastEnergies[i]);
            this.lastEnergies[i] = currentEnergy;

            if (history.length < this.historySize) {
                history.push(flux);
                continue;
            }
            
            const averageFlux = history.reduce((a, b) => a + b, 0) / history.length;
            const stdDev = this._calculateStandardDeviation(history, averageFlux);
            const dynamicThreshold = averageFlux + (1.5 * stdDev);

            if (flux > dynamicThreshold && flux > this.minFluxThreshold) {
                isBeat = true;
            }
            history.push(flux);
            history.shift();
        }
        return isBeat;
    }

    _calculateStandardDeviation(array, mean) {
        if (array.length < 2) return 0;
        const variance = array.reduce((acc, val) => acc + (val - mean) ** 2, 0) / array.length;
        return Math.sqrt(variance);
    }
}

class TempoEstimator {
    constructor() { this.reset(); }
    reset() {
        this.beatTimestamps = [];
        this.estimatedBPM = 120;
    }
    logBeat(timestamp) {
        this.beatTimestamps.push(timestamp);
        if (this.beatTimestamps.length > 30) this.beatTimestamps.shift();
        if (this.beatTimestamps.length < 10) return;

        const intervals = [];
        for (let i = 1; i < this.beatTimestamps.length; i++) {
            intervals.push(this.beatTimestamps[i] - this.beatTimestamps[i-1]);
        }
        intervals.sort((a, b) => a - b);
        const medianInterval = intervals[Math.floor(intervals.length / 2)];
        if (medianInterval > 0.2 && medianInterval < 2.0) {
            const currentBpm = 60 / medianInterval;
            this.estimatedBPM = this.estimatedBPM * 0.9 + currentBpm * 0.1;
        }
    }
    getBPM() { return this.estimatedBPM; }
}

function initVisualizer() {
    if (document.body.classList.contains('reduce-animations')) {
        const canvas = document.getElementById('visualizerCanvas');
        if (canvas) canvas.style.display = 'none';
        return; 
    }

    // iOS Fix: Disable Web Audio API graph to ensure stable background playback.
    // iOS Safari aggressively suspends AudioContexts in the background, which 
    // silences audio routed through createMediaElementSource.
    if (isIOS) {
        isVisualizerInitialized = true; 
        return;
    }

    if (isVisualizerInitialized) return;

    try {
        // 1. Create the context and all nodes first
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        eqBass = audioContext.createBiquadFilter();
        eqMid = audioContext.createBiquadFilter();
        eqTreble = audioContext.createBiquadFilter();
        analyser = audioContext.createAnalyser();
        source = audioContext.createMediaElementSource(audioPlayer);

        // 2. Configure the EQ nodes
        eqBass.type = 'lowshelf'; eqBass.frequency.value = 300; 
        eqMid.type = 'peaking'; eqMid.frequency.value = 1000; eqMid.Q.value = 1; 
        eqTreble.type = 'highshelf'; eqTreble.frequency.value = 3000;
        
        // 3. Connect the entire audio graph in order
        eqBass.connect(eqMid);
        eqMid.connect(eqTreble);
        eqTreble.connect(analyser);
        analyser.connect(audioContext.destination);

        // 4. Configure the analyser
        if (isMobile) {
            analyser.fftSize = 64;
        } else {
            analyser.fftSize = 2048;
        }
        
        analyser.smoothingTimeConstant = 0.8;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const displacementFilter = document.getElementById('displacement');
        const turbulenceFilter = document.getElementById('turbulence');

        if (!isMobile) {
            beatDetector = new BeatDetector([[0, 10], [10, 20], [40, 80], [100, 200]]);
            tempoEstimator = new TempoEstimator();
        }
        
        const canvas = document.getElementById('visualizerCanvas');
        const canvasCtx = canvas.getContext('2d');
        
        // Define separate bar indices for desktop and mobile to match their FFT sizes.
        const desktopBarIndices = [5, 10, 30, 100, 200, 400];
        const mobileBarIndices = [1, 3, 6, 12, 20, 28]; // Mapped to a 32-bin array
        const numBars = 6;
        
        const sensitivityMultipliers = [1, 1.05, 1.1, 1.15, 1.25, 1.4];
        const powerCurve = 2.2;
        
        let smoothedPulse = 0.0; 
        const smoothingFactor = 0.2;

        visualizerDraw = () => {
            visualizerFrameId = requestAnimationFrame(visualizerDraw);
            analyser.getByteFrequencyData(dataArray);
            
            if (!isMobile && beatDetector) {
                const isSpectralBeat = beatDetector.update(dataArray);
                const currentTime = audioPlayer.currentTime;
                let effectiveBPM = songBPM;

                if (!effectiveBPM && tempoEstimator) {
                    if (isSpectralBeat) tempoEstimator.logBeat(currentTime);
                    effectiveBPM = tempoEstimator.getBPM();
                }

                if (effectiveBPM > 0) {
                    const beatInterval = 60 / effectiveBPM;
                    const tolerance = beatInterval * 0.2; 
                    if (isSpectralBeat && currentTime > lastBpmAlignedBeatTime + beatInterval - tolerance) {
                        triggerBeatEffect();
                        lastBpmAlignedBeatTime = currentTime;
                    }
                }
            }
            
            if (canvas.width !== canvas.clientWidth) canvas.width = canvas.clientWidth;
            if (canvas.height !== canvas.clientHeight) canvas.height = canvas.clientHeight;
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
            
            const gap = 2;
            const barWidth = (canvas.width - (numBars - 1) * gap) / numBars;
            const style = getComputedStyle(document.body);
            const textColor = style.getPropertyValue('--text-color').trim() || '#FFFFFF';
            canvasCtx.fillStyle = textColor;

            const indicesToUse = isMobile ? mobileBarIndices : desktopBarIndices;

            for (let i = 0; i < numBars; i++) {
                const x = i * (barWidth + gap);
                const value = Math.min(dataArray[indicesToUse[i]] * sensitivityMultipliers[i], 255);
                const barHeight = Math.pow(value / 255, powerCurve) * canvas.height;
                
                const pillRadius = Math.max(0, barWidth / 2);
                if (barHeight < pillRadius * 2) {
                    const dotRadius = barHeight / 2;
                    if (dotRadius < 1) continue;
                    canvasCtx.globalAlpha = barHeight / (pillRadius * 2);
                    canvasCtx.beginPath();
                    canvasCtx.arc(x + pillRadius, canvas.height / 2, dotRadius, 0, 2 * Math.PI);
                    canvasCtx.fill();
                } else {
                    const y = (canvas.height - barHeight) / 2;
                    canvasCtx.globalAlpha = 1.0;
                    canvasCtx.beginPath();
                    if (canvasCtx.roundRect) {
                        canvasCtx.roundRect(x, y, barWidth, barHeight, pillRadius);
                    } else { // Fallback
                        canvasCtx.rect(x, y, barWidth, barHeight);
                    }
                    canvasCtx.fill();
                }
            }
            canvasCtx.globalAlpha = 1.0;
        }

        isVisualizerInitialized = true;

    } catch(e) {
        console.error("Failed to initialize AudioContext/Visualizer:", e);
    }
}

function processAndSortSongs() {
    const songsByAlbum = songs.reduce((acc, song) => {
        const albumArtistKey = song.albumArtist || 'Unknown Artist';
        const albumKey = `${albumArtistKey}::${song.album || 'Unknown Album'}`;
        if (!acc[albumKey]) acc[albumKey] = [];
        acc[albumKey].push(song);
        return acc;
    }, {});

    for (const albumKey in songsByAlbum) {
        const albumSongs = songsByAlbum[albumKey];
        albumSongs.sort((a, b) => (a.handleName || a.name).localeCompare(b.handleName || b.name));

        let inferredDisc = 1;
        let lastTrack = 0;
        
        albumSongs.forEach(song => {
            if (song.trackNumber !== null && song.trackNumber < lastTrack) {
                inferredDisc++;
            }
            song.effectiveDiscNumber = song.discNumber || inferredDisc;
            lastTrack = song.trackNumber || 0;
        });
    }
}

async function getArtColors(imageUrl) {
    return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.src = getLowResArtUrl(imageUrl);
        img.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0);
            
            // Get colors from top-left and bottom-right for a simple gradient
            const topLeft = ctx.getImageData(0, 0, 1, 1).data;
            const bottomRight = ctx.getImageData(img.width - 1, img.height - 1, 1, 1).data;

            const color1 = `rgba(${topLeft[0]}, ${topLeft[1]}, ${topLeft[2]}, 0.4)`;
            const color2 = `rgba(${bottomRight[0]}, ${bottomRight[1]}, ${bottomRight[2]}, 0.1)`;
            resolve(`linear-gradient(135deg, ${color1}, ${color2})`);
        };
        img.onerror = () => {
            // Fallback for failed image loads
            resolve('linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0))');
        };
    });
}

async function renderHomePage() {
    const homeView = document.getElementById('home-view');
    if (!homeView) return;

    // --- 1. Fetch all necessary data asynchronously ---
    const topSongsPromise = new Promise(resolve => {
        const tx = db.transaction('songs', 'readonly');
        const index = tx.objectStore('songs').index('playCount');
        const req = index.getAll();
        req.onsuccess = () => resolve(req.result.sort((a,b) => (b.playCount || 0) - (a.playCount || 0)).slice(0, 10));
    });

    const historyPromise = new Promise(resolve => {
        const tx = db.transaction('playHistory', 'readonly');
        const store = tx.objectStore('playHistory');
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result.sort((a,b) => b.timestamp - a.timestamp));
    });

    const [topSongs, history] = await Promise.all([topSongsPromise, historyPromise]);
    // --- 2. Select 6 unique songs for the highlights ---
    
    const highlightSongs = new Set();
    const listenAgainSongs = [];
    if (topSongs.length > 0) {
        listenAgainIndex = (listenAgainIndex + 1) % Math.min(topSongs.length, 10);
        localStorage.setItem('listenAgainIndex', listenAgainIndex);
    
        // Add 6 listen-again songs (or fewer if there aren't enough top songs)
        for (let i = 0; i < 6 && i < topSongs.length; i++) {
            listenAgainSongs.push(topSongs[(listenAgainIndex + i) % topSongs.length]);
        }
    }
    listenAgainSongs.forEach(s => highlightSongs.add(s));

    const recommendations = songs.filter(s => !listenAgainSongs.some(ls => ls.id === s.id));
    for (let i = 0; i < 6 && recommendations.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * recommendations.length);
        highlightSongs.add(recommendations.splice(randomIndex, 1)[0]);
    }
    
    // --- 3. Build the HTML ---
    const highlights = Array.from(highlightSongs);
    const highlightsHtml = highlights.map((song, i) => {
        const isListenAgain = listenAgainSongs.includes(song);
        return `
        <div class="highlight-card" data-id="${song.id}" id="highlight-${i+1}">
            <img src="${song.albumArt}">
            <div class="highlight-card-info">
                <div class="highlight-card-label">${isListenAgain ? 'Listen Again' : 'Quick Picks'}</div>
                <div class="highlight-card-title">${sanitize(song.name)}</div>
            </div>
        </div>`;
    }).join('');

    const recentSongIds = [...new Set(history.map(h => h.songId))];
    const recentlyPlayedSongs = recentSongIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
    const recentAlbums = [];
    const recentAlbumIds = new Set();
    for (const song of recentlyPlayedSongs) {
        const albumId = `${song.albumArtist}::${song.album}`;
        if (!recentAlbumIds.has(albumId)) {
            recentAlbumIds.add(albumId);
            recentAlbums.push(song); // Use the song object as a representative for the album
        }
        if (recentAlbums.length >= 40) break; // Limit to 40 albums
    }
    const recentlyPlayedHtml = recentAlbums.map(song => `
         <div class="item-card" data-album-id="${sanitize(song.albumArtist)}::${sanitize(song.album)}">
            <img src="${song.albumArt}" class="item-card-art">
            <div class="item-card-info">
                <div class="item-card-title">${sanitize(song.album)}</div>
                <div class="item-card-subtitle">${sanitize(song.albumArtist)}</div>
            </div>
        </div>
    `).join('');
    
    const genres = [...new Set(songs.map(s => s.genre).filter(Boolean))];
    const genreSectionsHtml = genres.map(genre => {
        const genreSongs = songs.filter(s => s.genre === genre).slice(0, 8);
        return `
        <div>
            <h2 class="section-title">${sanitize(genre)}</h2>
            <div class="item-grid">${genreSongs.map(song => `
                <div class="item-card" data-album-id="${sanitize(song.albumArtist)}::${sanitize(song.album)}">
                    <img src="${song.albumArt}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(song.album)}</div>
                        <div class="item-card-subtitle">${sanitize(song.albumArtist)}</div>
                    </div>
                </div>
            `).join('')}</div> 
        </div>`;
    }).join('');

    homeView.innerHTML = `
    <div class="page-content-wrapper">
        <h1 style="margin-bottom: 20px;">Home</h1>
        <div class="highlight-grid">${highlightsHtml}</div>
        <div>
            <h2 class="section-title">Recently Played</h2>
            <div class="item-grid">${recentlyPlayedHtml}</div>
        </div>
        ${genreSectionsHtml}
    </div>`;
    
    // --- 4. Asynchronously Apply Gradients ---
    highlights.forEach((song, i) => {
        const card = document.getElementById(`highlight-${i+1}`);
        if (card) {
            if (song.vibrantColor) {
                const color = song.vibrantColor;
                card.style.background = `linear-gradient(135deg, ${color}BF, ${color}33)`;
            } else {
                 getArtColors(song.albumArt).then(gradient => { card.style.background = gradient; });
            }
        }
    });

    requestAnimationFrame(() => {
        const homeView = document.getElementById('home-view');
        homeView.scrollTop = scrollPositions.home;
    });
}

function renderLibraryPage() {
    const libraryView = document.getElementById('library-view');
    const libraryGrid = document.getElementById('library-grid');
    if (!libraryGrid) return;

    // --- RENDER MAIN LIBRARY VIEW ---
    const searchFilteredSongs = songs; // No search bar here anymore

    if (searchFilteredSongs.length === 0) {
        libraryGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><span class="material-symbols-rounded">library_music</span><p>You have nothing owned.</p><p style="font-size: 0.8em; color: var(--secondary-text-color);">Enable Streaming, then open Discover to start saving songs.</p></div>`;
        return;
    }
    
    let itemsHtml = ''; // Declare itemsHtml here

    switch (currentFilter) {
        case 'artists':
            libraryGrid.className = 'item-grid';
            const artistsMap = new Map();
            searchFilteredSongs.forEach(song => {
                const artist = song.artist || 'Unknown Artist';
                if (!artistsMap.has(artist)) {
                    artistsMap.set(artist, song.albumArt);
                }
            });
            let artistsList = Array.from(artistsMap.entries());
            if (currentSortMode === 'alpha') artistsList.sort((a, b) => a[0].localeCompare(b[0]));
            
            itemsHtml = artistsList.map(([artist, art]) => `
                <div class="item-card" data-artist-name="${artist}">
                    <img src="${art || generateRandomGradient()}" alt="${artist}" class="item-card-art" style="border-radius: 50%; corner-shape: round;">
                    <div class="item-card-info" style="text-align: center;">
                        <div class="item-card-title">${sanitize(artist)}</div>
                    </div>
                </div>`).join('');
            break;
        
        case 'songs':
            libraryGrid.className = 'item-list'; // Enforce list view
            const sortedSongs = [...searchFilteredSongs]; // Create a copy to sort
             if (currentSortMode === 'alpha') searchFilteredSongs.sort((a,b) => a.name.localeCompare(b.name));
             else searchFilteredSongs.sort((a,b) => b.dateAdded - a.dateAdded);

            itemsHtml = searchFilteredSongs.map(song => `
                <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
                     <div class="song-info">
                        <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; scale: 1.2; border-radius: 8px; margin-right: 10px;">
                        <div>
                            <div class="song-title" style="white-space: normal;">${sanitize(song.name)}${getExplicitBadge(song.explicit)}</div>
                            <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                        </div>
                    </div>
                </div>
            `).join('');
            break;

        case 'playlists':
            libraryGrid.className = 'item-grid';
            
            // Generate the HTML for the user's existing playlists first
            itemsHtml = playlists.map(p => {
                const playlistSongs = p.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
                const arts = playlistSongs.map(s => s.albumArt);
                return `
                <div class="item-card" data-playlist-id="${p.id}">
                    ${getPlaylistArtPlaceholder(arts)}
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(p.name)}</div>
                        <div class="item-card-subtitle">${playlistSongs.length} songs</div>
                    </div>
                </div>`;
            }).join('');
            break;

        case 'albums':
        default:
            libraryGrid.className = 'item-grid'; // Enforce grid view
            const albums = groupSongsByAlbum(searchFilteredSongs);
            itemsHtml = albums.map(album => {
                const albumId = `${album.artist}::${album.originalAlbum}`;
                return `
                <div class="item-card" data-album-id="${albumId}">
                    <img src="${album.albumArt}" alt="${album.name}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(album.name)}</div>
                        <div class="item-card-subtitle">${sanitize(album.artist)}</div>
                    </div>
                </div>`;
            }).join('');
            break;
    }
    
    libraryGrid.innerHTML = itemsHtml;
    
    // --- SCROLL RESTORATION LOGIC ---
    requestAnimationFrame(() => {
        const libraryView = document.getElementById('library-view');
        libraryView.scrollTop = scrollPositions.library;
    });
}
        
function renderPlaylists() {
    const musicListContainer = document.querySelector('.music-list');
    musicListContainer.innerHTML = ''; 

    if (playlists.length === 0) {
        musicListContainer.innerHTML = '<div class="no-results"><span class="material-symbols-rounded">playlist_add</span><p>No playlists to add to</p><p style="font-size: 0.8em; color: var(--secondary-text-color);">Create one from the "More Options" menu while a song is playing.</p></div>';
        return;
    }

    playlists.forEach(playlist => {
        const playlistSongs = playlist.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
        const arts = playlistSongs.map(s => s.albumArt);
        
        const item = document.createElement('div');
        item.className = 'music-item';
        item.style.position = 'relative'; 
        item.innerHTML = `
            <div class="song-info">
                ${getPlaylistArtPlaceholder(arts, "album-thumbnail")}
                <div style="padding-left: 5px;">
                    <div class="song-title" style="font-size: 1em; margin-bottom: 2px; white-space: normal;">${playlist.name}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${playlistSongs.length} songs</div>
                </div>
            </div>
            <button class="remove-from-queue-btn" onclick="deletePlaylist(${playlist.id}, event)" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%);">
                <span class="material-symbols-rounded" style="font-size: 14px;">cancel</span>
            </button>`;
        
        item.addEventListener('click', (e) => {
            if (e.target.closest('button')) return; 
            renderPlaylistSongs(playlist.id);
        });

        musicListContainer.appendChild(item);
    });
}

function renderPlaylistSongs(playlistId) {
    activePlaylistId = playlistId;
    const playlist = playlists.find(p => p.id === playlistId);
    if (!playlist) return;

    const musicListContainer = document.querySelector('.music-list');
    musicListContainer.innerHTML = '';

    const playlistSongs = playlist.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);

    if (playlistSongs.length === 0) {
        musicListContainer.insertAdjacentHTML('beforeend', '<div class="no-results"><p>This playlist is empty.</p></div>');
        return;
    }

    const songsHtml = playlistSongs.map(song => `
        <div class="music-item ${song.id === currentSongId ? "active" : ""}" data-id="${song.id}">
            <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; scale: 1.2; border-radius: 8px; margin-right: 10px;">
                <div>
                    <div class="song-title" style="font-size: 1em; margin-bottom: 2px; white-space: normal;">${song.name}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                </div>
                <button class="remove-from-queue-btn" onclick="removeSongFromPlaylist(${song.id}, ${playlist.id}, event)" style="margin-left: auto;">
                    <span class="material-symbols-rounded" style="font-size: 14px;">cancel</span>
                </button>
            </div>
        </div>
    `).join('');

    musicListContainer.insertAdjacentHTML('beforeend', songsHtml);
    
    musicListContainer.querySelectorAll('.music-item').forEach(item => {
        item.addEventListener('click', (e) => {
            if (e.target.closest('button')) return;
            const songId = parseFloat(item.dataset.id);
            const songToPlay = songs.find(s => s.id === songId);
            if (songToPlay) playSong(songToPlay);
        });
    });
}
        
async function deletePlaylist(playlistId) {
    const playlist = playlists.find(p => p.id === playlistId);
    if (!playlist) return;

    if (await showConfirmDialog(`Are you sure you want to permanently delete the playlist "${playlist.name}"?`)) {
        // 1. Remove the playlist from the in-memory array.
        playlists = playlists.filter(p => p.id !== playlistId);

        // 2. Remove the playlist from the IndexedDB database.
        const tx = db.transaction('playlists', 'readwrite');
        tx.objectStore('playlists').delete(playlistId);
        await tx.done;

        triggerAutoSync();

        // 3. Close the drawer, as its content is now invalid.
        closeDrawer();

        // 4. Notify the user and refresh the library view.
        showToast(`Playlist "${playlist.name}" deleted`);
        if (activeView === 'library') {
            renderLibraryPage(); 
        }
    }
}

async function removeSongFromPlaylist(songId, playlistId, event) {
    event.stopPropagation();
    const playlist = playlists.find(p => p.id === playlistId);
    const song = songs.find(s => s.id === songId);
    if (!playlist || !song) return;

    // Prompt if NOT in edit mode
    if (!isPlaylistEditMode) {
        const confirm = await showConfirmDialog(`Remove "${song.name}" from this playlist?`);
        if (!confirm) return;
    }

    // Find index to remove only one instance if duplicates exist, or all? 
    // Usually playlists allow duplicates, but simple filter removes all instances of ID.
    // For now, removing by ID is standard.
    playlist.songIds = playlist.songIds.filter(id => id !== songId);

    const tx = db.transaction('playlists', 'readwrite');
    tx.objectStore('playlists').put(playlist);
    await tx.done;

    triggerAutoSync();
    
    if (isPlaylistEditMode) {
        // In edit mode, remove element directly to keep position context for others
        const item = event.target.closest('.music-item');
        if(item) item.remove();
        // Update DB is already done, but if we dragged things around, the DOM order matters.
        // If we just clicked remove, filtering songIds is fine.
    } else {
        // In view mode, refresh to keep consistent
        // If we are in the drawer (normal library usage), we might need to refresh drawer content manually
        // But since this function is usually called from the drawer context:
        const drawerContent = document.getElementById('drawer-content');
        if (drawerContent && document.getElementById('drawer').classList.contains('open')) {
             // Re-render only if we aren't in edit mode (to avoid resetting scroll/focus)
             // However, openDrawer call is complex to reconstruct here.
             // Simplest approach: remove the row from DOM.
             const item = event.target.closest('.music-item');
             if(item) item.remove();
             
             // If we were viewing the dedicated Playlist View (not drawer), handle that?
             // Currently playlists are only fully viewable in Drawer.
        }
    }
    
    showToast(`Removed "${song.name}"`);
}

function togglePlaylistEditMode(playlistId) {
    isPlaylistEditMode = !isPlaylistEditMode;
    
    const container = document.getElementById('playlist-items-container');
    const editBtn = document.getElementById('drawer-edit-playlist-btn');
    
    if (isPlaylistEditMode) {
        container.classList.add('edit-mode');
        if(editBtn) {
            editBtn.style.backgroundColor = 'var(--accent)';
            editBtn.style.color = 'var(--background-color)';
            editBtn.innerHTML = '<span class="material-symbols-rounded" style="font-size:16px;">check</span> Done';
        }
        makePlaylistItemsDraggable(container, playlistId);
    } else {
        container.classList.remove('edit-mode');
        if(editBtn) {
            editBtn.style.backgroundColor = 'var(--search-background)';
            editBtn.style.color = 'var(--text-color)';
            editBtn.innerHTML = 'Edit';
        }
        // Cleanup drag listeners is handled by logic inside draggable function or simply ignored when not dragging
    }
}

function makePlaylistItemsDraggable(container, playlistId) {
    let draggedItem = null;
    let touchTimeout;
    let isTouchDragging = false;
    let touchGhost = null;
    let touchStartY = 0;

    const items = container.querySelectorAll('.playlist-item');

    items.forEach(item => {
        // Desktop
        item.setAttribute('draggable', 'true');
        
        item.addEventListener('dragstart', (e) => {
            if (!isPlaylistEditMode) { e.preventDefault(); return; }
            draggedItem = item;
            setTimeout(() => item.classList.add('dragging'), 0);
        });

        item.addEventListener('dragend', () => {
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
                draggedItem = null;
                updatePlaylistOrder(container, playlistId);
            }
        });

        // Mobile Touch (Handle Only)
        const handle = item.querySelector('.playlist-drag-handle');
        if (handle) {
            handle.addEventListener('touchstart', (e) => {
                if (!isPlaylistEditMode) return;
                e.preventDefault(); // Prevent scroll
                touchStartY = e.touches[0].clientY;
                isTouchDragging = true;
                item.classList.add('dragging');
                
                if (navigator.vibrate) navigator.vibrate(50);

                touchGhost = item.cloneNode(true);
                touchGhost.style.position = 'fixed';
                touchGhost.style.zIndex = '9999';
                touchGhost.style.pointerEvents = 'none';
                touchGhost.style.opacity = '0.9';
                touchGhost.style.width = `${item.offsetWidth}px`;
                touchGhost.style.background = 'var(--modal-background)';
                touchGhost.classList.add('edit-mode'); // Keep styling
                
                const rect = item.getBoundingClientRect();
                touchGhost.style.top = `${rect.top}px`;
                touchGhost.style.left = `${rect.left}px`;
                document.body.appendChild(touchGhost);
            }, { passive: false });

            handle.addEventListener('touchmove', (e) => {
                if (!isTouchDragging) return;
                e.preventDefault();
                const touch = e.touches[0];

                if (touchGhost) {
                    touchGhost.style.top = `${touch.clientY - (touchGhost.offsetHeight / 2)}px`;
                    touchGhost.style.left = `${touch.clientX - (touchGhost.offsetWidth / 2)}px`;
                }

                const afterElement = getDragAfterElement(container, touch.clientY);
                if (afterElement == null) {
                    container.appendChild(item);
                } else {
                    container.insertBefore(item, afterElement);
                }
            }, { passive: false });

            const endDrag = () => {
                if (isTouchDragging) {
                    isTouchDragging = false;
                    item.classList.remove('dragging');
                    if (touchGhost) { touchGhost.remove(); touchGhost = null; }
                    updatePlaylistOrder(container, playlistId);
                }
            };
            handle.addEventListener('touchend', endDrag);
            handle.addEventListener('touchcancel', endDrag);
        }
    });

    container.addEventListener('dragover', e => {
        if (!isPlaylistEditMode) return;
        e.preventDefault();
        const afterElement = getDragAfterElement(container, e.clientY);
        if (afterElement == null) {
            container.appendChild(draggedItem);
        } else {
            container.insertBefore(draggedItem, afterElement);
        }
    });
}

async function updatePlaylistOrder(container, playlistId) {
    const playlist = playlists.find(p => p.id === playlistId);
    if (!playlist) return;

    const newSongIds = [];
    container.querySelectorAll('.playlist-item').forEach(item => {
        const id = parseFloat(item.dataset.id);
        if (!isNaN(id)) newSongIds.push(id);
    });

    playlist.songIds = newSongIds;
    
    // Save to DB
    const tx = db.transaction('playlists', 'readwrite');
    tx.objectStore('playlists').put(playlist);
    await tx.done;
    triggerAutoSync();
}
        
function renderSongs(albums, isArtistView = false) {
  const musicListContainer = document.querySelector('.music-list');
  
  if (!albums || albums.length === 0) {
    musicListContainer.innerHTML = '<div class="no-results"><span class="material-symbols-rounded">search_off</span><p>No songs found</p></div>';
    return;
  }
  
  musicListContainer.innerHTML = albums.map(album => `
    <div class="album-section" 
         data-album-artist="${album.artist}" 
         data-album-name="${album.originalAlbum}">
      <div class="album-header">
        <img src="${album.albumArt}" alt="${album.name}" class="album-thumbnail">
        <div class="album-info">
          <div class="album-name">${album.name}</div>
          ${isArtistView ? '' : `<div class="album-artist">${album.artist}</div>`}
          <div class="album-year">${album.year}</div>
        </div>
      </div>
      <div class="album-songs">
        ${album.songs.map(song => `
          <div class="music-item ${song.id === currentSongId ? "active" : ""}" data-id="${song.id}">
            <div class="song-info">
              <span class="track-number">${song.trackNumber ? song.trackNumber + "." : ""}</span>
              <span class="song-title">${song.name}</span>
            </div>
          </div>
        `).join("")}
      </div>
    </div>
  `).join("");
  
  attachSongAndAlbumEventListeners();
}

function renderSongsAsList(songsToRender) {
    const musicListContainer = document.querySelector('.music-list');
    musicListContainer.innerHTML = songsToRender.map(song => `
        <div class="music-item ${song.id === currentSongId ? "active" : ""}" data-id="${song.id}">
            <div class="song-info">
                <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 5px;">
                <div>
                    <div class="song-title" style="font-size: 1em; margin-bottom: 2px;">${song.name}</div>
                    <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                </div>
            </div>
        </div>
    `).join('');
    attachSongAndAlbumEventListeners();
}
        
async function renderLyrics() {
    const lyricsQueuePanel = document.getElementById('lyrics-queue-panel');
    if (!lyricsQueuePanel) return;

    const lyricsContainer = lyricsQueuePanel.querySelector('.lyrics-container') || 
                            (() => {
                                lyricsQueuePanel.innerHTML = `<div class="lyrics-container" id="lyrics-scroll-container"></div>`;
                                return lyricsQueuePanel.querySelector('.lyrics-container');
                            })();

    if (!currentSongId) {
        lyricsContainer.innerHTML = `<p style="opacity: 1; filter: none;">No song is currently playing.</p>`;
        return;
    }
    
    const songIdForThisRender = currentSongId;
    const song = currentlyPlayingSong;

    if (song.lyrics) {
        if (song.lrcData && song.lrcData.lyrics && song.lrcData.lyrics.length > 0) {
            let lineIndex = 0; 
            const lyricsHtml = song.lrcData.lyrics.map(item => {
                switch(item.type) {
                    case 'line':
                        return `<p id="lyric-line-${lineIndex++}" data-time="${item.time}">${item.text || '  '}</p>`;
                    case 'aside':
                        return `<p class="lyric-aside" data-time="${item.time}">${item.text}</p>`;
                    default:
                        return '';
                }
            }).join('');
            
            lyricsContainer.innerHTML = lyricsHtml;

            lyricsContainer.querySelectorAll('p:not(.lyric-aside)').forEach(lineEl => {
                lineEl.addEventListener('click', () => {
                    const seekTime = parseFloat(lineEl.dataset.time);
                    if (!isNaN(seekTime)) audioPlayer.currentTime = seekTime;
                });
            });

            lyricsContainer.addEventListener('scroll', () => {
                if (isProgrammaticScroll) return;
                isUserScrollingLyrics = true;
                clearTimeout(lyricsScrollTimeout);
                lyricsContainer.querySelectorAll('p').forEach(p => {
                    p.style.filter = 'none';
                    p.style.opacity = 1;
                });
                lyricsScrollTimeout = setTimeout(() => {
                    isUserScrollingLyrics = false;
                    lastActiveIndex = -1;
                }, 250);
            });

        } else {
            lyricsContainer.innerHTML = `<p style="opacity: 1; filter: none; white-space: pre-wrap;">${song.lyrics}</p>`;
        }
        return;
    }

    // Use istidalEnabled as the toggle for the new API
    if (istidalEnabled || isLrclibEnabled) {
        lyricsContainer.innerHTML = `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`;
        const fetchedLyrics = await fetchLyrics(song);

        if (songIdForThisRender !== currentSongId) return;

        if (fetchedLyrics) {
            song.lyrics = fetchedLyrics.content;
            if (fetchedLyrics.type === 'lrc') song.lrcData = parseLRC(fetchedLyrics.content);
            
            if (song.storage === 'tidal') await updatetidalCacheWithLyrics(song);
            else await saveSongs();
            
            renderLyrics();
        } else {
             lyricsContainer.innerHTML = `
                <div class="no-results">
                    <p>No lyrics found automatically.</p>
                    ${song.storage !== 'tidal' ? '<button id="manual-search-trigger" class="goto-btn">Search Manually</button>' : ''}
                </div>`;
            if (document.getElementById('manual-search-trigger')) {
                document.getElementById('manual-search-trigger').addEventListener('click', () => {
                    const cleaned = cleanMetadataForLyricsSearch(song);
                    document.getElementById('manualLyricsSearchInput').value = `${cleaned.artist} - ${cleaned.name}`;
                    document.getElementById('manualLyricsResults').innerHTML = '';
                    openModal(manualLyricsSearchModal);
                });
            }
        }
        return;
    }

    lyricsContainer.innerHTML = `<p style="opacity: 1; filter: none;">No lyrics found.</p>`;
}

function setupBpm(song) {
    songBPM = song.bpm || null;
    lastBpmAlignedBeatTime = 0;
    if (tempoEstimator) tempoEstimator.reset();
}

async function fetchLyricsFromLrclib(song) {
    if (!song) return null;

    // Use the cleaned metadata for the API call
    const cleanedSong = cleanMetadataForLyricsSearch(song);
    const artist = encodeURIComponent(cleanedSong.artist);
    const track = encodeURIComponent(cleanedSong.name);

    // Start building the URL with the required parameters
    let url = `https://lrclib.net/api/get?artist_name=${artist}&track_name=${track}`;

    // --- THE FIX ---
    // Only add the album_name parameter if it's NOT a tidal song
    // and if an album name actually exists.
    if (song.storage !== 'tidal' && cleanedSong.album) {
        const album = encodeURIComponent(cleanedSong.album);
        url += `&album_name=${album}`;
    }

    try {
        const response = await fetch(url);
        if (!response.ok) {
            console.warn(`LRCLIB request failed with status: ${response.status}`);
            return null;
        }
        
        const data = await response.json();
        if (Object.keys(data).length === 0 || (!data.plainLyrics && !data.syncedLyrics)) {
            return null;
        }

        if (data.syncedLyrics) {
            return { type: 'lrc', content: data.syncedLyrics };
        } else if (data.plainLyrics) {
            return { type: 'plain', content: data.plainLyrics };
        }

    } catch (error) {
        console.error("Error fetching lyrics from LRCLIB:", error);
    }
    return null;
}

// This function cleans metadata before any LRCLIB search
function cleanMetadataForLyricsSearch(song) {
    let cleanTitle = song.name || '';
    let cleanArtist = song.artist || '';

    // Remove common patterns like (feat...), (prod...), [Official Video], etc.
    const patternsToRemove = [
        /\s*\(feat\..*?\)/i,
        /\s*\(prod\..*?\)/i,
        /\s*\[.*?\]/g,
        /\s*\(.*?(official|lyric|audio|video|visualizer).*?\)/i,
        /\s-\s(official|lyric|audio|video|visualizer).*/i,
        /MV/g
    ];

    patternsToRemove.forEach(pattern => {
        cleanTitle = cleanTitle.replace(pattern, '').trim();
    });

    return { name: cleanTitle, artist: cleanArtist, album: song.album };
}

// New function to handle the manual search API call
async function searchLrclibForManualPick() {
    const query = document.getElementById('manualLyricsSearchInput').value;
    const resultsContainer = document.getElementById('manualLyricsResults');
    if (!query) return;

    resultsContainer.innerHTML = `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`;
    const url = `https://lrclib.net/api/search?q=${encodeURIComponent(query)}`;

    try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('API Search failed');
        
        // Store results in our global variable
        lastLrclibSearchResults = await response.json();

        if (lastLrclibSearchResults.length === 0) {
            resultsContainer.innerHTML = '<p>No results found.</p>';
            return;
        }

        resultsContainer.innerHTML = lastLrclibSearchResults.map(track => `
            <div class="menu-item" data-id="${track.id}" style="cursor: pointer;">
                <div>
                    <div>${sanitize(track.trackName)}</div>
                    <div style="font-size: 0.8em; color: var(--secondary-text-color);">${sanitize(track.artistName)}</div>
                </div>
            </div>
        `).join('');

        // Add click listeners to each new result item
        resultsContainer.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', async () => {
                const trackId = parseInt(item.dataset.id, 10);
                const selectedTrack = lastLrclibSearchResults.find(t => t.id === trackId);
                
                if (!selectedTrack) return; // Safety check

                const song = currentlyPlayingSong;
                if (!song) return;

                // Apply lyrics directly from the selected search result
                if (selectedTrack.syncedLyrics) {
                    song.lyrics = selectedTrack.syncedLyrics;
                    song.lrcData = parseLRC(selectedTrack.syncedLyrics);
                } else if (selectedTrack.plainLyrics) {
                    song.lyrics = selectedTrack.plainLyrics;
                    song.lrcData = null;
                } else {
                    showToast("Selected track has no lyrics");
                    return;
                }

                // Save the newly found lyrics
                if (song.storage === 'tidal') {
                    await updatetidalCacheWithLyrics(song);
                } else {
                    await saveSongs();
                }
                
                // Close modal and re-render the lyrics panel
                closeModal(manualLyricsSearchModal);
                await renderLyrics();
            });
        });

    } catch (error) {
        resultsContainer.innerHTML = `<p>Error during search.</p>`;
        console.error("Manual LRCLIB search error:", error);
    }
}
    
async function renderOfflinetidalView() {
    const resultsGrid = document.getElementById('tidal-results-grid');
    const query = document.getElementById('tidalOfflineSearchInput').value.toLowerCase();
    resultsGrid.innerHTML = '';
    
    try {
        const tx = db.transaction('tidalCache', 'readonly');
        const store = tx.objectStore('tidalCache');
        const allCachedItems = await promiseIDBRequest(store.getAll());

        let filteredItems = allCachedItems;
        if (query) {
            filteredItems = allCachedItems.filter(item => 
                item.metadata.name.toLowerCase().includes(query) ||
                item.metadata.artist.toLowerCase().includes(query)
            );
        }
        
        if (filteredItems.length === 0) {
            if (query) {
                // If there was a search query, show a "no results" message.
                resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>No cached songs match "${sanitize(query)}"</p></div>`;
            } else {
                // If there was no query, it means the cache is empty.
                resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>No tidal songs are cached</p></div>`;
            }
            return;
        }
        
        // Sort by most recently played
        filteredItems.sort((a, b) => b.timestamp - a.timestamp);

        const resultsHtml = filteredItems.map(entry => {
            const track = entry.metadata;
            return `
            <div class="music-item" data-cached-id="${track.id}" style="cursor: pointer;">
                 <div class="song-info">
                    <img src="${track.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                    <div>
                        <div class="song-title" style="white-space: normal;">${sanitize(track.name)}</div>
                        <div class="album-artist" style="font-size: 0.8em;">${sanitize(track.artist)}</div>
                    </div>
                </div>
            </div>
            `;
        }).join('');
        resultsGrid.className = 'item-list';
        resultsGrid.innerHTML = resultsHtml;
    } catch (error) {
        console.error('Failed to render offline songs:', error);
        resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>Error loading cached songs.</p></div>`;
    }
}

// This new function will control the view in the "New" tab
async function rendertidalPage() {
    const searchContainer = document.getElementById('tidal-search-container');
    const offlineSearchContainer = document.getElementById('tidal-offline-search-container');
    const filterContainer = document.getElementById('tidal-filter-container'); // Inner container
    const controlsWrapper = document.getElementById('tidal-controls'); // The main wrapper
    const browseContainer = document.getElementById('tidal-browse-container');
    const resultsGrid = document.getElementById('tidal-results-grid');
    const input = document.getElementById('tidalSearchInput');
    
    if (istidalOfflineMode) {
        searchContainer.style.display = 'none';
        offlineSearchContainer.style.display = 'flex';
        // Show controls in offline mode to allow filtering cached songs
        if(controlsWrapper) controlsWrapper.style.display = 'flex';
        if(filterContainer) filterContainer.style.display = 'none'; // Hide specific online filters
        browseContainer.style.display = 'none';
        document.getElementById('tidalOfflineToggle').classList.add('active');
        renderOfflinetidalView();
    } else {
        searchContainer.style.display = 'block';
        offlineSearchContainer.style.display = 'none';
        document.getElementById('tidalOfflineToggle').classList.remove('active');
        document.getElementById('tidalOfflineSearchInput').value = '';
        
        // Logic for Discover Landing vs Search Results
        if (!input.value.trim()) {
            resultsGrid.style.display = 'none';
            browseContainer.style.display = 'block';
            if(controlsWrapper) controlsWrapper.style.display = 'none'; // Hide controls when browsing
            renderDiscoverBrowse();
        } else {
            browseContainer.style.display = 'none';
            resultsGrid.style.display = 'grid';
            if(controlsWrapper) controlsWrapper.style.display = 'flex'; // Show controls when searching
            if(filterContainer) filterContainer.style.display = 'flex';
            rendertidalSearchResults();
        }
    }
}

async function renderDiscoverBrowse() {
    const browseContainer = document.getElementById('tidal-browse-container');
    if (!browseContainer) return;

    // 1. Search History
    let historyContainer = document.getElementById('search-history-container');

    if (searchHistory.length > 0) {
        // Create if missing
        if (!historyContainer) {
            historyContainer = document.createElement('div');
            historyContainer.id = 'search-history-container';
            // FIX: Prepend ensures it is always the FIRST element in the view
            browseContainer.prepend(historyContainer);
        }

        // Update content (Overwrites existing HTML, preventing internal duplication)
        let historyHtml = `<div style="display:flex; gap:10px; margin-bottom: 20px; flex-wrap:wrap; justify-content: center;">`;
        historyHtml += searchHistory.map(term => 
            `<div class="history-pill" onclick="document.getElementById('tidalSearchInput').value='${sanitize(term)}'; document.getElementById('tidalSearchInput').dispatchEvent(new Event('input'));"><span class="material-symbols-rounded" style="font-size:16px">history</span>${sanitize(term)}</div>`
        ).join('');
        historyHtml += `</div>`;
        historyContainer.innerHTML = historyHtml;
    } else if (historyContainer) {
        // Remove container if history is cleared
        historyContainer.remove();
    }
    
    // 3. Trending (Populate browseContext)
    const trendingGrid = document.getElementById('tidal-trending-grid');
    if (trendingGrid && trendingGrid.innerHTML === '') {
        try {
            const playlistId = 'edf3b7d2-cb42-41d7-93c0-afa2a395521b'; 
            const res = await fetchHifi(`/playlist/?id=${playlistId}`);
            const json = await res.json();
            
            const items = json.items || (json.data ? json.data.items : []);
            
            const tracks = items
                .filter(entry => entry.item && entry.type === 'track')
                .map(entry => entry.item)
                .slice(0, 12);

            // ** FIX: Store tracks globally so playtidalTrack can find them **
            browseContext = tracks.map(track => ({
                id: track.id,
                name: track.title,
                artist: track.artist.name,
                album: track.album.title,
                albumArt: getHighResArtwork(track.album.cover),
                storage: 'tidal',
                duration: track.duration,
                audioQuality: track.audioQuality
            }));

            trendingGrid.innerHTML = tracks.map(track => {
                const cover = track.album ? track.album.cover : null;
                return `
                <div class="item-card" onclick="playtidalTrack(${track.id})">
                    <img src="${getHighResArtwork(cover)}" class="item-card-art">
                    <div class="item-card-info">
                        <div class="item-card-title">${sanitize(track.title)}</div>
                        <div class="item-card-subtitle">${sanitize(track.artist.name)}</div>
                    </div>
                </div>
            `}).join('');
        } catch(e) { 
            console.warn("Trending fetch failed:", e); 
            trendingGrid.innerHTML = '<div class="no-results" style="grid-column: 1/-1"><p>Unable to load</p></div>';
        }
    }
}

function searchGenre(genre) {
    const input = document.getElementById('tidalSearchInput');
    input.value = genre;
    input.dispatchEvent(new Event('input')); // Trigger search
}
        
function renderQueue() {
    const lyricsQueuePanel = document.getElementById('lyrics-queue-panel');
    if (!lyricsQueuePanel) return;

    // Create the header with the title and the new autoplay toggle
    const headerHtml = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0; flex-shrink: 0;">
            <h2 class="section-title" style="margin: 0;">Up Next</h2>
            <div style="display: flex; align-items: center; gap: 10px;">
                <label for="autoplayToggle" style="font-size: 14px; color: var(--secondary-text-color);">Autoplay</label>
                <input type="checkbox" id="autoplayToggle" ${isAutoplayEnabled ? 'checked' : ''}>
            </div>
        </div>
    `;

    const lockedClass = isRadioMode ? 'radio-locked' : '';
    
    if (playQueue.length === 0) {
        lyricsQueuePanel.innerHTML = headerHtml + `
            <div class="now-queue">
                <div class="no-results" style="flex-grow: 1; justify-content: center;">
                    <span class="material-symbols-rounded">format_list_bulleted</span>
                    <p>The queue is empty.</p>
                </div>
            </div>
        `;
    } else {
        const queueHtml = playQueue.map((song, index) => `
            <div class="music-item queue-item ${song.id === currentSongId ? "active" : ""}" data-queue-index="${index}" data-id="${song.id}">
                <div class="song-info">
                    <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 6px; margin: 0 5px;">
                    <div class="song-title">${sanitize(song.name)}${getExplicitBadge(song.explicit)}</div>
                    <span class="song-artist-queue">${song.artist}</span>
                    <button class="remove-from-queue-btn" data-queue-index="${index}">
                        <span class="material-symbols-rounded" style="font-size: 14px;">cancel</span>
                    </button>
                </div>
            </div>
        `).join('');
        
        // Add Save Button at bottom
        lyricsQueuePanel.innerHTML = `<div class="now-queue">
            ${headerHtml}
            <div class="queue-list-container" style="margin-top: 10px;">${queueHtml}</div>
            ${playQueue.length > 0 ? `
            <div style="padding: 15px 0; text-align: center;">
                <button id="saveQueueBtn" class="action-btn" style="width: 100%; justify-content: center;">
                    <span class="material-symbols-rounded" style="margin-right: 5px;">playlist_add</span>Save
                </button>
            </div>` : ''}
        </div>`;
    }
    

    // Attach event listener for the new toggle switch and save button
    const autoplayToggle = document.getElementById('autoplayToggle');
    if (autoplayToggle) {
        autoplayToggle.addEventListener('change', toggleAutoplay);
    }
    const saveQBtn = document.getElementById('saveQueueBtn');
    if (saveQBtn) {
        saveQBtn.onclick = saveQueueAsPlaylist;
    }

    // Disable drag if radio
    if (!isRadioMode) makeQueueItemsDraggable();
    addQueueItemEventListeners();
}

function scrollToCurrentSongInQueue() {
    // Use a small timeout to ensure the DOM has updated
    setTimeout(() => {
        const activeSongEl = document.querySelector('#lyrics-queue-panel .queue-item.active');
        if (activeSongEl) {
            activeSongEl.scrollIntoView({
                behavior: 'smooth',
                block: 'center'
            });
        }
    }, 100);
}

function attachSongAndAlbumEventListeners() {
  document.querySelectorAll('.song-actions').forEach(button => {
      button.addEventListener('click', (e) => {
          const songId = parseFloat(button.dataset.id);
          openSongContextMenu(e, songId);
      });
  });
}

function rebuildQueueFromCurrentView() {
    const newQueue = [];
    let songItems;

    // Determine where to source the song list from based on the active view
    if (activeView === 'library') {
        songItems = document.querySelectorAll('#library-grid .item-card[data-album-id]');
    } else if (activeView === 'search') {
        // We will add search logic later, for now, it can be empty
        songItems = document.querySelectorAll('#search-view .item-card');
    } else {
        // Default or Home view, we can source from the entire song list for now
        playQueue = [...songs]; // Fallback to all songs
        console.log(`Queue rebuilt from all songs. ${playQueue.length} songs.`);
        isQueueUserModified = false;
        return;
    }

    if (songItems.length > 0) {
        // This part needs to be adapted based on what each view renders.
        // For the library's album view:
        if (activeView === 'library' && currentFilter === 'albums') {
            const albumSongs = [];
            songItems.forEach(card => {
                const [artist, albumName] = card.dataset.albumId.split('::');
                const songsFromAlbum = songs.filter(s => s.albumArtist === artist && s.album === albumName);
                albumSongs.push(...songsFromAlbum);
            });
            // Remove duplicates in case albums are shown multiple times
            const uniqueIds = new Set();
            playQueue = albumSongs.filter(song => {
                const isDuplicate = uniqueIds.has(song.id);
                uniqueIds.add(song.id);
                return !isDuplicate;
            });

        } else {
             // Fallback for other potential views (like song list view later)
             songItems.forEach(item => {
                const songId = parseFloat(item.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song && !newQueue.some(s => s.id === song.id)) {
                    newQueue.push(song);
                }
            });
            playQueue = newQueue;
        }

    } else {
        // If the view is empty, just use the full song list
        playQueue = [...songs];
    }
    
    console.log(`Queue rebuilt from ${activeView} view. ${playQueue.length} songs.`);
    isQueueUserModified = false; 
}
        
function addToQueue(songId, position = 'last') {
    isQueueUserModified = true; // Flag that the user is now manually curating the queue
    
    // FIX: Find song from multiple possible sources
    let song = songs.find(s => s.id === songId);
    if (!song && lasttidalSearchResults.length > 0) { // If not in local library, check tidal results
         const track = lasttidalSearchResults.find(t => t.id === songId);
         if (track) {
            song = {
                id: track.id,
                name: track.title,
                artist: track.user.username,
                album: 'tidal',
                albumArt: getHighResArtwork(track.artwork_url),
                storage: 'tidal'
            };
         }
    }

    if (!song) {
        console.error("Could not find song to add to queue with ID:", songId);
        return;
    }

    if (playQueue.length === 0) {
        rebuildQueueFromCurrentView();
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
    }
    
    if (currentQueueIndex === -1) {
        currentQueueIndex = playQueue.length > 0 ? playQueue.length -1 : 0;
    }
    
    if (position === 'next') {
        playQueue.splice(currentQueueIndex + 1, 0, song);
    } else { 
        playQueue.push(song);
    }

    showToast(`Added "${sanitize(song.name)}" to queue`);
    
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
}

async function toggleAutoplay(event) {
    isAutoplayEnabled = event.target.checked;
    if (isAutoplayEnabled) {
        await generateAutoplaySongs();
    } else {
        removeAutoplaySongs();
    }
}

function removeAutoplaySongs() {
    if (autoplaySongIds.size === 0) return;

    playQueue = playQueue.filter(song => !autoplaySongIds.has(song.id));
    autoplaySongIds.clear();
    
    // After removing songs, the current index might be wrong. Let's fix it.
    currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);

    renderQueue();
}

async function saveQueueAsPlaylist() {
    if (playQueue.length === 0) return showToast("Queue is empty");
    
    // Simple prompt for now
    const name = prompt("Enter new playlist name:");
    if (name && name.trim()) {
        const newPlaylist = { name: name.trim(), songIds: playQueue.map(s => s.id) };
        
        try {
            const tx = db.transaction('playlists', 'readwrite');
            const request = tx.objectStore('playlists').add(newPlaylist);
            await new Promise((resolve, reject) => {
                tx.oncomplete = () => {
                    newPlaylist.id = request.result;
                    resolve();
                };
                tx.onerror = () => reject(tx.error);
            });
            
            playlists.push(newPlaylist);
            triggerAutoSync();
            showToast(`Saved playlist "${name}"`);
            if (activeView === 'library') renderLibraryPage();
        } catch (e) {
            console.error(e);
            showToast("Failed to save playlist");
        }
    }
}

function setPlayerLoadingState(isLoading, song = null) {
    const loadingSVG = `<svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg>`;
    const playIconText = 'play_arrow';
    const pauseIconText = 'pause';

    if (isLoading) {
        if (song) {
            updatePlayerUI(song);
            updateMiniplayerUI(song, 'loading');
            
            // ** NEW: Immediately update external sessions **
            updateMediaSessionMetadata(song); // Trigger async metadata update
            
            // Register session immediately so keys work while loading
            let artworkSrc = song.albumArt;
            // Quick check for high-res URL to use as placeholder
            if(artworkSrc && artworkSrc.includes('resources.tidal.com')) {
               artworkSrc = artworkSrc.replace(/\/\d+x\d+\.jpg$/, '/320x320.jpg');
            }
        }
        playPauseIcon.innerHTML = loadingSVG;
        const miniplayerPlayBtn = document.getElementById('miniplayer-play-btn');
        if(miniplayerPlayBtn) miniplayerPlayBtn.innerHTML = loadingSVG;
    } else {
        const state = audioPlayer.paused ? 'paused' : 'playing';
        updateMiniplayerUI(currentlyPlayingSong, state);
        playPauseIcon.innerHTML = '';
        playPauseIcon.textContent = state === 'playing' ? pauseIconText : playIconText;
    }
}

async function generateAutoplaySongs() {
    if (isFetchingQueue) return;
    isFetchingQueue = true;
    toggleQueueLoading(true);

    removeAutoplaySongs(); 

    const lastSong = playQueue.length > 0 ? playQueue[playQueue.length - 1] : (currentlyPlayingSong || null);
    if (!lastSong || !lastSong.artist) {
        isFetchingQueue = false;
        toggleQueueLoading(false);
        return;
    }

    try {
        // Fetch 100 items for better variety
        const response = await fetchHifi(`/search/?s=${encodeURIComponent(lastSong.artist)}&limit=100`);
        const data = await response.json();
        const potentialTracks = (data.data || data).items || [];
        
        // Immediate Shuffle
        shuffleArray(potentialTracks);

        const currentQueueIds = new Set(playQueue.map(s => s.id));
        
        // Map first to get clean objects
        let mappedCandidates = potentialTracks.map(track => ({
            id: track.id,
            name: track.title,
            artist: (track.artist && track.artist.name) ? track.artist.name : track.artist,
            album: (track.album && track.album.title) ? track.album.title : track.album,
            albumArt: getHighResArtwork(track.album ? track.album.cover : null),
            storage: 'tidal',
            duration: track.duration,
            audioQuality: track.audioQuality,
            vibrantColor: track.album ? track.album.vibrantColor : null
        })).filter(t => t.id && !currentQueueIds.has(t.id)); // Filter invalid or current queue

        // Split Fresh vs Repeats
        let fresh = mappedCandidates.filter(t => !sessionPlayedIds.has(t.id));
        let repeats = mappedCandidates.filter(t => sessionPlayedIds.has(t.id));

        let finalSelection = [];
        
        // Prefer fresh, fallback to repeats if needed to fill a buffer of 20
        if (fresh.length >= 20) {
            finalSelection = fresh.slice(0, 20);
        } else {
            // Fill up to 20 with fresh, then repeats
            finalSelection = [...fresh, ...repeats].slice(0, 20);
        }

        // Final shuffle of the selection
        shuffleArray(finalSelection);

        if (finalSelection.length > 0) {
            finalSelection.forEach(song => autoplaySongIds.add(song.id));
            playQueue.push(...finalSelection);
        } 
        
        if (isPanelVisible && panelContent === 'queue') {
            renderQueue();
        }

    } catch (e) {
        console.error("Autoplay generation failed:", e);
    } finally {
        isFetchingQueue = false;
        toggleQueueLoading(false);
    }
}

function formatSongsForAiPrompt(songList) {
    if (!songList || songList.length === 0) return "No songs available.";
    // Provide more context: Title, Artist, Genre, and Source (tidal or Local)
    return songList.map(s => 
        `Title: ${s.name}, Artist: ${s.artist}, Genre: ${s.genre || 'Unknown'}, Source: ${s.storage === 'tidal' ? 'tidal' : 'Local'}`
    ).join('\n');
}

async function generateAiAutoplaySongs() {
    if (!musicAiModel) return [];

    const contextQueue = playQueue.length > 0 ? playQueue : (currentlyPlayingSong ? [currentlyPlayingSong] : []);
    if (contextQueue.length === 0) return [];

    // --- Build Comprehensive Context for AI ---
    let comprehensiveLibrary = [...songs];
    const userQueueSongIds = new Set(playQueue.map(s => s.id));

    // 1. If tidal is enabled, fetch potential recommendations to add to the AI's knowledge base.
    if (istidalEnabled && tidalClientId) {
        const contextArtists = new Set(contextQueue.map(s => s.artist).filter(Boolean));
        const contextGenres = new Set(contextQueue.map(s => s.genre).filter(Boolean));
        const searchTerms = [...new Set([...contextArtists, ...contextGenres])];
        
        const promises = searchTerms.map(term =>
            fetch(proxyUrl(`https://api-v2.tidal.com/search/tracks?q=${encodeURIComponent(term)}&client_id=${tidalClientId}&limit=10`))
                .then(res => res.ok ? res.json() : { collection: [] })
                .catch(() => ({ collection: [] }))
        );
        const results = await Promise.all(promises);
        const scTracks = results.flatMap(data => data.collection).map(track => ({
            id: track.id, name: track.title, artist: track.user.username,
            album: 'tidal', albumArt: getHighResArtwork(track.artwork_url), storage: 'tidal', genre: track.genre
        }));

        // Add tidal tracks to the library if they aren't duplicates of local songs
        scTracks.forEach(scSong => {
            const uniqueKey = `${scSong.artist.toLowerCase().trim()}::${scSong.name.toLowerCase().trim()}`;
            if (!localSongLookup.has(uniqueKey)) {
                comprehensiveLibrary.push(scSong);
            }
        });
    }
    
    return []; // Return empty array on failure
}

function openSongContextMenu(targetElement, songId, isTidalTrack = false) {
    if (!targetElement) return; // Safety check

    const contextMenu = document.getElementById('songContextMenu');
    
    document.getElementById('menuAddToQueueNext').onclick = () => {
        if (isTidalTrack) {
            addTidalTrackToQueue(songId, 'next');
        } else {
            addToQueue(songId, 'next');
        }
        contextMenu.classList.remove('visible');
    };
    document.getElementById('menuAddToQueueLast').onclick = () => {
        if (isTidalTrack) {
            addTidalTrackToQueue(songId, 'last');
        } else {
            addToQueue(songId, 'last');
        }
        contextMenu.classList.remove('visible');
    };

    contextMenu.classList.add('visible'); // Make visible before measuring to get dimensions
    const rect = targetElement.getBoundingClientRect();
    const menuWidth = contextMenu.offsetWidth;
    const menuHeight = contextMenu.offsetHeight;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    let top = rect.bottom + 5;
    let left = rect.left;

    // Adjust for viewport boundaries
    if (left + menuWidth > viewportWidth) {
        left = viewportWidth - menuWidth - 10; // Keep some margin from right edge
    }
    if (left < 10) {
        left = 10; // Keep some margin from left edge
    }
    if (top + menuHeight > viewportHeight) {
        top = rect.top - menuHeight - 5; // If it overflows bottom, open upwards
    }
    if (top < 10) {
        top = 10; // Keep some margin from top
    }
    
    contextMenu.style.top = `${top}px`;
    contextMenu.style.left = `${left}px`;

    // Add a one-time listener to close the menu when clicking elsewhere
    // Use a timeout to prevent the current click from being captured
    setTimeout(() => {
        const closeMenuOnClickOutside = (e) => {
            if (!contextMenu.contains(e.target)) {
                contextMenu.classList.remove('visible');
                document.removeEventListener('click', closeMenuOnClickOutside, true);
                document.removeEventListener('contextmenu', closeMenuOnClickOutside, true);
            }
        };
        // Use the capture phase (true) to catch the click before it bubbles to other elements
        document.addEventListener('click', closeMenuOnClickOutside, true);
        document.addEventListener('contextmenu', closeMenuOnClickOutside, true);
    }, 0);
}

function addTidalTrackToQueue(trackId, position = 'last') {
    isQueueUserModified = true;
    
    const numericTrackId = Number(trackId);
    const track = lasttidalSearchResults.find(t => t.id === numericTrackId) ||
                  currentDrawerContext.find(t => t.id === numericTrackId) ||
                  browseContext.find(t => t.id === numericTrackId);
    
    if (!track) {
        console.error("Could not find Tidal track to add to queue with ID:", trackId);
        return;
    }

    const song = {
        id: track.id,
        name: track.title || track.name,
        artist: track.artist?.name || track.artists?.[0]?.name || "Unknown Artist",
        album: track.album?.title || track.album || "Unknown Album",
        albumArt: getHighResArtwork(track.album?.cover),
        storage: 'tidal',
        duration: track.duration,
        audioQuality: track.audioQuality,
        explicit: track.explicit || false
    };

    if (playQueue.length === 0) {
        rebuildQueueFromCurrentView();
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
    }
    
    if (currentQueueIndex === -1) {
        currentQueueIndex = playQueue.length > 0 ? playQueue.length - 1 : 0;
    }
    
    if (position === 'next') {
        playQueue.splice(currentQueueIndex + 1, 0, song);
    } else { 
        playQueue.push(song);
    }

    showToast(`"${sanitize(song.name)}" added to queue`);
    
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
}

async function imageUrlToBase64(url) {
    if (!url || url.startsWith('data:')) return url;
    
    let urlToFetch = url;
    // Check if it's a TIDAL URL that can be resized
    if (url.includes('resources.tidal.com/images/')) {
        // Replace the size part of the URL (e.g., /1280x1280.jpg or /640x640.jpg) with /320x320.jpg
        urlToFetch = url.replace(/\/\d+x\d+\.jpg$/, '/320x320.jpg');
    }

    try {
        const response = await fetch(urlToFetch);
        const blob = await response.blob();
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    } catch (e) {
        console.warn('Failed to convert image to base64:', e);
        return url;
    }
}

async function playSong(song, playContext = null) {
    if (isPlayerLoading) {
        console.warn("Player is already loading, blocking new play request.");
        return;
    }
    
    if (playContext !== null) {
        isRadioMode = false;
        document.body.classList.remove('radio-mode');
    }

    if (playContext && Array.isArray(playContext)) {
        const wasAutoplayEnabled = isAutoplayEnabled;
        playQueue = [...playContext];
        isQueueUserModified = false;
        autoplaySongIds.clear();
        if (wasAutoplayEnabled) {
            await generateAutoplaySongs();
        }
    } else if (playQueue.length === 0) {
        rebuildQueueFromCurrentView();
    }
    
    isPlayerLoading = true;
    setPlayerLoadingState(true, song); 

    try {
        // iOS Fix: Resolve URL *before* touching the audio element to keep session alive
        lastActiveTimestamp = -1;
        song.hasBeenLogged = false;
        currentlyPlayingSong = song;
        setupBpm(song);
        
        // This await is the critical part. If we pause() before this, iOS kills the background task.
        let fileUrl = song.blobUrl || song.streamUrl || await getSongFileUrl(song);
        
        if (!fileUrl) {
            // Self-healing: If local file is missing, try to stream from cloud and restore it
            if (song.storage !== 'tidal') {
                 fileUrl = await recoverMissingLocalSong(song);
                 if (fileUrl) {
                     showToast(`Recovered "${song.name}" from cloud`);
                 }
            }
        }

        if (!fileUrl) {
            throw new Error(`Could not get a playable URL for ${song.name}`);
        }

        // --- Synchronous Audio Setup ---
        // Now that we have the URL, we swap sources immediately
        
        if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
            URL.revokeObjectURL(audioPlayer.src);
        }
        
        if (hls) {
            hls.destroy();
            hls = null;
        }

        const isHlsStream = song.streamUrl && song.streamUrl.includes('.m3u8');
        const isBlob = fileUrl.startsWith('blob:');
        
        if (isBlob) {
            audioPlayer.removeAttribute('crossorigin');
            connectAudioGraph();
        } else if (song.storage === 'tidal' || song.storage === 'filesystem') {
            // If we are streaming a direct URL and NOT on iOS, we disconnect the 
            // audio graph to prevent "silence" due to CORS restrictions.
            if (!isIOS && !castSession) {
                console.warn("Direct stream detected: Disconnecting visualizer to bypass CORS silencing.");
                disconnectAudioGraph();
            }
            audioPlayer.removeAttribute('crossorigin');
        } else {
            audioPlayer.removeAttribute('crossorigin');
            connectAudioGraph();
        }

        if (castSession) {
            updatePlayerUI(song);
            loadRemoteMedia();
            isPlayerLoading = false;
            return;
        } else {
            if (isHlsStream) {
                if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                    hls = new Hls();
                    hls.on(Hls.Events.ERROR, function (event, data) {
                        if (data.fatal) {
                            console.error('Fatal HLS Error:', data);
                            isPlayerLoading = false;
                            playNextSong({ userInitiated: false });
                        }
                    });
                    hls.loadSource(fileUrl);
                    hls.attachMedia(audioPlayer);
                } else if (audioPlayer.canPlayType('application/vnd.apple.mpegurl')) {
                    audioPlayer.src = fileUrl;
                }
            } else {
                audioPlayer.src = fileUrl;
                audioPlayer.load();
            }
        }

        currentSongId = song.id;
        sessionPlayedIds.add(song.id);
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);

        let base64Artwork = song.albumArt;
        try {
            base64Artwork = await imageUrlToBase64(song.albumArt);
        } catch (e) {
            console.warn("Artwork conversion failed", e);
        }

        if (isPanelVisible) {
            if (panelContent === 'lyrics') {
                renderLyrics();
            } else if (panelContent === 'queue') {
                renderQueue();
                scrollToCurrentSongInQueue();
            }
        }

        await new Promise((resolve, reject) => {
            const playAudio = () => {
                audioPlayer.play().then(resolve).catch(e => {
                    if (e.name === 'AbortError') {
                        resolve();
                    } else {
                        reject(e);
                    }
                });
            };
            // iOS optimization: trigger play immediately
            playAudio();
        });

        lastSongStartTime = Date.now();

        proactivelyCacheNextInQueue();

        // Explicitly unsetting seek handlers HERE (after playback starts) forces the OS 
        // to render Next/Prev buttons instead of seek buttons for the current item.
        if ('mediaSession' in navigator) {
            navigator.mediaSession.setActionHandler('seekforward', null);
            navigator.mediaSession.setActionHandler('seekbackward', null);
        }

        playPauseIcon.textContent = 'pause';
        playPauseBtn.classList.add('playing');
        updateMiniplayerUI(song, 'playing');

    } catch (error) {
        if (error.name !== 'AbortError') console.error("Failed to play song:", song.name, error);
        updateMiniplayerUI(song, 'paused');
    } finally {
        isPlayerLoading = false;
    }
}

function getLocalVersionIfExists(track) {
    if (!track) return track;
    const artistName = (track.artist && track.artist.name) ? track.artist.name : track.artist;
    const trackName = track.title || track.name;

    if (!artistName || !trackName) return track;

    const uniqueKey = `${artistName.toLowerCase().trim()}::${trackName.toLowerCase().trim()}`;
    if (localSongLookup.has(uniqueKey)) {
        console.log(`Found local version for "${trackName}", switching to owned track.`);
        return localSongLookup.get(uniqueKey);
    }
    return track;
}

function updateMiniplayerUI(song, state) {
    // If we are on the Now Playing screen, the miniplayer should ALWAYS be hidden.
    if (activeView === 'now-playing') {
        miniplayer.classList.add('hidden');
        return;
    }

    if (!song || !currentSongId) {
        miniplayer.classList.add('hidden');
        return;
    }

    miniplayer.classList.remove('hidden');
    miniplayerArt.src = song.albumArt;
    miniplayerTitle.textContent = sanitize(song.name) + getExplicitBadge(song.explicit);
    miniplayerArtist.textContent = sanitize(song.artist);

    let iconHtml;
    switch(state) {
        case 'playing':
            iconHtml = `<span class="material-symbols-rounded" style="font-size: 32px; font-variation-settings: 'FILL' 1, 'wght' 700, 'GRAD' 0, 'opsz' 48;">pause</span>`;
            break;
        case 'loading':
            iconHtml = `<svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg>`;
            break;
        case 'paused':
        default:
            iconHtml = `<span class="material-symbols-rounded" style="font-size: 32px; font-variation-settings: 'FILL' 1, 'wght' 700, 'GRAD' 0, 'opsz' 48;">play_arrow</span>`;
            break;
    }
    const miniplayerPlayBtn = document.getElementById('miniplayer-play-btn');
    if(miniplayerPlayBtn) miniplayerPlayBtn.innerHTML = iconHtml;
}
        
async function getSongFileUrl(song) {
    if (!song) return null;

    // 1. Check internal IndexedDB (For 'indexeddb' songs or 'filesystem' fallbacks)
    try {
        const tx = db.transaction(['musicFiles'], 'readonly');
        const request = tx.objectStore('musicFiles').get(song.id);
        const result = await new Promise((resolve) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => resolve(null);
        });
        if (result && result.file) return URL.createObjectURL(result.file);
    } catch (e) {
        console.warn("DB check skipped for URL resolution.");
    }

    // 2. Check connected folders for 'filesystem' songs
    if (song.storage === 'filesystem') {
        for (const handle of directoryHandles) {
            try {
                const fileHandle = await handle.getFileHandle(song.handleName);
                const file = await fileHandle.getFile();
                return URL.createObjectURL(file);
            } catch (e) {
                if (e.name === 'NotFoundError') continue;
                console.error(`Error accessing ${song.handleName} in ${handle.name}:`, e);
            }
        }
    }

    console.warn(`Could not find "${song.handleName}" in any connected directories or DB.`);
    return null;
}

async function logSongPlay(songId) {
    try {
        const songTx = db.transaction('songs', 'readwrite');
        const songStore = songTx.objectStore('songs');
        const songReq = songStore.get(songId);

        songReq.onsuccess = () => {
            const songData = songReq.result;
            if (songData) {
                songData.playCount = (songData.playCount || 0) + 1;
                songStore.put(songData);
            }
        };
        
        const historyTx = db.transaction('playHistory', 'readwrite');
        const historyStore = historyTx.objectStore('playHistory');
        historyStore.put({ timestamp: Date.now(), songId: songId });

        await Promise.all([songTx.done, historyTx.done]);

        // Also update the in-memory version
        const inMemorySong = songs.find(s => s.id === songId);
        if (inMemorySong) {
            inMemorySong.playCount = (inMemorySong.playCount || 0) + 1;
        }

    } catch (error) {
        console.error("Failed to log song play:", error);
    }
}

function proxyUrl(url) {
    if (isCorsProxyEnabled) {
        // This regex matches all relevant tidal domains that need proxying.
        const tidalDomains = /(tidal\.com|sndcdn\.com|tidal\.cloud)/;
        if (tidalDomains.test(url)) {
            return `https://corsproxy.io/?${encodeURIComponent(url)}`;
        }
    }
    return url;
}
        
function initModalVariables() {
    editModal = document.getElementById('editModal');
    editSongId = document.getElementById('editSongId');
    editTitle = document.getElementById('editTitle');
    editArtist = document.getElementById('editArtist');
    editAlbum = document.getElementById('editAlbum');
    saveEdit = document.getElementById('saveEdit');
    cancelEdit = document.getElementById('cancelEdit');
    saveEdit.addEventListener('click', saveMetadataChanges);
    cancelEdit.addEventListener('click', () => closeModal(editModal));

    sleepTimerModal = document.getElementById('sleepTimerModal');
    document.getElementById('cancelSleepTimer').addEventListener('click', () => setSleepTimer(0));

    playlistModal = document.getElementById('playlistModal');
    document.getElementById('closePlaylistModal').addEventListener('click', () => closeModal(playlistModal));
    document.getElementById('createPlaylistBtn').addEventListener('click', createPlaylistAndAddSong);

    equalizerModal = document.getElementById('equalizerModal');
    document.getElementById('closeEqModal').addEventListener('click', () => closeModal(equalizerModal));
    document.getElementById('resetEq').addEventListener('click', () => {
        ['bass-slider', 'mid-slider', 'treble-slider'].forEach(id => {
            const slider = document.getElementById(id);
            slider.value = 0;
            slider.dispatchEvent(new Event('input')); 
        });
    });
    document.getElementById('bass-slider').addEventListener('input', (e) => { if(eqBass) eqBass.gain.value = e.target.value; });
    document.getElementById('mid-slider').addEventListener('input', (e) => { if(eqMid) eqMid.gain.value = e.target.value; });
    document.getElementById('treble-slider').addEventListener('input', (e) => { if(eqTreble) eqTreble.gain.value = e.target.value; });
    
    manageFoldersModal = document.getElementById('manageFoldersModal');
    manualLyricsSearchModal = document.getElementById('manualLyricsSearchModal');
    document.getElementById('manualLyricsSearchBtn').addEventListener('click', searchLrclibForManualPick);
    document.getElementById('closeManualLyricsModal').addEventListener('click', () => closeModal(manualLyricsSearchModal));
}

document.getElementById('gDriveSyncBtn').addEventListener('click', () => syncLibraryToDrive(true));

function openManageFoldersModal() {
    document.getElementById('tidalToggle').checked = istidalEnabled;
    document.getElementById('lrclibToggle').checked = isLrclibEnabled;
    document.getElementById('prefAudioQuality').value = prefAudioQuality;
    document.getElementById('smartCacheToggle').checked = enableSmartCache;
    document.getElementById('streamOnlyToggle').checked = enableStreamOnly;
    document.getElementById('explicitToggle').checked = hideExplicitContent;
    openModal(manageFoldersModal);
}

        async function saveIntegrationSettings() {
            istidalEnabled = document.getElementById('tidalToggle').checked;
            isLrclibEnabled = document.getElementById('lrclibToggle').checked;

            const tx = db.transaction('config', 'readwrite');
            await Promise.all([
                tx.objectStore('config').put({ key: 'istidalEnabled', value: istidalEnabled }),
                tx.objectStore('config').put({ key: 'isLrclibEnabled', value: isLrclibEnabled })
            ]);
            
            toggletidalTab();
        }

async function saveIntegrationSettings() {
    istidalEnabled = document.getElementById('tidalToggle').checked;
    isLrclibEnabled = document.getElementById('lrclibToggle').checked;
    prefAudioQuality = document.getElementById('prefAudioQuality').value;
    enableSmartCache = document.getElementById('smartCacheToggle').checked;
    enableStreamOnly = document.getElementById('streamOnlyToggle').checked;
    hideExplicitContent = document.getElementById('explicitToggle').checked;

    const tx = db.transaction('config', 'readwrite');
    await Promise.all([
        tx.objectStore('config').put({ key: 'istidalEnabled', value: istidalEnabled }),
        tx.objectStore('config').put({ key: 'isLrclibEnabled', value: isLrclibEnabled }),
        tx.objectStore('config').put({ key: 'prefAudioQuality', value: prefAudioQuality }),
        tx.objectStore('config').put({ key: 'enableSmartCache', value: enableSmartCache }),
        tx.objectStore('config').put({ key: 'enableStreamOnly', value: enableStreamOnly }),
        tx.objectStore('config').put({ key: 'hideExplicitContent', value: hideExplicitContent })
    ]);
    
    toggletidalTab();
    showToast("Settings saved");
    closeModal(manageFoldersModal);
}

function toggletidalTab() {
    const tab = document.getElementById('tidal-tab');
    if (tab) {
        tab.style.display = istidalEnabled ? 'flex' : 'none';
    }
}

        async function searchtidal({ loadMore = false } = {}) {
            if (tidalSearchAbortController && !loadMore) {
                tidalSearchAbortController.abort();
            }
            tidalSearchAbortController = new AbortController();
            const signal = tidalSearchAbortController.signal;

            const query = document.getElementById('tidalSearchInput').value.trim();
            if (query && !loadMore) {
                // Feature 6: Save History
                searchHistory = searchHistory.filter(h => h !== query).slice(0, 4); // Keep last 5 unique
                searchHistory.unshift(query);
                localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
            }
            
            const resultsGrid = document.getElementById('tidal-results-grid');
            if (!query) {
                resultsGrid.innerHTML = '';
                lasttidalSearchResults = [];
                return;
            }

            if (!loadMore) {
                resultsGrid.innerHTML = `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`;
                tidalSearchOffset = 0;
                lasttidalSearchResults = [];
            } else {
                tidalSearchOffset += 50;
            }

            let param = 's';
            if (tidalFilter === 'artists') param = 'a';
            else if (tidalFilter === 'albums') param = 'al';
            else if (tidalFilter === 'playlists') param = 'p';

            const path = `/search/?${param}=${encodeURIComponent(query)}&offset=${tidalSearchOffset}`;

            try {
                const response = await fetchHifi(path, { signal });
                if (!response.ok) throw new Error(`API request failed: ${response.statusText}`);
                
                const responseData = await response.json();
                let data = responseData.data || {};
                
                if (tidalFilter === 'artists' && data.artists) data = data.artists;
                else if (tidalFilter === 'albums' && data.albums) data = data.albums;
                else if (tidalFilter === 'playlists' && data.playlists) data = data.playlists;
                else if (tidalFilter === 'tracks' && data.tracks) data = data.tracks;

                const totalItems = data.totalNumberOfItems || 0;
                const rawItems = (data.items || []).filter(item => !hideExplicitContent || !item.explicit);
                let newItems = [];
    
                switch (tidalFilter) {
                    case 'artists':
                        newItems = rawItems;
                        break;
                    case 'albums':
                        newItems = rawItems;
                        break;
                    case 'playlists':
                        newItems = rawItems;
                        break;
                    case 'tracks':
                    default:
                        newItems = rawItems;
                        break;
                }

                // FIX: Filter out duplicates before adding to the main results list
                const existingIds = new Set(lasttidalSearchResults.map(item => item.id));
                const newUniqueItems = newItems.filter(item => !existingIds.has(item.id));

                lasttidalSearchResults = lasttidalSearchResults.concat(newUniqueItems);
                rendertidalSearchResults(totalItems);

            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Search request was aborted.');
                    return;
                }
                console.error('Hifi Search Error:', error);
                resultsGrid.innerHTML = `<div class="no-results" style="grid-column: 1 / -1;"><p>Error searching the catalogue</p></div>`;
            }
        }

// This is a new helper function to manage the cache size
async function manageCacheSize() {
    const tx = db.transaction('tidalCache', 'readwrite');
    const store = tx.objectStore('tidalCache');
    const index = store.index('timestamp');
    const allEntriesReq = index.getAll();

    allEntriesReq.onsuccess = async () => {
        const entries = allEntriesReq.result;
        let totalSize = entries.reduce((acc, entry) => acc + entry.size, 0);

        if (totalSize > tidal_CACHE_LIMIT) {
            console.log(`Cache size (${(totalSize / 1024 / 1024).toFixed(2)}MB) exceeds limit. Pruning...`);
            entries.sort((a, b) => a.timestamp - b.timestamp); // Sort oldest first

            for (const entry of entries) {
                if (totalSize <= tidal_CACHE_LIMIT) break;
                await store.delete(entry.id);
                totalSize -= entry.size;
                console.log(`Removed ${entry.metadata.name} from cache.`);
            }
        }
    };
    await tx.done;
}

// This is a new function to handle background caching
async function cachetidalTrack(songObject, streamUrl) {
    try {
        const audioResponse = await fetch(streamUrl);
        if (!audioResponse.ok) throw new Error('Could not download audio file for caching.');
        const audioBlob = await audioResponse.blob();

        const cacheEntry = {
            id: songObject.id,
            metadata: songObject,
            blob: audioBlob,
            timestamp: Date.now(),
            size: audioBlob.size
        };

        const tx = db.transaction('tidalCache', 'readwrite');
        tx.objectStore('tidalCache').put(cacheEntry);
        await tx.done;

        console.log(`Successfully cached "${songObject.name}"`);
        await manageCacheSize();

    } catch (error) {
        console.error(`Failed to cache ${songObject.name}:`, error);
    }
}

async function proactivelyCacheNextInQueue() {
    if (!enableSmartCache || enableStreamOnly) return; 
    if (playQueue.length === 0 || currentQueueIndex < 0) return;

    // ** Dynamic Caching Strategy **
    let cacheDepth = 2; // Default
    
    // 1. Check User Behavior: If skipping rapidly, reduce depth to save bandwidth
    if (consecutiveRapidSkips >= 3) {
        cacheDepth = 1;
        console.log("Rapid skipping mode: Reducing cache buffer to 1.");
    } 
    // 2. Check Song Duration:
    else if (currentlyPlayingSong) {
        // Use metadata duration (API) or player duration
        const duration = currentlyPlayingSong.duration || audioPlayer.duration || 0;
        
        if (duration > 0 && duration < 180) { 
            // Short song (< 3 mins): Cache MORE because the next track comes sooner
            cacheDepth = 3;
        } else if (duration > 300) {
            // Long song (> 5 mins): Cache LESS initially, we have plenty of time
            cacheDepth = 1;
        }
    }

    // Look ahead based on calculated depth
    for (let i = 1; i <= cacheDepth; i++) {
        const nextIndex = currentQueueIndex + i;
        if (nextIndex >= playQueue.length) break;

        const nextSong = playQueue[nextIndex];
        
        // Only cache Tidal songs that aren't already cached
        if (nextSong.storage === 'tidal') {
            const tx = db.transaction('tidalCache', 'readonly');
            const store = tx.objectStore('tidalCache');
            const checkReq = store.get(nextSong.id);

            checkReq.onsuccess = async () => {
                if (!checkReq.result) {
                    console.log(`Proactively caching [${i}/${cacheDepth}]: ${nextSong.name}`);
                    try {
                        // Use a small delay for subsequent items to prioritize the immediate next song
                        if (i > 1) await new Promise(r => setTimeout(r, 2000));
                        await processAndCachetidalTrack(nextSong);
                    } catch (err) {
                        console.error(`Failed to proactively cache ${nextSong.name}:`, err);
                    }
                }
            };
        }
    }
}

async function processAndCachetidalTrack(songObject) {
    // Delegate audio fetching to the main function which correctly prioritizes /track/ over /dash/
    const cacheEntry = await processAndCacheAudio(songObject);

    if (cacheEntry) {
        // Fetch lyrics separately since processAndCacheAudio sets them to null
        try {
            const lrcDataResult = await fetchLyrics(songObject);
            if (lrcDataResult) {
                const lrcData = lrcDataResult.type === 'lrc' ? parseLRC(lrcDataResult.content) : null;
                
                cacheEntry.metadata.lyrics = lrcDataResult.content;
                cacheEntry.metadata.lrcData = lrcData;

                // Update the DB entry with lyrics
                const tx = db.transaction('tidalCache', 'readwrite');
                tx.objectStore('tidalCache').put(cacheEntry);
                await tx.done;
                console.log(`Updated cache with lyrics for "${songObject.name}"`);
            }
        } catch (e) {
            console.warn("Failed to fetch lyrics during background cache:", e);
        }
        return cacheEntry;
    }
    return null;
}

async function openArtistView(artistId, artistName) {
    currentDrawerContext = [];
    openDrawer(artistName, "Loading content...", `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`);

    try {
        const response = await fetchHifi(`/artist/?f=${artistId}`);
        if (!response.ok) throw new Error('Failed to fetch artist content');
        
        const data = await response.json();
    
        // Extract top tracks from the 'tracks' property
        const topTracks = data.tracks || [];
        
        // Extract albums from the new, deeply nested structure
        let albums = [];
        if (data.albums && data.albums.rows && data.albums.rows.length > 0 && data.albums.rows[0].modules && data.albums.rows[0].modules.length > 0 && data.albums.rows[0].modules[0].pagedList) {
            albums = data.albums.rows[0].modules[0].pagedList.items || [];
        }

        if (topTracks.length === 0 && albums.length === 0) {
            drawerContent.innerHTML = `<div class="no-results"><p>No content found for this artist.</p></div>`;
            return;
        }
        
        // The context for the "Own All" button should be the list of albums
        currentDrawerContext = albums;

        let contentHtml = '';

        // Generate HTML for the top tracks list
        if (topTracks.length > 0) {
            contentHtml += `
                <h3 class="section-title" style="font-size: 1.2rem; margin-bottom: 10px;">Top Tracks</h3>
                <div class="item-list" style="margin-bottom: 20px;">${topTracks.slice(0, 10).map(track => `
                    <div class="music-item" data-track-id="${track.id}" style="cursor: pointer;">
                        <div class="song-info">
                            <img src="${getHighResArtwork(track.album.cover, 80)}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 6px; margin-right: 10px;">
                            <div>
                                <div class="song-title">${sanitize(track.title)}</div>
                                <div class="album-artist" style="font-size: 0.8em;">${sanitize(track.album.title)}</div>
                            </div>
                        </div>
                    </div>`).join('')}
                </div>`;
        }

        // Generate HTML for the albums grid
        if (albums.length > 0) {
            contentHtml += `
                <h3 class="section-title" style="font-size: 1.2rem; margin-bottom: 10px;">Albums</h3>
                <div class="item-grid">${albums.map(album => `
                    <div class="item-card" data-album-id="${album.id}" data-album-name="${sanitize(album.title)}" data-album-artist-name="${sanitize(artistName)}">
                        <img src="${getHighResArtwork(album.cover, 320)}" class="item-card-art">
                        <div class="item-card-info">
                            <div class="item-card-title">${sanitize(album.title)}</div>
                        </div>
                    </div>`).join('')}
                </div>`;
        }
        
        // Update the drawer's subtitle and include the "Own All" button
        const drawerSubtitleEl = document.getElementById('drawer-subtitle');
        if(albums.length > 0) {
            drawerSubtitleEl.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; gap: 15px;">
                    <span>${albums.length} albums</span>
                    <button class="action-btn" id="save-artist-btn" style="padding: 8px 12px; height: auto;">
                        <span class="material-symbols-rounded" style="font-size: 16px;">arrow_circle_down</span>
                        Own All
                    </button>
                </div>
            `;
        } else {
             drawerSubtitleEl.textContent = `${topTracks.length} top tracks`;
        }
        

        drawerContent.innerHTML = contentHtml;
        
        if (document.getElementById('save-artist-btn')) {
            document.getElementById('save-artist-btn').addEventListener('click', () => saveArtistContent(currentDrawerContext, artistName));
        }

    } catch (error) {
        console.error("Error fetching artist content:", error);
        drawerContent.innerHTML = `<div class="no-results"><p>Could not load artist content.</p></div>`;
    }
}
        
async function openPlaylistView(playlistId, playlistTitle) {
    openDrawer(playlistTitle, 'Playlist', `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`);

    try {
        const response = await fetchHifi(`/playlist/?id=${playlistId}`);
        if (!response.ok) throw new Error('Failed to fetch playlist tracks');
        
        const responseData = await response.json();
        const playlistData = responseData.playlist || responseData.data || {};
        const items = responseData.items || responseData.data?.items || [];
        const tracks = items.filter(item => item.type === 'track' && item.item).map(item => item.item);

        if (!tracks || tracks.length === 0) {
            drawerContent.innerHTML = `<div class="no-results"><p>This playlist has no tracks.</p></div>`;
            return;
        }
        
        currentDrawerContext = tracks;
        const playlistImage = playlistData.image || playlistData.squareImage || playlistData.cover;
        const trackArts = tracks.slice(0, 4).map(t => getHighResArtwork(t.album?.cover));
        
        const trackCount = playlistData.numberOfTracks || tracks.length;
        const description = playlistData.description || '';
        
        const contentHtml = `
            <div class="album-header-list" style="margin-bottom: 15px; display: flex; align-items: center; justify-content: center; flex-direction: column;">
                <div style="display: flex; align-items: center; gap: 15px; width: 250px; height: 250px;">
                    ${playlistImage ? 
                        `<img src="${getHighResArtwork(playlistImage)}" style="width: 100%; height: 100%; border-radius: 12px; corner-shape: superellipse(1.5); box-shadow: 0 0 0 1px var(--glass-border); object-fit: cover;">` : 
                        getPlaylistArtPlaceholder(trackArts, "item-card-art")
                    }
                </div>
                ${description ? `<p style="text-align: center; color: var(--secondary-text-color); font-size: 0.9em; margin: 10px 20px;">${sanitize(description)}</p>` : ''}
                <p style="text-align: center; color: var(--secondary-text-color); font-size: 0.85em; margin-top: 5px;">${trackCount} tracks</p>
            </div>
            <div class="item-list">${tracks.map((track, index) => `
                <div class="music-item" data-track-id="${track.id}" style="cursor: pointer;">
                    <div class="song-info">
                        <span class="track-number">${index + 1}.</span>
                        <div class="song-title">${sanitize(track.title)}${getExplicitBadge(track.explicit)}</div>
                    </div>
                    <div class="album-artist">${sanitize(track.artist?.name || track.artists?.[0]?.name || 'Unknown Artist')}</div>
                </div>`).join('')}
            </div>`;

        drawerContent.innerHTML = contentHtml;

    } catch (error) {
        console.error("Error fetching playlist tracks:", error);
        drawerContent.innerHTML = `<div class="no-results"><p>Failed to load playlist tracks.</p></div>`;
    }
}

async function openAlbumView(albumId, albumName, artistName) {
    openDrawer(albumName, artistName, `<div class="loading-message"><svg width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="color: var(--text-color);"><style>.spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}@keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}</style><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke-width="3"></circle></g></svg></div>`);

    try {
        // FIX: Use the direct album endpoint to get its tracks.
        const response = await fetchHifi(`/album/?id=${albumId}`);
        if (!response.ok) throw new Error('Failed to fetch album tracks');
        
        const responseData = await response.json();
        const data = responseData.data || {};
        const tracks = (data.items || []).map(t => t.item);

        if (!tracks || tracks.length === 0) {
            drawerContent.innerHTML = `<div class="no-results"><p>No tracks found for this album.</p></div>`;
            return;
        }
        
        tracks.sort((a, b) => (a.volumeNumber || 1) - (b.volumeNumber || 1) || (a.trackNumber || 0) - (b.trackNumber || 0));
        currentDrawerContext = tracks;
        const albumArt = getHighResArtwork(tracks[0].album.cover);
        
        const contentHtml = `
            <div class="album-header-list" style="margin-bottom: 15px; display: flex; align-items: center; justify-content: center; flex-direction: column;">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <img src="${albumArt}" style="width: 250px; height: 250px; border-radius: 12px; corner-shape: superellipse(1.5); box-shadow: 0 0 0 1px var(--glass-border);">
                </div>
                <button class="action-btn" id="save-album-btn" style="padding: 8px 12px; height: auto;">
                    <span class="material-symbols-rounded" style="font-size: 16px;">arrow_circle_down</span>
                    Own
                </button>
            </div>
            <div class="item-list">${tracks.map(track => `
                <div class="music-item" data-track-id="${track.id}" style="cursor: pointer;">
                    <div class="song-info">
                        <span class="track-number">${track.trackNumber}.</span>
                        <div class="song-title">${sanitize(track.title)}${getExplicitBadge(track.explicit)}</div>
                    </div>
                </div>`).join('')}
            </div>`;

        drawerContent.innerHTML = contentHtml;
        document.getElementById('save-album-btn').addEventListener('click', () => saveAlbumContent(tracks, albumName));

    } catch (error) {
        console.error("Error fetching album tracks:", error);
        drawerContent.innerHTML = `<div class="no-results"><p>Could not load album tracks.</p></div>`;
    }
}

function openLocalAlbumView(artistName, albumName) {
    // Filter local songs based on artist and album
    const albumSongs = songs.filter(s => s.albumArtist === artistName && s.album === albumName)
                           .sort((a,b) => (a.trackNumber || 0) - (b.trackNumber || 0));

    if (albumSongs.length === 0) {
        openDrawer(albumName, artistName, `<div class="no-results"><p>No songs found for this local album.</p></div>`);
        return;
    }
    
    // Use the first song's art for the header
    const albumArt = albumSongs[0].albumArt;

    // Build the content HTML
    const contentHtml = `
        <div class="album-header-list" style="margin-bottom: 15px; display: flex; align-items: center; justify-content: center; flex-direction: column;">
            <div style="display: flex; align-items: center; gap: 15px;">
                <img src="${albumArt}" style="width: 250px; height: 250px; border-radius: 12px; corner-shape: superellipse(1.5); box-shadow: 0 0 0 1px var(--glass-border);">
            </div>
        </div>
        <div class="item-list">${albumSongs.map(song => `
            <div class="music-item" data-id="${song.id}" style="cursor: pointer;">
                <div class="song-info">
                    <span class="track-number">${song.trackNumber || ''}.</span>
                    <div class="song-title">${sanitize(song.name)}</div>
                </div>
            </div>`).join('')}
        </div>`;

    openDrawer(albumName, artistName, contentHtml);
}

async function fetchAndUpdateLyrics(song) {
    if (song.lyrics) {
        if (isPanelVisible && panelContent === 'lyrics') {
            renderLyrics();
        }
        return;
    }

    console.log(`Fetching lyrics for "${song.name}" in the background...`);
    const fetchedLyrics = await fetchLyrics(song);

    if (fetchedLyrics && currentlyPlayingSong && currentlyPlayingSong.id === song.id) {
        currentlyPlayingSong.lyrics = fetchedLyrics.content;
        currentlyPlayingSong.lrcData = fetchedLyrics.type === 'lrc' ? parseLRC(fetchedLyrics.content) : null;
        
        if (currentlyPlayingSong.storage === 'tidal') {
            updatetidalCacheWithLyrics(currentlyPlayingSong);
        } else {
            saveSongs();
        }

        if (isPanelVisible && panelContent === 'lyrics') {
            renderLyrics();
        }
    }
}
        
async function savetidalTrackToLibrary() {
    if (!currentlyPlayingSong || currentlyPlayingSong.storage !== 'tidal') return;

    const songToSave = currentlyPlayingSong;
    try {
        showToast(`Saving "${songToSave.name}"...`);
        let audioBlob;
        const tx = db.transaction('tidalCache', 'readonly');
        const cacheReq = await promiseIDBRequest(tx.objectStore('tidalCache').get(songToSave.id));
        if (cacheReq && cacheReq.blob) {
            audioBlob = cacheReq.blob;
        } else {
            const processedEntry = await processAndCacheAudio(songToSave);
            if (!processedEntry || !processedEntry.blob) throw new Error("Failed to process track for saving.");
            audioBlob = processedEntry.blob;
        }

        if (!songToSave.lyrics) {
            const fetchedLyrics = await fetchLyrics(songToSave);
            if (fetchedLyrics) {
                songToSave.lyrics = fetchedLyrics.content;
                songToSave.lrcData = fetchedLyrics.type === 'lrc' ? parseLRC(fetchedLyrics.content) : null;
                updatetidalCacheWithLyrics(songToSave);
            }
        }

        const newLocalId = Date.now() + Math.random();
        const newLocalSong = {
            id: newLocalId, name: songToSave.name, artist: songToSave.artist,
            album: songToSave.album, albumArtist: songToSave.artist,
            storage: 'indexeddb', handleName: `${songToSave.name}.mp3`,
            dateAdded: Date.now(), year: new Date().getFullYear().toString(),
            albumArt: songToSave.albumArt, trackNumber: songToSave.trackNumber,
            discNumber: songToSave.volumeNumber,
            lyrics: songToSave.lyrics, lrcData: songToSave.lrcData, playCount: 0,
            vibrantColor: songToSave.vibrantColor,
            peak: songToSave.peak,
            bpm: songToSave.bpm,
            isrc: songToSave.isrc,
            copyright: songToSave.copyright,
            explicit: songToSave.explicit
        };
        const songTx = db.transaction(['songs', 'musicFiles'], 'readwrite');
        songTx.objectStore('songs').put(newLocalSong);
        songTx.objectStore('musicFiles').put({ id: newLocalId, file: audioBlob });
        await songTx.done;
        songs.push(newLocalSong);
        processAndSortSongs();
        updateLocalSongLookup([newLocalSong]);
        showToast(`Added "${songToSave.name}"`);
    } catch (error) {
        console.error("Failed to save track to library:", error);
        showToast("Cannot add song");
    }
}

async function batchSaveTidalTracks(tracks) {
    const newSongs = [];
    const filesToStore = [];
    let processedCount = 0;

    // Filter out tracks that are already in the local library using the ISRC map
    const tracksToProcess = tracks.filter(track => !track.isrc 
        || !isrcToLocalSongMap.has(track.isrc));

    if (tracksToProcess.length === 0) {
        return 0; // Nothing to do
    }

    // Concurrency Limiter
    const concurrencyLimit = 5;
    const queue = [...tracksToProcess];
    let activeWorkers = 0;
    const results = [];

    const processTrack = async (track) => {
        try {
            const audioBlob = (await processAndCacheAudio(track))?.blob;
            if (!audioBlob) throw new Error("Failed to process audio.");

            const fetchedLyrics = await fetchLyrics(track);

            const newLocalId = Date.now() + Math.random();
            const newLocalSong = {
                id: newLocalId, name: track.name, artist: track.artist,
                album: track.album, albumArtist: track.artist,
                storage: 'indexeddb', handleName: `${track.name}.mp3`,
                dateAdded: Date.now(), year: new Date().getFullYear().toString(),
                albumArt: track.albumArt, trackNumber: track.trackNumber,
                discNumber: track.volumeNumber,
                lyrics: fetchedLyrics ? fetchedLyrics.content : null,
                lrcData: (fetchedLyrics && fetchedLyrics.type === 'lrc') 
                    ? parseLRC(fetchedLyrics.content) : null,
                peak: track.peak,
                bpm: track.bpm,
                playCount: 0,
                vibrantColor: track.vibrantColor,
                isrc: track.isrc,
                copyright: track.copyright,
                explicit: track.explicit
            };
            
            return { 
                songData: newLocalSong, 
                fileData: { id: newLocalId, file: audioBlob } 
            };

        } catch (error) {
            console.error(`Failed to save track "${track.name}":`, error);
            return null; // Return null on failure for this track
        }
    };

    return new Promise(resolve => {
        const worker = async () => {
            while (queue.length > 0) {
                const track = queue.shift();
                const result = await processTrack(track);
                if (result) {
                    results.push(result);
                }
            }
            activeWorkers--;
            if (activeWorkers === 0) {
                // All workers are done, finalize the process
                finalizeBatchSave();
            }
        };

        const finalizeBatchSave = async () => {
            if (results.length === 0) {
                resolve(0);
                return;
            }

            const newSongsData = results.map(r => r.songData);
            const newFilesData = results.map(r => r.fileData);

            // Perform a single, large transaction
            const tx = db.transaction(['songs', 'musicFiles'], 'readwrite');
            const songStore = tx.objectStore('songs');
            const fileStore = tx.objectStore('musicFiles');
            newSongsData.forEach(song => songStore.put(song));
            newFilesData.forEach(file => fileStore.put(file));
            await tx.done;

            // Update in-memory state
            songs.push(...newSongsData);
            processAndSortSongs();
            updateLocalSongLookup(newSongsData);
            newSongsData.forEach(song => {
                if(song.isrc) isrcToLocalSongMap.set(song.isrc, song);
            });
            
            triggerAutoSync();
            resolve(results.length);
        };

        // Start workers
        for (let i = 0; i < concurrencyLimit && queue.length > 0; i++) {
            activeWorkers++;
            worker();
        }
    });
}

async function saveArtistContent(albums, artistName) {
    showToast(`Saving all albums by ${artistName}...`);
    
    for (const album of albums) {
        try {
            const response = await fetchHifi(`/album/?id=${album.id}`);
            
            if (response.ok) {
                const responseData = await response.json();
                
                // FIX 2: Update parsing to match new API structure (data.data.items)
                const albumData = responseData.data || {};
                const items = albumData.items || [];
                const tracks = items.map(t => t.item);
                
                if (tracks.length > 0) {
                    await saveAlbumContent(tracks, album.title, true); // silent=true
                } else {
                    console.warn(`Album "${album.title}" has no tracks.`);
                }
            }
        } catch (error) {
            console.error(`Failed to fetch tracks for album ${album.title}:`, error);
        }
    }
    
    showToast(`Finished saving albums for ${artistName}`);
    renderLibraryPage(); // Refresh the library view
}

async function saveAlbumContent(tracks, albumName, silent = false) {
    if (!silent) {
        showToast(`Saving "${albumName}"...`);
    }

    const tracksToSave = tracks.map(trackData => ({
        id: trackData.id, name: trackData.title, artist: trackData.artist.name,
        album: trackData.album.title, albumArt: getHighResArtwork(trackData.album.cover),
        storage: 'tidal', duration: trackData.duration, audioQuality: trackData.audioQuality,
        trackNumber: trackData.trackNumber, volumeNumber: trackData.volumeNumber,
        isrc: trackData.isrc, copyright: trackData.copyright,
        vibrantColor: trackData.album.vibrantColor
    }));

    const savedCount = await batchSaveTidalTracks(tracksToSave);

    if (!silent) {
        if (savedCount > 0) {
            showToast(`Saved ${savedCount} new from "${albumName}"`);
            renderLibraryPage();
        } else {
            showToast(`All items from "${albumName}" are already owned`);
        }
    }
}
        
async function processAndCacheAudio(songObject, signal = null) {
    try {
        // 1. Configure Quality Order based on Settings
        // Use global prefAudioQuality if available, otherwise default to LOSSLESS
        let userPref = (typeof prefAudioQuality !== 'undefined') ? prefAudioQuality : 'LOSSLESS';
        
        // Data Saver Awareness
        if (isDataSaver()) {
            console.log("Data Saver detected. Downgrading quality to LOW.");
            userPref = 'LOW';
        }
        
        const allQualities = ['LOSSLESS', 'HIGH', 'LOW'];
        
        let qualityLevelsToTry = [userPref];
        
        // Add remaining qualities as fallbacks
        allQualities.forEach(q => {
            if (!qualityLevelsToTry.includes(q)) qualityLevelsToTry.push(q);
        });

        let concatenatedBlob = null;
        let finalQuality = 'LOW'; // Default to low, update if we find better

        // --- Stage 1: Attempt to fetch using /track endpoint (Preferred) ---
        console.log(`Attempting to fetch via /track endpoint for "${songObject.name}"...`);
        for (const quality of qualityLevelsToTry) {
            if (concatenatedBlob) break;
            
            try {
                // Use fetchHifi for API resilience, pass signal
                const response = await fetchHifi(`/track/?id=${songObject.id}&quality=${quality}`, { signal });
                
                if (response.ok) {
                    const responseData = await response.json();
                    const data = responseData.data || {};

                    if (data.peak) songObject.peak = data.peak;
                    if (data.bpm) songObject.bpm = data.bpm;

                    if (data.manifest) {
                        const decodedManifest = JSON.parse(atob(data.manifest));
                        if (decodedManifest.urls && decodedManifest.urls[0]) {
                            const audioUrl = decodedManifest.urls[0];
                            console.log(`Found direct URL via /track manifest for quality: ${quality}`);
                            
                            // Use standard fetch for CDN download, but pass signal
                            const audioResponse = await fetch(audioUrl, { signal });
                            if (audioResponse.ok) {
                                concatenatedBlob = await audioResponse.blob();
                                finalQuality = quality; // Capture the actual quality found
                            }
                        }
                    }
                }
            } catch(e) {
                if (e.name === 'AbortError') throw e; 
                // Don't log every 401/403 for high qualities, it's expected if not available
                if(e.message && !e.message.includes('401')) {
                    console.warn(`Request to /track with quality ${quality} failed:`, e);
                }
            }
        }

        // --- Stage 2: If /track failed, attempt to fetch using /dash endpoint (Fallback) ---
        if (!concatenatedBlob) {
            console.log(`All /track attempts failed. Trying /dash endpoint...`);
            for (const quality of qualityLevelsToTry) {
                if (concatenatedBlob) break;
                
                try {
                    const response = await fetchHifi(`/dash/?id=${songObject.id}&quality=${quality}`, { signal });
                    if (!response.ok) continue;

                    const text = await response.text();
                    
                    if (text && text.trim().startsWith('<?xml')) {
                        console.log(`Found XML manifest via /dash for quality: ${quality}`);
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(text, "application/xml");
                        const representation = xmlDoc.querySelector("Representation");
                        const segmentTemplate = representation.querySelector("SegmentTemplate");
                        const initUrl = segmentTemplate.getAttribute("initialization");
                        const mediaUrlTemplate = segmentTemplate.getAttribute("media");
                        const segmentTimeline = segmentTemplate.querySelector("SegmentTimeline");
                        const sElements = segmentTimeline.querySelectorAll("S");
                        const segments = [];
                        sElements.forEach(s => {
                            const r = parseInt(s.getAttribute("r") || "0");
                            for (let i = 0; i <= r; i++) segments.push(1);
                        });
                        const segmentUrls = [];
                        for (let i = 0; i < segments.length; i++) {
                            segmentUrls.push(mediaUrlTemplate.replace('$Number$', i + 1));
                        }
                        
                        // Fetch segments in parallel
                        const [initSegmentBlob, ...mediaSegmentBlobs] = await Promise.all(
                            [initUrl, ...segmentUrls].map(url => fetch(url, { signal }).then(res => res.blob()))
                        );
                        concatenatedBlob = new Blob([initSegmentBlob, ...mediaSegmentBlobs], { type: 'audio/mp4' });
                        finalQuality = quality;

                    } else {
                        try {
                            const directUrlData = JSON.parse(text);
                            if (directUrlData && directUrlData.urls && directUrlData.urls.length > 0) {
                                console.log(`Found direct URL via /dash for quality: ${quality}`);
                                const audioResponse = await fetch(directUrlData.urls[0], { signal });
                                if (audioResponse.ok) {
                                    concatenatedBlob = await audioResponse.blob();
                                    finalQuality = quality;
                                }
                            }
                        } catch (e) {
                           // Silent catch for JSON parse errors on XML data
                        }
                    }
                } catch (e) {
                    if (e.name === 'AbortError') throw e;
                    console.warn(`Request to /dash with quality ${quality} failed:`, e);
                }
            }
        }
        
        if (!concatenatedBlob) {
            throw new Error('Failed to fetch a valid stream from both /track and /dash endpoints.');
        }

        const cacheEntry = {
            id: songObject.id, 
            blob: concatenatedBlob, 
            timestamp: Date.now(), 
            size: concatenatedBlob.size,
            metadata: { 
                ...songObject, 
                audioQuality: finalQuality, // Store the actual quality we got
                lyrics: null, 
                lrcData: null 
            }
        };

        // 3. Check Stream Only Mode Setting
        // Only write to DB if Stream Only is FALSE and we aren't just processing for immediate play
        if (!enableStreamOnly) {
            const tx = db.transaction('tidalCache', 'readwrite');
            tx.objectStore('tidalCache').put(cacheEntry);
            await tx.done;
            console.log(`Successfully cached audio for "${songObject.name}" [${finalQuality}]`);
            await manageCacheSize();
        } else {
            console.log(`Stream Only Mode: "${songObject.name}" loaded to RAM, not caching.`);
        }
        
        return cacheEntry;

    } catch (error) {
        if (error.name === 'AbortError') {
            console.log(`Aborted audio processing for ${songObject.name}`);
            return null;
        }
        console.error(`Failed to process audio for ${songObject.name}:`, error);
        return null;
    }
}

// New helper to resolve stream URL without downloading the whole file
async function resolveTidalUrl(songObject) {
    let userPref = (typeof prefAudioQuality !== 'undefined') ? prefAudioQuality : 'LOSSLESS';
    if (isDataSaver()) userPref = 'LOW';
    
    const allQualities = ['LOSSLESS', 'HIGH', 'LOW'];
    
    let qualityLevelsToTry = [userPref];
    allQualities.forEach(q => { if (!qualityLevelsToTry.includes(q)) qualityLevelsToTry.push(q); });

    // 1. Try /track/ endpoint
    for (const quality of qualityLevelsToTry) {
        try {
            const response = await fetchHifi(`/track/?id=${songObject.id}&quality=${quality}`);
            if (response.ok) {
                const data = (await response.json()).data || {};
                
                // Update metadata if available
                if (data.peak) songObject.peak = data.peak;
                if (data.bpm) songObject.bpm = data.bpm;

                if (data.manifest) {
                    const decoded = JSON.parse(atob(data.manifest));
                    if (decoded.urls && decoded.urls[0]) {
                        return { url: decoded.urls[0], quality };
                    }
                }
            }
        } catch(e) { /* continue */ }
    }

    // 2. Fallback to /dash/ endpoint
    for (const quality of qualityLevelsToTry) {
        try {
            const response = await fetchHifi(`/dash/?id=${songObject.id}&quality=${quality}`);
            if (!response.ok) continue;

            const text = await response.text();
            if (text && text.trim().startsWith('<?xml')) {
                // XML Manifest logic
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(text, "application/xml");
                const representation = xmlDoc.querySelector("Representation");
                const segmentTemplate = representation.querySelector("SegmentTemplate");
                const mediaUrlTemplate = segmentTemplate.getAttribute("media");
                
                // Construct a direct URL for the first segment (often works for playback start) 
                // or just fail over to processAndCacheAudio if DASH is strict.
                // However, usually DASH requires MediaSource Extensions which don't work well 
                // in standard Audio tags without HLS.js or Dash.js.
                // For this specific API, often the XML route implies complex handling.
                // We will return null here to force the fallback or error, 
                // BUT many of these endpoints also return JSON on other qualities.
                
                // Optimized: If we hit XML, we might be better off skipping "Stream Direct" 
                // and letting the robust downloader handle it, OR just return null.
            } else {
                try {
                    const json = JSON.parse(text);
                    if (json && json.urls && json.urls[0]) {
                        return { url: json.urls[0], quality };
                    }
                } catch (e) {}
            }
        } catch (e) {}
    }
    return null;
}
        
async function updatetidalCacheWithLyrics(song) {
    if (!song || song.storage !== 'tidal') return;

    try {
        const tx = db.transaction('tidalCache', 'readwrite');
        const store = tx.objectStore('tidalCache');
        const request = store.get(song.id);

        request.onsuccess = () => {
            const entry = request.result;
            if (entry) {
                // Add the new lyrics data to the cached metadata
                entry.metadata.lyrics = song.lyrics;
                entry.metadata.lrcData = song.lrcData;
                store.put(entry);
            }
        };
        await tx.done;
        console.log(`Saved lyrics for SC track "${song.name}" to cache.`);
    } catch (error) {
        console.error("Failed to update tidal cache with lyrics:", error);
    }
}

async function playtidalTrack(trackId, playContext = null) {
    // 1. Halt previous efforts
    if (playbackLoader) {
        playbackLoader.abort();
    }
    playbackLoader = new AbortController(); // Create new controller for this song
    const signal = playbackLoader.signal;
    
    const numericTrackId = Number(trackId);
    let songObject;
    try {
        // FIX: Check cache first, this is now the primary source of truth.
        const tx = db.transaction('tidalCache', 'readonly');
        const cachedEntry = await promiseIDBRequest(tx.objectStore('tidalCache').get(numericTrackId));
        
        if (cachedEntry) {
            console.log("Playing from cache.");
            const songToPlay = cachedEntry.metadata;
            songToPlay.blobUrl = URL.createObjectURL(cachedEntry.blob);
            await playSong(songToPlay, playContext);
            fetchAndUpdateLyrics(songToPlay);
            return; // Exit here since we handled the cached song completely
        }
        
        // If not in cache, proceed with the original online logic
        // Check playQueue as well to support Radio tracks
        let trackData = lasttidalSearchResults.find(t => t.id === numericTrackId) ||
                          currentDrawerContext.find(t => t.id === numericTrackId) ||
                          browseContext.find(t => t.id === numericTrackId) || // Check browse context
                          playQueue.find(t => t.id === numericTrackId);

        if (!trackData) {
            try {
                const infoRes = await fetchHifi(`/info/?id=${numericTrackId}`, { signal });
                if (infoRes.ok) {
                    const infoJson = await infoRes.json();
                    trackData = infoJson.data;
                }
            } catch (e) { console.warn("Failed to fetch track info", e); }
        }

        if (!trackData) {
            console.error("Track ID not found in any context:", numericTrackId);
            throw new Error("Track not found in contexts or API info");
        }

        if (trackData.isrc && isrcToLocalSongMap.has(trackData.isrc)) {
            const localSong = isrcToLocalSongMap.get(trackData.isrc);
            console.log(`Found local version for "${trackData.title || trackData.name}". Playing from library.`);
            await playSong(localSong, null);
            return;
        }

        // Fix: Determine if data is already normalized (from Queue/Radio) or Raw (from API)
        const isNormalized = trackData.storage === 'tidal' && typeof trackData.artist === 'string';

        const title = isNormalized ? trackData.name : trackData.title;
        const artist = isNormalized ? trackData.artist : (trackData.artist ? trackData.artist.name : "Unknown Artist");
        const album = isNormalized ? trackData.album : (trackData.album ? trackData.album.title : "Unknown Album");
        const albumArt = isNormalized ? trackData.albumArt : getHighResArtwork(trackData.album ? trackData.album.cover : null);
        const vibrantColor = isNormalized ? trackData.vibrantColor : (trackData.album ? trackData.album.vibrantColor : null);

        songObject = {
            id: trackData.id, 
            name: title, 
            artist: artist,
            album: album, 
            albumArt: albumArt,
            storage: 'tidal', 
            duration: trackData.duration, 
            audioQuality: trackData.audioQuality,
            trackNumber: trackData.trackNumber, 
            volumeNumber: trackData.volumeNumber,
            isrc: trackData.isrc, 
            copyright: trackData.copyright, 
            vibrantColor: vibrantColor,
            peak: trackData.peak || null,
            bpm: trackData.bpm || null,
            explicit: trackData.explicit || false
        };
        
        currentlyPlayingSong = songObject;
        currentSongId = songObject.id;
        setPlayerLoadingState(true, songObject);

        console.log("Track not cached. Resolving stream URL...");
        
        // Only stream direct URLs on iOS (where visualizers are disabled).
        // On Desktop/Android, we MUST use Blobs to bypass CORS silencing for Web Audio processing.
        const shouldStreamDirectly = isIOS;

        let streamData = null;
        if (shouldStreamDirectly) {
            streamData = await resolveTidalUrl(songObject);
        }
        
        if (signal.aborted) return;

        if (streamData) {
            // We found a direct stream URL
            console.log(`Stream URL found [${streamData.quality}]. Playing directly.`);
            songObject.streamUrl = streamData.url;
            songObject.audioQuality = streamData.quality;
            
            await playSong(songObject, playContext);
            fetchAndUpdateLyrics(songObject);
        } else {
            // Fallback: If quick resolve failed, try the full processor (slower, but robust)
            console.log("Quick resolve failed. Attempting full process...");
            const newCachedSong = await processAndCacheAudio(songObject, signal);
            
            if (signal.aborted) return;

            if (newCachedSong) {
                const songToPlay = newCachedSong.metadata;
                songToPlay.blobUrl = URL.createObjectURL(newCachedSong.blob);
                await playSong(songToPlay, playContext);
                fetchAndUpdateLyrics(songToPlay);
            } else {
                throw new Error("Unable to resolve audio stream.");
            }
        }
    } catch (error) {
        if (signal.aborted) return; // Ignore errors caused by abort
        console.error(`Failed to play Hi-Fi track ${numericTrackId}:`, error);
        showToast("Cannot play selected item");
        isPlayerLoading = false;
        playNextSong({ userInitiated: false });
    } finally {
        if (!signal.aborted) {
            setPlayerLoadingState(false, songObject);
        }
    }
}
        
function connectAudioGraph() {
    // iOS Fix: Never connect the AudioContext graph on iOS. 
    // It causes resume failures because iOS kills/suspends the context in the background.
    if (isIOS) return;

    if (source && audioContext && eqBass) {
        try {
            source.disconnect(); 
        } catch(e) { }
        source.connect(eqBass);
        document.getElementById('visualizerCanvas').style.visibility = 'visible';
    }
}

function disconnectAudioGraph() {
    if (isIOS) return;

    if (source) {
        try {
            source.disconnect();
        } catch(e) { }
        document.getElementById('visualizerCanvas').style.visibility = 'hidden';
    }
}
        
async function removeFolder(folderName) {
    if (!await showConfirmDialog(`Are you sure you want to remove the folder "${folderName}"? All songs from this folder will be removed from your library.`)) {
        return;
    }

    const initialSongCount = songs.length;
    
    // Update the list of active directory handles in memory
    directoryHandles = directoryHandles.filter(h => h.name !== folderName);

    const songsToKeep = [];
    for (const song of songs) {
        // Always keep songs that are stored directly in the browser's database
        if (song.storage === 'indexeddb') {
            songsToKeep.push(song);
            continue;
        }

        // For filesystem-based songs, check if their file still exists in any of the REMAINING folders
        if (song.storage === 'filesystem') {
            let isStillAvailable = false;
            for (const handle of directoryHandles) {
                try {
                    // Check if we can get a handle to the file. If this doesn't throw an error, the file exists.
                    await handle.getFileHandle(song.handleName, { create: false });
                    isStillAvailable = true;
                    break; // The song is safe, no need to check other folders
                } catch (e) {
                    // A "NotFoundError" is expected if the song was in the removed folder.
                    // We only log other potential errors (e.g., permission denied).
                    if (e.name !== 'NotFoundError') {
                        console.warn(`Permission or other error checking for "${song.handleName}" in "${handle.name}".`, e);
                    }
                }
            }
            // Only add the song to our list of survivors if it was found in a remaining folder.
            if (isStillAvailable) {
                songsToKeep.push(song);
            }
        }
    }

    const removedSongCount = initialSongCount - songsToKeep.length;
    
    // Replace the main songs array with the filtered list of survivors.
    songs = songsToKeep;

    // --- Persist all state changes and update the UI ---

    // 1. Save the updated (smaller) list of directory handles to the database.
    const tx = db.transaction('config', 'readwrite');
    tx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
    await tx.done;
    
    // 2. Save the updated (smaller) list of songs to the database.
    await saveSongs();

    // 3. Update the play queue in case a removed song was in it.
    updatePlayQueue();

    // 4. Show a confirmation message and refresh the UI.
    showToast(`Removed "${folderName}"`);
    openManageFoldersModal(); // Refreshes the folder list inside the modal.
    if (activeView === 'library') {
        renderLibraryPage(); // Refreshes the main library view in the background.
    }
}

        async function deleteSong(songIdToDelete) {
            const songIndex = songs.findIndex(s => s.id === songIdToDelete);
            if (songIndex === -1) return;
        
            const songToDelete = songs[songIndex];
            if (songToDelete.storage === 'indexeddb') {
                const tx = db.transaction('musicFiles', 'readwrite');
                tx.objectStore('musicFiles').delete(songIdToDelete);
                await tx.done;
            }
            
            if (songToDelete.isrc) {
                isrcToLocalSongMap.delete(songToDelete.isrc);
            }
        
            songs.splice(songIndex, 1);
            await saveSongs();
        
            if (songIdToDelete === currentSongId) {
                playNextSong(); 
            } else {
                updatePlayQueue();
            }
        }
        
        function openEditModal(songId) {
            const song = songs.find(s => s.id === songId);
            if (!song) return;
        
            editSongId.value = song.id;
            editTitle.value = song.name;
            editArtist.value = song.artist;
            editAlbum.value = song.album;
            openModal(editModal);
        }

        async function saveMetadataChanges() {
            const songId = parseFloat(editSongId.value);
            const song = songs.find(s => s.id === songId);
            if (!song) return;

            song.name = editTitle.value;
            song.artist = editArtist.value;
            song.album = editAlbum.value;

            if (song.id === currentSongId) {
                musicTitle.textContent = sanitize(song.name);
                musicArtist.textContent = song.artist;
                document.title = `${song.name} by ${song.artist}`;
                updateMediaSessionMetadata(song);
            }

            await saveSongs();
            closeModal(editModal);
        }

        function openPlaylistModal() {
            const playlistList = document.getElementById('playlistList');
            playlistList.innerHTML = '';
            if (playlists.length > 0) {
                 playlists.forEach(p => {
                    const item = document.createElement('div');
                    item.className = 'menu-item';
                    item.textContent = p.name;
                    item.onclick = () => addSongToPlaylist(p.id);
                    playlistList.appendChild(item);
                });
            } else {
                playlistList.innerHTML = '<p style="color: var(--secondary-text-color); text-align: center;">No playlists to add to</p>';
            }
            openModal(playlistModal);
        }
    
        async function fetchLyrics(song) {
            let lyrics = null;

            // 1. Try HiFi (Native) API first for Tidal songs
            // This is preferred because it matches by ID (100% accuracy)
            if (song.storage === 'tidal') {
                lyrics = await fetchLyricsFromHifi(song);
            }

            // 2. Fallback: If no lyrics found (or not Tidal), and LRCLIB is enabled, try LRCLIB
            // This matches by Artist/Title (Fuzzy match)
            if (!lyrics && isLrclibEnabled) {
                console.log(`Primary lyrics failed for "${song.name}", trying LRCLIB fallback...`);
                lyrics = await fetchLyricsFromLrclib(song);
            }

            return lyrics;
        }
        
        async function fetchLyricsFromHifi(song) {
            if (!song || !song.id) return null;
            try {
                const response = await fetchHifi(`/lyrics/?id=${song.id}`);
                if (!response.ok) {
                    console.warn(`Hifi Lyrics request failed with status: ${response.status}`);
                    return null;
                }
                const data = await response.json();
                if (!data || data.length === 0 || (!data[0].lyrics && !data[0].subtitles)) {
                    return null;
                }
                const lyricsData = data[0];
                if (lyricsData.subtitles) {
                    return { type: 'lrc', content: lyricsData.subtitles };
                } else if (lyricsData.lyrics) {
                    return { type: 'plain', content: lyricsData.lyrics };
                }
            } catch (error) {
                console.error("Error fetching lyrics from Hifi API:", error);
            }
            return null;
        }
        
function addQueueItemEventListeners() {
    document.querySelectorAll('.queue-item').forEach(item => {
        item.addEventListener('click', (e) => {
            // Prevent click from propagating to the remove button
            if (e.target.closest('.remove-from-queue-btn')) return;

            const songId = parseFloat(item.dataset.id);
            const song = playQueue.find(s => s.id === songId);
            if (song) {
                // --- THE FIX ---
                // We now call the play functions with "null" as the context.
                // This tells the player to find the song in the EXISTING queue
                // instead of creating a new one.
                if (song.storage === 'tidal') {
                    playtidalTrack(song.id, null);
                } else {
                    playSong(song, null);
                }
            }
        });
    });

    document.querySelectorAll('.remove-from-queue-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            isQueueUserModified = true; // <-- ADD THIS LINE: Removing a song is a manual edit.
            const indexToRemove = parseInt(e.currentTarget.dataset.queueIndex, 10);
            
            if (playQueue[indexToRemove].id === currentSongId) {
                playQueue.splice(indexToRemove, 1);
                if (playQueue.length > 0) {
                    let nextIndex = indexToRemove >= playQueue.length ? 0 : indexToRemove;
                    currentQueueIndex = nextIndex - 1;
                    playNextSong();
                } else {
                    resetPlayer();
                }
            } else {
                playQueue.splice(indexToRemove, 1);
                if (indexToRemove < currentQueueIndex) currentQueueIndex--;
            }
            renderQueue();
        });
    });
}

function makeQueueItemsDraggable() {
    const container = document.querySelector('.queue-list-container');
    if (!container) return;
    let draggedQueueItem = null;

    // Touch variables
    let touchTimeout;
    let isTouchDragging = false;
    let touchGhost = null;
    let touchStartY = 0;

    const items = container.querySelectorAll('.queue-item');

    items.forEach(item => {
        // --- Desktop Drag & Drop (HTML5 API) ---
        item.setAttribute('draggable', 'true');
        
        item.addEventListener('dragstart', () => {
            draggedQueueItem = item;
            setTimeout(() => item.classList.add('dragging'), 0);
        });

        item.addEventListener('dragend', () => {
            if (draggedQueueItem) {
                draggedQueueItem.classList.remove('dragging');
                draggedQueueItem = null;
                updateQueueFromDOM();
            }
        });

        // --- Mobile Touch Drag & Drop ---
        item.addEventListener('touchstart', (e) => {
            // Ignore if touching interactive controls inside the row
            if (e.target.closest('button')) return;

            touchStartY = e.touches[0].clientY;
            
            // Long press (250ms) triggers drag mode
            touchTimeout = setTimeout(() => {
                isTouchDragging = true;
                item.classList.add('dragging');
                
                // Visual Feedback: Vibration
                if (navigator.vibrate) navigator.vibrate(50);
                
                // Create Ghost Element for visual tracking
                touchGhost = item.cloneNode(true);
                touchGhost.style.position = 'fixed';
                touchGhost.style.zIndex = '9999';
                touchGhost.style.pointerEvents = 'none';
                touchGhost.style.opacity = '0.9';
                touchGhost.style.transform = 'scale(1.05)';
                touchGhost.style.boxShadow = '0 10px 20px rgba(0,0,0,0.3)';
                touchGhost.style.background = 'var(--search-background)';
                touchGhost.style.width = `${item.offsetWidth}px`;
                touchGhost.style.borderRadius = '16px';
                
                // Position ghost at finger location (or original element location initially)
                const rect = item.getBoundingClientRect();
                touchGhost.style.top = `${rect.top}px`;
                touchGhost.style.left = `${rect.left}px`;
                
                document.body.appendChild(touchGhost);
            }, 250); 
            
        }, { passive: false });

        item.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            
            if (!isTouchDragging) {
                // If user moves finger significantly before timeout, it's a scroll operation
                if (Math.abs(touch.clientY - touchStartY) > 5) {
                    clearTimeout(touchTimeout);
                }
                return;
            }

            // We are dragging, prevent browser scrolling
            if (e.cancelable) e.preventDefault(); 
            
            // Move Ghost
            if (touchGhost) {
                touchGhost.style.top = `${touch.clientY - (touchGhost.offsetHeight / 2)}px`;
                touchGhost.style.left = `${touch.clientX - (touchGhost.offsetWidth / 2)}px`;
            }
            
            // Live Reordering Logic
            // The item being dragged (.dragging) is excluded from getDragAfterElement queries
            const afterElement = getDragAfterElement(container, touch.clientY);
            if (afterElement == null) {
                container.appendChild(item);
            } else {
                container.insertBefore(item, afterElement);
            }
        }, { passive: false });

        const endTouchDrag = () => {
            clearTimeout(touchTimeout);
            if (isTouchDragging) {
                isTouchDragging = false;
                item.classList.remove('dragging');
                if (touchGhost) {
                    touchGhost.remove();
                    touchGhost = null;
                }
                updateQueueFromDOM();
            }
        };

        item.addEventListener('touchend', endTouchDrag);
        item.addEventListener('touchcancel', endTouchDrag);
    });

    container.addEventListener('dragover', e => {
        e.preventDefault();
        const afterElement = getDragAfterElement(container, e.clientY);
        if (afterElement == null) {
            container.appendChild(draggedQueueItem);
        } else {
            container.insertBefore(draggedQueueItem, afterElement);
        }
    });
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.queue-item:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function updateQueueFromDOM() {
    isQueueUserModified = true; 
    const newQueueOrder = [];
    document.querySelectorAll('.queue-item').forEach(item => {
        const songId = parseFloat(item.dataset.id);
        const song = playQueue.find(s => s.id === songId);
        if (song) newQueueOrder.push(song);
    });

    playQueue = newQueueOrder;
    currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);

    // Check if an autoplay song was moved to be next
    if (currentQueueIndex + 1 < playQueue.length) {
        const nextSongId = playQueue[currentQueueIndex + 1].id;
        if (autoplaySongIds.has(nextSongId)) {
            autoplaySongIds.delete(nextSongId);
        }
    }
    
    isShuffleEnabled = false;
    updateShuffleButtonState();
    
    renderQueue();
}
        
async function playNextSong({ userInitiated = false, isTransition = false } = {}) {
    if (userInitiated) {
        const timeListened = (Date.now() - lastSongStartTime) / 1000;
        if (timeListened < 30) {
            consecutiveRapidSkips++;
            console.log(`Rapid skip detected (${timeListened.toFixed(1)}s). Streak: ${consecutiveRapidSkips}`);
        } else {
            consecutiveRapidSkips = 0;
        }
    } else {
        // Natural end of song reset
        consecutiveRapidSkips = 0;
    }
        
    if (userInitiated && repeatMode === 'one') toggleRepeat();
    if (!userInitiated && !isTransition && repeatMode === 'one') {
        audioPlayer.currentTime = 0;
        audioPlayer.play().catch(e => console.error("Repeat-one playback failed", e));
        return;
    }
    if (!playQueue || playQueue.length === 0) return;
    
    currentQueueIndex++;

    // Infinite Radio Scroll
    if (isRadioMode && playQueue.length - currentQueueIndex < 5) {
        console.log("Radio running low, fetching more...");
        appendRadioTracks(); 
    }
    
    // If we have reached the end of the queue AND autoplay is enabled...
    if (isAutoplayEnabled && currentQueueIndex >= playQueue.length) {
        // ...await the generation of new songs. This ensures the queue is populated
        // before the function continues. The generate function already handles clearing old songs.
        await generateAutoplaySongs(); 
    }

    if (currentQueueIndex >= playQueue.length) {
        if (repeatMode === 'all') currentQueueIndex = 0;
        else {
            resetPlayer();
            return;
        }
    }

    const nextSong = playQueue[currentQueueIndex];
    if (nextSong) {
        // **THE FIX:** Check song type and call the correct function
        if (nextSong.storage === 'tidal') {
            playtidalTrack(nextSong.id);
        } else {
            playSong(nextSong, { isTransition });
        }
        proactivelyCacheNextInQueue();
    }
}
        
function playPreviousSong() {
    // 6. Feature: Restricted Controls (No Rewind in Radio)
    if (isRadioMode) {
        showToast("Cannot rewind in Radio");
        return;
    }

    if (repeatMode === 'one') toggleRepeat();
    if (!playQueue.length) return;
    if (audioPlayer.currentTime > 5) {
        audioPlayer.currentTime = 0;
        audioPlayer.play().catch(e => console.error("Restart playback failed", e));
        return;
    }
    currentQueueIndex--;
    if (currentQueueIndex < 0) {
        currentQueueIndex = (repeatMode === 'all') ? playQueue.length - 1 : 0;
    }

    const prevSong = playQueue[currentQueueIndex];
    if (prevSong) {
        // **THE FIX:** Check song type and call the correct function
        if (prevSong.storage === 'tidal') {
            playtidalTrack(prevSong.id);
        } else {
            playSong(prevSong, { isTransition: false });
        }
        proactivelyCacheNextInQueue();
    }
}

function cleanupBlobs() {
    songs.forEach(song => {
        if (song.url) URL.revokeObjectURL(song.url);
    });
}
   
function toggleShuffle() {
    isShuffleEnabled = !isShuffleEnabled;
    document.getElementById("shuffleBtn").classList.toggle("active", isShuffleEnabled);

    if (playQueue.length <= 1) return; // No need to shuffle if queue is small

    if (isShuffleEnabled) {
        // When shuffle is turned ON, shuffle the current queue but keep the playing song at the top.
        const currentSong = playQueue[currentQueueIndex];
        let songsToShuffle = playQueue.filter(song => song.id !== currentSongId);
        
        shuffleArray(songsToShuffle); // Use the utility function we added previously

        // Rebuild the queue with the current song first, followed by the shuffled list.
        playQueue = [currentSong, ...songsToShuffle];
        currentQueueIndex = 0; // The current song is now at the start of the shuffled queue.
        isQueueUserModified = true; // Shuffling is a user modification of the queue order.
    }
    // Note: When shuffle is turned OFF, we do not re-sort the queue. It remains in its
    // current shuffled order until a new song/album is played.

    // Re-render the queue panel if it's open to show the new shuffled order.
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
}

function updateShuffleButtonState() {
    document.getElementById("shuffleBtn").classList.toggle("active", isShuffleEnabled);
}
        
function toggleRepeat() {
    const repeatBtn = document.getElementById('repeatBtn');
    switch(repeatMode) {
        case 'none':
            repeatMode = 'all';
            repeatBtn.innerHTML = '<span class="material-symbols-rounded">repeat</span>';
            repeatBtn.classList.add('active');
            break;
        case 'all':
            repeatMode = 'one';
            repeatBtn.innerHTML = '<span class="material-symbols-rounded">repeat_one</span>';
            break;
        case 'one':
            repeatMode = 'none';
            repeatBtn.innerHTML = '<span class="material-symbols-rounded">repeat</span>';
            repeatBtn.classList.remove('active');
            break;
    }
}
    
function updatePlayQueue() {
    if (isQueueUserModified) {
        currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
        // Corrected check: if the queue panel is visible, re-render it
        if (isPanelVisible && panelContent === 'queue') {
            renderQueue();
        }
        return;
    }

    if (isShuffleEnabled) {
        let availableSongs = [...songs];
        let currentSong = currentSongId ? availableSongs.find(s => s.id === currentSongId) : null;
        if (currentSong) availableSongs = availableSongs.filter(s => s.id !== currentSongId);
        
        for (let i = availableSongs.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [availableSongs[i], availableSongs[j]] = [availableSongs[j], availableSongs[i]];
        }
        playQueue = currentSong ? [currentSong, ...availableSongs] : availableSongs;
    } else {
        const sortedSongs = [...songs].sort((a, b) => {
            const albumCompare = (a.albumArtist || '').localeCompare(b.albumArtist || '') 
                            || (a.album || '').localeCompare(b.album || '');
            if (albumCompare !== 0) return albumCompare;
            const discCompare = (a.effectiveDiscNumber || 1) - (b.effectiveDiscNumber || 1);
            if (discCompare !== 0) return discCompare;
            return (a.trackNumber || 0) - (b.trackNumber || 0);
        });
        playQueue = sortedSongs;
    }
    
    currentQueueIndex = playQueue.findIndex(s => s.id === currentSongId);
    // Corrected check: if the queue panel is visible, re-render it
    if (isPanelVisible && panelContent === 'queue') {
        renderQueue();
    }
}
        
function groupSongsByAlbum(songsToRender) {
  const albums = {};
  
  songsToRender.forEach(song => {
    const albumArtistName = song.albumArtist || song.artist || 'Unknown Artist';
    const albumName = song.album || 'Unknown Album';
    const albumKey = `${albumArtistName}::${albumName}::${song.effectiveDiscNumber}`;

    if (!albums[albumKey]) {
      const albumDisplayName = song.effectiveDiscNumber > 1 ? `${albumName} (Disc ${song.effectiveDiscNumber})` : albumName;
      albums[albumKey] = {
        name: albumDisplayName,
        artist: albumArtistName,
        year: song.year,
        albumArt: song.albumArt,
        songs: [],
        originalAlbum: albumName,
        originalAlbumArtist: albumArtistName,
        effectiveDiscNumber: song.effectiveDiscNumber,
        dateAdded: 0 
      };
    }
    albums[albumKey].songs.push(song);
  });
  
  for (let key in albums) {
      albums[key].dateAdded = Math.max(...albums[key].songs.map(s => s.dateAdded || 0));
      albums[key].songs.sort((a, b) => (a.trackNumber || 0) - (b.trackNumber || 0));
  }
  
  let albumArray = Object.values(albums);
  
  if (currentSortMode === 'dateAdded') {
      albumArray.sort((a, b) => b.dateAdded - a.dateAdded);
  } else { // 'alpha'
      albumArray.sort((a, b) => {
         const artistCompare = a.originalAlbumArtist.localeCompare(b.originalAlbumArtist);
         if (artistCompare !== 0) return artistCompare;
         const albumCompare = a.originalAlbum.localeCompare(b.originalAlbum);
         if (albumCompare !== 0) return albumCompare;
         return a.effectiveDiscNumber - b.effectiveDiscNumber;
      });
  }
  return albumArray;
}

async function updateMediaSessionMetadata(song) {
    if (!('mediaSession' in navigator)) return;

    // Phase 1: Immediately update text metadata, reusing the old artwork temporarily.
    // This prevents the notification from disappearing.
    const metadata = {
        title: song.name + getExplicitBadge(song.explicit),
        artist: song.artist,
        album: song.album,
    };

    const temporaryArtworkSrc = currentMediaSessionArtBlobUrl || song.albumArt;
    
    navigator.mediaSession.metadata = new MediaMetadata({
        ...metadata,
        artwork: [{ src: temporaryArtworkSrc, sizes: '512x512', type: 'image/png' }]
    });

    // Phase 2: Asynchronously create the new blob URL and update the artwork.
    const oldBlobUrl = currentMediaSessionArtBlobUrl;
    let newBlobUrl = null;

    if (song.albumArt) {
        try {
            let urlToFetch = song.albumArt;
            // If it's a resizable TIDAL URL, get a smaller version to avoid CORS issues
            if (urlToFetch.includes('resources.tidal.com/images/')) {
                urlToFetch = urlToFetch.replace(/\/\d+x\d+\.jpg$/, '/320x320.jpg');
            }
            const response = await fetch(urlToFetch);
            const blob = await response.blob();
            newBlobUrl = URL.createObjectURL(blob);
        } catch (e) {
            console.error("Failed to create blob URL for media session artwork", e);
        }
    }
    
    currentMediaSessionArtBlobUrl = newBlobUrl;

    // Update the metadata again, this time with the final, correct artwork.
    const finalArtworkSrc = newBlobUrl || song.albumArt;
    navigator.mediaSession.metadata = new MediaMetadata({
        ...metadata,
        artwork: [
            { src: finalArtworkSrc, sizes: '96x96', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '128x128', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '192x192', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '256x256', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '384x384', type: 'image/png' },
            { src: finalArtworkSrc, sizes: '512x512', type: 'image/png' },
        ]
    });

    // 10 seconds to allow the OS/Browser to fully consume the blob.
    // Revoking too early causes the "Not allowed to load" error in console.
    if (oldBlobUrl && oldBlobUrl !== newBlobUrl) {
        setTimeout(() => {
            URL.revokeObjectURL(oldBlobUrl);
        }, 10000); 
    }
}

function updateMediaSessionPlaybackState(state) {
    if ('mediaSession' in navigator) navigator.mediaSession.playbackState = state;
}

function updateMediaSessionPositionState() {
    if (!('mediaSession' in navigator) || !isFinite(audioPlayer.duration)) return;
    try {
        navigator.mediaSession.setPositionState({
            duration: audioPlayer.duration,
            playbackRate: audioPlayer.playbackRate,
            position: audioPlayer.currentTime,
        });
    } catch (error) {
        console.error("Error setting media session position state:", error);
    }
}

function setupMediaSessionActions() {
    if (!('mediaSession' in navigator)) return;

    navigator.mediaSession.setActionHandler('play', () => playPauseBtn.click());
    navigator.mediaSession.setActionHandler('pause', () => playPauseBtn.click());
    navigator.mediaSession.setActionHandler('nexttrack', () => playNextSong({ userInitiated: true }));
    navigator.mediaSession.setActionHandler('previoustrack', () => playPreviousSong());
    navigator.mediaSession.setActionHandler('stop', () => resetPlayer());

    navigator.mediaSession.setActionHandler('seekforward', null);
    navigator.mediaSession.setActionHandler('seekbackward', null);
    navigator.mediaSession.setActionHandler('seekto', (d) => { audioPlayer.currentTime = d.seekTime; });
}

window.__onGCastApiAvailable = function(isAvailable) {
    if (isAvailable) {
        castPlayer = new cast.framework.RemotePlayer();
        castController = new cast.framework.RemotePlayerController(castPlayer);

        cast.framework.CastContext.getInstance().setOptions({
            receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
            autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
        });
        
        setupCastListeners();
    }
};

function setupCastListeners() {
    context.addEventListener(cast.framework.CastContextEventType.SESSION_STATE_CHANGED, (e) => {
        if (!castSession) return;
        // Sync Play/Pause icon
        playPauseIcon.textContent = castPlayer.isPaused ? 'play_arrow' : 'pause';
        playPauseBtn.classList.toggle('playing', !castPlayer.isPaused);
        updateMiniplayerUI(currentlyPlayingSong, castPlayer.isPaused ? 'paused' : 'playing');
        
        // Sync Progress
        const duration = castPlayer.duration || currentlyPlayingSong?.duration || 0;
        if (duration > 0) {
            const percent = (castPlayer.currentTime / duration) * 100;
            progress.style.width = `${percent}%`;
            updateTimeDisplays(castPlayer.currentTime, duration);
        }
    });
}

async function loadRemoteMedia() {
    if (!castSession || !currentlyPlayingSong) return;
    
    let streamUrl = currentlyPlayingSong.streamUrl;
    const isLocal = currentlyPlayingSong.storage !== 'tidal';

    if (isLocal) {
        streamUrl = await recoverMissingLocalSong(currentlyPlayingSong);
    } else if (!streamUrl) {
        const resolved = await resolveTidalUrl(currentlyPlayingSong);
        streamUrl = resolved?.url;
    }
    
    if (!streamUrl) {
        showToast("Casting for local files is not supported");
        return;
    }

    const mediaInfo = new chrome.cast.media.MediaInfo(streamUrl, 'audio/mp3');
    mediaInfo.metadata = new chrome.cast.media.MusicTrackMediaMetadata();
    mediaInfo.metadata.title = currentlyPlayingSong.name;
    mediaInfo.metadata.artist = currentlyPlayingSong.artist;
    mediaInfo.metadata.images = [{ url: currentlyPlayingSong.albumArt }];

    const request = new chrome.cast.media.LoadRequest(mediaInfo);
    castSession.getMediaSession()?.load(request);
}
        
window.addEventListener("beforeunload", () => {
    if (currentSongId !== null) {
        localStorage.setItem("currentSong", JSON.stringify({
            id: currentSongId,
            progress: audioPlayer.currentTime
        }));
    } else {
        localStorage.removeItem("currentSong");
    }
});

window.addEventListener("load", async () => {
    try {
        if (isMobile) {
            document.body.classList.add('is-mobile');
        }
        
        // Request Persistent Storage
        if (navigator.storage && navigator.storage.persist) {
            const isPersisted = await navigator.storage.persist();
            console.log(`Storage persistence granted: ${isPersisted}`);
        }

        await initDB();
        initModalVariables();

        if ('showDirectoryPicker' in window) {
            const tx = db.transaction('config', 'readonly');
            const handleReq = tx.objectStore('config').get('directoryHandles');
            const configResult = await new Promise(r => { handleReq.onsuccess = () => r(handleReq.result) });
            
            if (configResult && Array.isArray(configResult.value)) {
                const verifiedHandles = [];
                // **THE FIX IS HERE:** Check if the handles are valid before trying to use them.
                const storedHandles = configResult.value;
                for (const handle of storedHandles) {
                    // Plain objects from an import won't have the queryPermission method.
                    if (typeof handle.queryPermission === 'function') {
                        if (await verifyPermission(handle, false)) { // Don't prompt on load
                            verifiedHandles.push(handle);
                        }
                    } else {
                        console.warn(`Removed an invalid or restored folder handle: "${handle.name}". Please re-add the folder manually.`);
                    }
                }
                directoryHandles = verifiedHandles;

                // If some handles were invalid, update the database with the cleaned list.
                if (directoryHandles.length < storedHandles.length) {
                    alert("Some music folders need to be re-added after the system import.");
                    const writeTx = db.transaction('config', 'readwrite');
                    writeTx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
                    await writeTx.done;
                }
                console.log(`Restored and verified ${directoryHandles.length} folder handles.`);
            }
        }

        // --- Load tidal Settings ---
        const configTx = db.transaction('config', 'readonly');
        const scIdReq = configTx.objectStore('config').get('tidalClientId');
        const scEnabledReq = configTx.objectStore('config').get('istidalEnabled');
        const corsProxyReq = configTx.objectStore('config').get('isCorsProxyEnabled');
        const lrclibReq = configTx.objectStore('config').get('isLrclibEnabled'); 
        const qualityReq = configTx.objectStore('config').get('prefAudioQuality');
        const cacheReq = configTx.objectStore('config').get('enableSmartCache');
        const streamOnlyReq = configTx.objectStore('config').get('enableStreamOnly');
        const explicitReq = configTx.objectStore('config').get('hideExplicitContent');
            
        const scIdResult = await new Promise(r => { scIdReq.onsuccess = () => r(scIdReq.result) });
        const scEnabledResult = await new Promise(r => { scEnabledReq.onsuccess = () => r(scEnabledReq.result) });
        const corsProxyResult = await new Promise(r => { corsProxyReq.onsuccess = () => r(corsProxyReq.result) });
        const lrclibEnabledResult = await new Promise(r => { lrclibReq.onsuccess = () => r(lrclibReq.result) }); 
        const qualityRes = await new Promise(r => { qualityReq.onsuccess = () => r(qualityReq.result) });
        const cacheRes = await new Promise(r => { cacheReq.onsuccess = () => r(cacheReq.result) });
        const streamOnlyRes = await new Promise(r => { streamOnlyReq.onsuccess = () => r(streamOnlyReq.result) });
        
        // Load Google Client ID & Restore Session
        const gClientIdReq = configTx.objectStore('config').get('gDriveClientId');
        const gClientIdRes = await new Promise(r => { gClientIdReq.onsuccess = () => r(gClientIdReq.result) });
        
        if (gClientIdRes && gClientIdRes.value) {
            const savedId = gClientIdRes.value;
            document.getElementById('gDriveClientId').value = savedId;
            
            // Initialize Client
            if (typeof google !== 'undefined') {
                initGoogleClient(savedId);
                
                // Restore Token from Storage
                const storedToken = localStorage.getItem('gDriveToken');
                const storedExpiry = localStorage.getItem('gDriveExpiry');
                
                if (storedToken && storedExpiry) {
                    const expiryTime = parseInt(storedExpiry);
                    // Only restore if valid (or close to valid, let getValidToken handle refresh if old)
                    // We visually restore state even if expired, so the user sees "Connected"
                    gAccessToken = storedToken;
                    gTokenExpiry = expiryTime;
                    updateDriveUI(true);
                }
            }
        }

        tidalClientId = scIdResult ? scIdResult.value : '';
        istidalEnabled = scEnabledResult ? scEnabledResult.value : false;
        isCorsProxyEnabled = corsProxyResult ? corsProxyResult.value : false;
        isLrclibEnabled = lrclibEnabledResult ? lrclibEnabledResult.value : false;
        if(qualityRes) prefAudioQuality = qualityRes.value;
        if(cacheRes !== undefined) enableSmartCache = cacheRes.value;
        if(streamOnlyRes !== undefined) enableStreamOnly = streamOnlyRes.value;
        if(explicitReq.result !== undefined) hideExplicitContent = explicitReq.result.value;
        
        if (istidalEnabled) {
            await findFastestHifiEndpoint();
        }
        
        toggletidalTab();

        await loadSongsAndPlaylists();
        await scanForNewSongs();
        await migrateToFSA();

        const savedData = localStorage.getItem("currentSong");
        if (savedData) {
            const { id, progress } = JSON.parse(savedData);
            const song = songs.find(s => s.id === id);
            if (song) {
                currentSongId = song.id;
                currentlyPlayingSong = song;
                updatePlayerUI(song);
                updateMiniplayerUI(song, 'paused');
                playPauseIcon.textContent = 'play_arrow';
                playPauseBtn.classList.remove('playing');
                isQueueUserModified = false;
                updatePlayQueue();
                const fileUrl = await getSongFileUrl(song);
                if (fileUrl) {
                    audioPlayer.src = fileUrl;
                    audioPlayer.load();
                    audioPlayer.onloadedmetadata = () => {
                         audioPlayer.currentTime = progress || 0;
                         updateTimeDisplays();
                         audioPlayer.onloadedmetadata = null;
                    };
                }
            }
        }
        
        setView('home');
        initDistortionCanvas();
    } catch (error) {
        console.error('Critical error on application load:', error);
    }
});

async function verifyPermission(handle, shouldRequest = false) {
    const options = { mode: 'read' };
    if (await handle.queryPermission(options) === 'granted') return true;
    if (shouldRequest && await handle.requestPermission(options) === 'granted') return true;
    console.warn(`Permission not granted for folder: ${handle.name}`);
    return false;
}

async function openContextFromPlayer(type) {
    if (!currentlyPlayingSong) return;
    const s = currentlyPlayingSong;
    
    // We need to fetch basic info to get IDs if missing (Radio songs flattened metadata)
    if (s.storage === 'tidal') {
        // Try to derive IDs or search
        // This is complex because we flattened metadata. 
        // Simple fallback: Search for the Artist/Album
        const query = type === 'artist' ? s.artist : s.album;
        document.getElementById('tidalSearchInput').value = query;
        setView('tidal'); // Switch to Discover
        searchtidal(); // Trigger search
    }
}
        
        function updatePlayerUI(song, progress = 0) {
            // musicTitle.textContent = sanitize(song.name);
            // musicArtist.textContent = song.artist;
            musicTitle.innerHTML = `<span class="clickable" onclick="openContextFromPlayer('album')">${sanitize(song.name)}</span>${getExplicitBadge(song.explicit)}`;
            musicArtist.innerHTML = `<span class="clickable" onclick="openContextFromPlayer('artist')">${sanitize(song.artist)}</span>`;
            updateTimeDisplays(progress, audioPlayer.duration);

            const stableArtUrl = song.albumArt || 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
            if (albumArtImg.src !== stableArtUrl) {
                albumArtImg.src = stableArtUrl;
                albumArtImg.classList.remove('fade-out');
                updateAllBackgrounds(stableArtUrl);
                updateFavicon(stableArtUrl);
            }

            const statusEl = document.getElementById('player-status');
            if (statusEl) {
                if (isRadioMode) {
                    statusEl.textContent = 'Station';
                } else if (song.storage === 'tidal' && song.audioQuality === 'LOSSLESS') {
                    statusEl.textContent = 'Lossless';
                } else {
                    statusEl.textContent = '';
                }
            }

            // **MODIFICATION**: Prioritize the known (trimmed) duration from the song object
            const displayDuration = song.duration || audioPlayer.duration || 0;
            updateTimeDisplays(progress, displayDuration);
        }

        function updateTimeDisplays(current = 0, duration = 0) {
            currentTimeDisplay.textContent = formatTime(current);
            
            // Show remaining time instead of total duration
            if (isFinite(duration) && duration > 0) {
                const remaining = Math.max(0, duration - current);
                durationDisplay.textContent = '-' + formatTime(remaining);
            } else {
                durationDisplay.textContent = formatTime(duration);
            }
        }

let lastActiveIndex = -1;
let isUserScrollingLyrics = false;
let lyricsScrollTimeout = null;
let isProgrammaticScroll = false;

audioPlayer.addEventListener('timeupdate', async () => {
    if (currentSongId) {
        const song = currentlyPlayingSong;
        const duration = song.duration || audioPlayer.duration;
        const percentage = (audioPlayer.currentTime / duration) * 100;
        progress.style.width = `${percentage}%`;
        const scaledPercentage = (percentage / 100) * 90.5;
        miniplayerProgress.style.width = `${scaledPercentage}%`;
        updateTimeDisplays(audioPlayer.currentTime, audioPlayer.duration);
        updatePageTitle();

        // Only log plays for local songs
        if (song && song.storage !== 'tidal' && !song.hasBeenLogged && audioPlayer.currentTime > 30) {
            song.hasBeenLogged = true;
            await logSongPlay(song.id);
        }

        if ('mediaSession' in navigator) updateMediaSessionPositionState();
        if (crossfadeEnabled && audioPlayer.duration > 0 && audioPlayer.duration - audioPlayer.currentTime < 3 && !audioPlayer.isFading) {
             audioPlayer.isFading = true;
             playNextSong({ isTransition: true });
        }
        
        if (song && song.lrcData && song.lrcData.lyrics && isPanelVisible && panelContent === 'lyrics') {
            if (isUserScrollingLyrics) return; // Halt updates while user scrolls

            const currentTime = audioPlayer.currentTime;
            const allLyricElements = document.querySelectorAll('#lyrics-scroll-container p');
            if (allLyricElements.length === 0) return;

            // 1. Find the single active timestamp
            let activeTime = -1;
            allLyricElements.forEach(el => {
                const elTime = parseFloat(el.dataset.time);
                if (!isNaN(elTime) && elTime <= currentTime) {
                    activeTime = elTime;
                }
            });

            // 2. Find all indices that match this active time
            const activeIndices = [];
            if (activeTime > -1) {
                allLyricElements.forEach((el, index) => {
                    if (parseFloat(el.dataset.time) === activeTime) {
                        activeIndices.push(index);
                    }
                });
            }

            const referenceIndex = activeIndices.length > 0 ? activeIndices[0] : -1;

            if (referenceIndex !== lastActiveIndex) { // Check for change to prevent redundant updates
                const firstActiveIndex = activeIndices.length > 0 ? activeIndices[0] : -1;
                const lastActiveIndexInGroup = activeIndices.length > 0 ? activeIndices[activeIndices.length - 1] : -1;

                allLyricElements.forEach((el, index) => {
                    const isActive = activeIndices.includes(index);
                    let blur = 0;
                    let opacity = 1;

                    if (!isActive) {
                        if (index > lastActiveIndexInGroup) { // Lines below active group
                            const distance = index - lastActiveIndexInGroup;
                            if (distance >= 5) {
                                blur = 5; opacity = 0;
                            } else {
                                blur = distance * 1.25;
                                opacity = 1 - (distance * 0.25);
                            }
                        } else { // Lines above active group
                            const distance = firstActiveIndex - index;
                            if (distance >= 2) {
                                blur = 3; opacity = 0;
                            } else { // distance is 1
                                blur = 1.5; opacity = 0.5;
                            }
                        }
                    }

                    el.style.filter = `blur(${blur}px)`;
                    el.style.opacity = opacity;
                });

                const activeElement = allLyricElements[referenceIndex];
                if (activeElement) {
                    isProgrammaticScroll = true;
                    activeElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // After a delay, reset the flag so user scrolls work again
                    setTimeout(() => { isProgrammaticScroll = false; }, 500);
                }
                lastActiveIndex = referenceIndex;
            }
        }
    }
});
        
playPauseBtn.addEventListener('click', async () => {
    // Only attempt to resume AudioContext on non-iOS devices
    if (!isIOS && audioContext && audioContext.state === 'suspended') {
        await audioContext.resume();
    }
    if (!currentSongId) return;

    if (!isVisualizerInitialized) initVisualizer();

    if (castSession) {
        castController.playPause();
        return;
    }
    if (audioPlayer.paused) {
        if ('mediaSession' in navigator && navigator.mediaSession.metadata === null) {
            const song = currentlyPlayingSong;
            if (song) {
                updateMediaSessionMetadata(song);
            }
        }
        audioPlayer.play().catch(error => console.error("Play failed:", error));
    } else {
        audioPlayer.pause();
    }
});
        
nextBtn.addEventListener('click', async () => {
    if (castSession) castController.stop(); 
    await playNextSong({ userInitiated: true });
});
prevBtn.addEventListener('click', () => {
    if (castSession) castController.stop();
    playPreviousSong();
});

function seekAudio(e) {
    const duration = castSession ? castPlayer.duration : audioPlayer.duration;
    if(!isFinite(duration) || duration <= 0) return;

    const rect = progressBar.getBoundingClientRect();
    const clickX = Math.max(0, Math.min(e.clientX, rect.right)) - rect.left;
    const percent = Math.max(0, Math.min(1, clickX / rect.width));
    const seekTime = percent * duration;

    if (castSession) {
        castPlayer.currentTime = seekTime;
        castController.seek();
    } else {
        audioPlayer.currentTime = seekTime;
    }
}
        
function handleProgressDrag(e) { if (isDragging) seekAudio(e.touches ? e.touches[0] : e); }

function closePanel() {
    if (!isPanelVisible) return;
    isPanelVisible = false;
    
    document.getElementById('now-playing-view').classList.remove('panel-is-open');

    // Remove the 'visible' class from the panel
    document.getElementById('lyrics-queue-panel').classList.remove('visible');
    
    // Remove the 'active' class from the buttons
    document.querySelector('.lyrics-button').classList.remove('active');
    document.querySelector('.queue-button').classList.remove('active');
    
    // Update the .now-playing-wrapper styles
    const nowPlayingWrapper = document.querySelector('.now-playing-wrapper');
    if (nowPlayingWrapper) {
        nowPlayingWrapper.style.padding = '5px';
        nowPlayingWrapper.style.alignItems = 'center';
    }
}
        
progressBar.addEventListener("click", e => seekAudio(e));
progressBar.addEventListener("mousedown", () => { isDragging = true; });
document.addEventListener("mouseup", () => { isDragging = false; });
document.addEventListener("mousemove", e => handleProgressDrag(e));
progressBar.addEventListener("touchstart", () => { isDragging = true; }, { passive: true });
document.addEventListener("touchend", () => { isDragging = false; });
document.addEventListener("touchmove", e => handleProgressDrag(e), { passive: true });

audioPlayer.addEventListener('pause', () => {
    const nowPlayingView = document.getElementById('now-playing-view');
    if(nowPlayingView) nowPlayingView.classList.add('paused');
    
    playPauseIcon.textContent = 'play_arrow';
    playPauseBtn.classList.remove('playing');
    updateMiniplayerUI(currentlyPlayingSong, 'paused');
    updateMediaSessionPlaybackState('paused');
});

audioPlayer.addEventListener('play', () => {
    const nowPlayingView = document.getElementById('now-playing-view');
    if(nowPlayingView) nowPlayingView.classList.remove('paused');

    playPauseIcon.textContent = 'pause';
    playPauseBtn.classList.add('playing');
    updateMiniplayerUI(currentlyPlayingSong, 'playing');
    updateMediaSessionPlaybackState('playing');

    if (!document.body.classList.contains('reduce-animations')) {
    }
});

audioPlayer.addEventListener('ended', () => {
    audioPlayer.isFading = false;
    playNextSong(); 
});

audioPlayer.addEventListener('durationchange', updateMediaSessionPositionState);
audioPlayer.addEventListener('loadedmetadata', updateMediaSessionPositionState);

document.addEventListener('DOMContentLoaded', async () => {
    try {
        await initDB();
        searchInput = document.getElementById('searchInput');
        const musicUploadInput = document.getElementById('musicUpload');
        const libraryGrid = document.getElementById('library-grid');
        
        searchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                if (activeView === 'search') {
                    renderSearchResults();
                }
            }, 300);
        });

        document.getElementById('search-results-grid').addEventListener('click', (e) => {
            const songItem = e.target.closest('.music-item[data-id]');
            if (songItem) {
                const songId = parseFloat(songItem.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    // Get context from the search results
                    const contextSongs = Array.from(document.querySelectorAll('#search-results-grid .music-item[data-id]'))
                        .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                        .filter(Boolean);

                    isShuffleEnabled = false; 
                    updateShuffleButtonState();
                    
                    playSong(song, contextSongs);
                }
            }
        });
    
        document.getElementById('radioSearchInput').addEventListener('change', (e) => {
            if(e.target.value.trim()) startRadio('query', e.target.value.trim());
        });
    
        
        document.getElementById('home-view').addEventListener('click', (e) => {
            const highlightCard = e.target.closest('.highlight-card[data-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
    
            if (highlightCard) {
                const songId = parseFloat(highlightCard.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    // Play this single song as its own context
                    playSong(song, [song]);
                }
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const [artist, albumName] = albumId.split('::');
                // When playing from a "Recently Played" album card, play the first song of that album
                const songToPlay = songs.find(s => s.albumArtist === artist && s.album === albumName);
                if(songToPlay) {
                    // The context is all songs from that album
                    const albumContext = songs.filter(s => s.albumArtist === artist && s.album === albumName);
                    playSong(songToPlay, albumContext);
                }
            }
        });

        libraryGrid.addEventListener('click', (e) => {
            const songItem = e.target.closest('.music-item[data-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
            const artistCard = e.target.closest('.item-card[data-artist-name]');
            const playlistCard = e.target.closest('.item-card[data-playlist-id]');

            if (songItem) {
                const songId = parseFloat(songItem.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    // Get the context from the currently displayed list
                    const contextSongs = Array.from(libraryGrid.querySelectorAll('.music-item[data-id]'))
                        .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                        .filter(Boolean);
                    isShuffleEnabled = false; 
                    updateShuffleButtonState();
                    playSong(song, contextSongs);
                }
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const [artist, albumName] = albumId.split('::');
                // When an album is clicked from the main library view, show its tracks.
                openLocalAlbumView(artist, albumName);
            } else if (artistCard) {
                const artistName = artistCard.dataset.artistName;
                const artistAlbums = groupSongsByAlbum(songs.filter(s => s.artist === artistName));
                const contentHtml = `<div class="item-grid">${artistAlbums.map(album => `
                    <div class="item-card" data-album-id="${album.artist}::${album.originalAlbum}">
                        <img src="${album.albumArt}" alt="${album.name}" class="item-card-art">
                        <div class="item-card-info">
                            <div class="item-card-title">${sanitize(album.name)}</div>
                        </div>
                    </div>`).join('')}</div>`;
                openDrawer(artistName, `${artistAlbums.length} albums`, contentHtml); // Pass details
            } else if (playlistCard) {
                 const playlistId = parseInt(playlistCard.dataset.playlistId, 10);
                 const playlist = playlists.find(p => p.id === playlistId);
                 const playlistSongs = playlist.songIds.map(id => songs.find(s => s.id === id)).filter(Boolean);
                 
                // Render with Remove Buttons & Drag Handles
                 const contentHtml = `<div class="item-list" id="playlist-items-container">${playlistSongs.map(song => `
                    <div class="music-item playlist-item" data-id="${song.id}" style="cursor: pointer;">
                         <div class="song-info">
                            <div class="playlist-drag-handle">
                                <span class="material-symbols-rounded">drag_handle</span>
                            </div>
                            <img src="${song.albumArt}" class="album-thumbnail" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 6px;">
                            <div>
                                <div class="song-title">${sanitize(song.name)}</div>
                                <div class="album-artist" style="font-size: 0.8em;">${sanitize(song.artist)}</div>
                            </div>
                            <button class="song-item-actions" onclick="event.stopPropagation(); removeSongFromPlaylist(${song.id}, ${playlistId}, event)">
                                <span class="material-symbols-rounded" style="font-size: 20px;">do_not_disturb_on</span>
                            </button>
                        </div>
                    </div>`).join('')}</div>`;
                
                openDrawer(playlist.name, `${playlistSongs.length} songs`, contentHtml, { type: 'playlist', id: playlistId });
            }
        });

        drawerContent.addEventListener('click', (e) => {
            const localSongItem = e.target.closest('.music-item[data-id]');
            const tidalSongItem = e.target.closest('.music-item[data-track-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
            const backButton = e.target.closest('.drawer-back-btn'); // Correctly find the button

            if (backButton) {
                const artistName = backButton.dataset.artistName;
                const artistAlbums = groupSongsByAlbum(songs.filter(s => s.albumArtist === artistName));
                const contentHtml = `<div class="item-grid">${artistAlbums.map(album => {
                    const albumId = `${album.artist}::${album.originalAlbum}`;
                    return `
                    <div class="item-card" data-album-id="${sanitize(albumId)}">
                        <img src="${album.albumArt}" alt="${sanitize(album.name)}" class="item-card-art">
                        <div class="item-card-info">
                            <div class="item-card-title">${sanitize(album.name)}</div>
                        </div>
                    </div>`;
                }).join('')}</div>`;
                openDrawer(sanitize(artistName), `${artistAlbums.length} albums`, contentHtml);
            } else if (localSongItem) {
                // Logic for playing a local song from the library
                const songId = parseFloat(localSongItem.dataset.id);
                const song = songs.find(s => s.id === songId);
                if (song) {
                    const contextSongs = Array.from(drawerContent.querySelectorAll('.music-item[data-id]'))
                        .map(item => songs.find(s => s.id === parseFloat(item.dataset.id)))
                        .filter(Boolean);
                    playSong(song, contextSongs.length > 0 ? contextSongs : [song]);
                    closeDrawer();
                }
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const albumName = albumCard.dataset.albumName;
                const artistName = albumCard.dataset.albumArtistName;

                // Check if the albumId is a number (TIDAL) or a string (Local)
                if (!isNaN(parseFloat(albumId)) && isFinite(albumId)) {
                    // It's a numerical ID, so it's a TIDAL album.
                    openAlbumView(albumId, albumName, artistName);
                } else {
                    // It's a string like "Artist::Album", so it's a LOCAL album.
                    const [localArtist, localAlbum] = albumId.split('::');
                    openLocalAlbumView(localArtist, localAlbum);
                }
            } else if (tidalSongItem) {
                const trackId = tidalSongItem.dataset.trackId;
                const playContext = currentDrawerContext.map(track => ({
                    id: track.id,
                    name: track.title,
                    artist: track.artist.name,
                    album: track.album.title,
                    albumArt: getHighResArtwork(track.album.cover),
                    storage: 'tidal',
                    duration: track.duration,
                    audioQuality: track.audioQuality
                }));
                playtidalTrack(trackId, playContext);
                closeDrawer();
            }
        });

        document.getElementById('uploadBtn').addEventListener('click', async () => {
            if ('showDirectoryPicker' in window) {
                try {
                    const handle = await window.showDirectoryPicker();
                    if (await verifyPermission(handle, true)) {
                        directoryHandles.push(handle);
                        const tx = db.transaction('config', 'readwrite');
                        tx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
                        await tx.done;
                        await processDirectory(handle);
                    }
                } catch (err) {
                    if (err.name !== 'AbortError') console.error('Error picking directory:', err);
                }
            } else {
                musicUploadInput.click();
            }
        });

        musicUploadInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) addSongs(e.target.files, 'indexeddb');
        });
        
        document.querySelectorAll('.filter-container .filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelector('.filter-container .filter-btn.active').classList.remove('active');
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
                if (activeView === 'library') renderLibraryPage();
            });
        });

        const sortBtn = document.getElementById('sortBtn');
        const sortModeDisplay = document.getElementById('sort-mode-display');

        sortBtn.addEventListener('click', () => {
            // Toggle the sort mode
            currentSortMode = currentSortMode === 'alpha' ? 'dateAdded' : 'alpha';
            
            // Update the button's appearance
            if (currentSortMode === 'alpha') {
                sortBtn.innerHTML = `<span class="material-symbols-rounded">sort_by_alpha</span><span id="sort-mode-display"></span>`;
            } else {
                sortBtn.innerHTML = `<span class="material-symbols-rounded">history</span><span id="sort-mode-display"></span>`;
            }
            
            // Re-render the library with the new sorting
            renderLibraryPage();
        });

        // ADD listener for the new "Save to Library" button
        document.getElementById('menuSaveToLibrary').addEventListener('click', () => {
            savetidalTrackToLibrary();
            moreOptionsMenu.classList.remove('visible');
        });
    
        // ADD listener for the offline search input
        document.getElementById('tidalOfflineSearchInput').addEventListener('input', renderOfflinetidalView);
    
        // ADD listeners for the new filter buttons
        document.getElementById('tidal-filter-container').addEventListener('click', (e) => {
            const btn = e.target.closest('.filter-btn-sc');
            if (btn) {
                document.querySelector('#tidal-filter-container .filter-btn-sc.active').classList.remove('active');
                btn.classList.add('active');
                tidalFilter = btn.dataset.filter;
                searchtidal();
            }
        });

        document.body.addEventListener('click', async (e) => {
            if (e.target.closest('#drawer-delete-playlist-btn')) {
                const button = e.target.closest('#drawer-delete-playlist-btn');
                const playlistId = parseInt(button.dataset.playlistId, 10);
                if (playlistId) deletePlaylist(playlistId);
            }
            
            if (e.target.closest('#drawer-rename-playlist-btn')) {
                const button = e.target.closest('#drawer-rename-playlist-btn');
                const playlistId = parseInt(button.dataset.playlistId, 10);
                if (playlistId) renamePlaylist(playlistId);
            }

            if (e.target.closest('#drawer-edit-playlist-btn')) {
                const button = e.target.closest('#drawer-edit-playlist-btn');
                const playlistId = parseInt(button.dataset.playlistId, 10);
                if (playlistId) togglePlaylistEditMode(playlistId);
            }
        });

        async function renamePlaylist(playlistId) {
            const playlist = playlists.find(p => p.id === playlistId);
            if (!playlist) return;
            
            const newName = prompt("Rename playlist:", playlist.name);
            if (newName && newName.trim() && newName !== playlist.name) {
                playlist.name = newName.trim();
                const tx = db.transaction('playlists', 'readwrite');
                tx.objectStore('playlists').put(playlist);
                await tx.done;
                triggerAutoSync();
                
                document.getElementById('drawer-title').textContent = playlist.name;
                showToast("Playlist renamed");
                if (activeView === 'library') renderLibraryPage();
            }
        }
        
        setupLongPressListeners(document.getElementById('library-grid'));
        setupLongPressListeners(document.getElementById('search-results-grid'));
        setupLongPressListeners(drawerContent);

        initVisualizer();
        setupMediaSessionActions();

        document.getElementById('shuffleBtn').addEventListener('click', toggleShuffle);
        document.getElementById('repeatBtn').addEventListener('click', toggleRepeat);

        const lyricsQueuePanel = document.getElementById('lyrics-queue-panel');
        isPanelVisible = false;
        panelContent = null; // 'lyrics' or 'queue'

        const togglePanel = (newContent) => {
            const nowPlayingView = document.getElementById('now-playing-view');
            if (isPanelVisible && panelContent === newContent) {
                closePanel();
            } else {
                // Show or switch the panel
                isPanelVisible = true;
                panelContent = newContent;
                
                nowPlayingView.classList.add('panel-is-open');

                if (panelContent === 'lyrics') {
                    renderLyrics();
                } else {
                    renderQueue();
                    scrollToCurrentSongInQueue();
                }
                
                lyricsQueuePanel.classList.add('visible');

                // Only modify .now-playing-wrapper if viewport is 1251px or larger
                const nowPlayingWrapper = document.querySelector('.now-playing-wrapper');
                if (nowPlayingWrapper && window.innerWidth >= 1251) {
                    nowPlayingWrapper.style.setProperty('padding', '5px 20px 5px 5px', 'important');
                    nowPlayingWrapper.style.setProperty('align-items', 'flex-end', 'important');
                }
            }
            
            document.querySelector('.lyrics-button').classList.toggle('active', isPanelVisible && panelContent === 'lyrics');
            document.querySelector('.queue-button').classList.toggle('active', isPanelVisible && panelContent === 'queue');
        };
        
        document.querySelector('.lyrics-button').addEventListener('click', () => togglePanel('lyrics'));
        document.querySelector('.queue-button').addEventListener('click', () => togglePanel('queue'));
                
        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                if (isDrawerOpen) {
                    closeDrawer();
                    return; 
                }
                const viewName = btn.dataset.view;
                const currentViewElement = document.getElementById(`${activeView}-view`);
                if (currentViewElement) {
                    scrollPositions[activeView] = currentViewElement.scrollTop;
                }
                setView(viewName);
            });
        });
    
        miniplayer.addEventListener('click', (e) => {
            if (e.target.closest('.mini-control-btn')) return;
        
            const currentViewElement = document.getElementById(`${activeView}-view`);
            if (currentViewElement) {
                scrollPositions[activeView] = currentViewElement.scrollTop;
            }
        
            setView('now-playing');
        });
        
        // Wire up miniplayer controls
        miniplayerPlayBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            playPauseBtn.click();
        });
        document.getElementById('miniplayer-next-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            nextBtn.click();
        });
        document.getElementById('miniplayer-prev-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            prevBtn.click();
        });

        const nowPlayingView = document.getElementById('now-playing-view');
        const moreButton = nowPlayingView.querySelector('.more-button');
        const moreOptionsMenu = document.getElementById('moreOptionsMenu');

        moreButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!currentSongId || !currentlyPlayingSong) {
                showToast('No song is currently playing');
                return;
            }
            
            const isLocal = currentlyPlayingSong.storage !== 'tidal';
        
            // Show/hide menu items based on song type
            document.getElementById('menuEditMetadata').style.display = isLocal ? 'flex' : 'none';
            document.getElementById('menuDeleteSong').style.display = isLocal ? 'flex' : 'none';
            document.getElementById('menuAddToPlaylist').style.display = isLocal ? 'flex' : 'none';

            // Show "Save to Library" ONLY for tidal songs.
            document.getElementById('menuSaveToLibrary').style.display = isLocal ? 'none' : 'flex';
                    
            moreOptionsMenu.classList.toggle('visible');
        });

        document.addEventListener('click', (e) => {
            // Close menu if clicking outside of it or its trigger button
            if (!e.target.closest('#moreOptionsMenu') && !e.target.closest('.more-button')) {
                moreOptionsMenu.classList.remove('visible');
            }
        });

        document.getElementById('menuDeleteSong').addEventListener('click', async () => {
            if (currentSongId && await showConfirmDialog('Delete this song? This is permanent.')) await deleteSong(currentSongId);
            moreOptionsMenu.classList.remove('visible');
        });
        
        document.getElementById('menuFullscreenBtn').addEventListener('click', () => {
            isFullscreen = !isFullscreen; // Toggle the state
            toolbar.classList.toggle('hidden', isFullscreen); // Update toolbar based on new state
        
            // Toggle additional styles based on fullscreen state
            const albumArt = document.querySelector('.album-art');
            const playerControls = document.querySelector('.player-controls');
            
            if (albumArt) {
                albumArt.style.setProperty('margin-top', isFullscreen ? '0px' : '', 'important');
            }
            
            if (playerControls) {
                playerControls.style.display = isFullscreen ? 'none' : '';
            }
        
            if (volumeControl) {
                volumeControl.style.display = isFullscreen ? 'none' : '';
            }
        });
        
        document.getElementById('menuEditMetadata').addEventListener('click', () => { if (currentSongId) openEditModal(currentSongId); moreOptionsMenu.classList.remove('visible'); });
        document.getElementById('menuCrossfade').addEventListener('click', toggleCrossfade);
        document.getElementById('menuSleepTimer').addEventListener('click', () => { openModal(sleepTimerModal); moreOptionsMenu.classList.remove('visible'); });
        document.getElementById('menuAddToPlaylist').addEventListener('click', () => { if (currentSongId) openPlaylistModal(); moreOptionsMenu.classList.remove('visible'); });
        document.getElementById('menuEqualizer').addEventListener('click', () => { openModal(equalizerModal); moreOptionsMenu.classList.remove('visible'); });

        document.getElementById('shuffleBtn').addEventListener('click', toggleShuffle);
        document.getElementById('repeatBtn').addEventListener('click', toggleRepeat);

        document.getElementById('manageFoldersBtn').addEventListener('click', openManageFoldersModal);

        document.getElementById('saveIntegrations').addEventListener('click', async () => {
            // Save Google Client ID
            const gClientId = document.getElementById('gDriveClientId').value.trim();
            const tx = db.transaction('config', 'readwrite');
            tx.objectStore('config').put({ key: 'gDriveClientId', value: gClientId });
            await tx.done;
            saveIntegrationSettings();
        });

        document.getElementById('saveIntegrations').addEventListener('click', saveIntegrationSettings);

        // --- Library Export/Import Logic ---
        document.getElementById('exportLibraryBtn').addEventListener('click', async () => {
            try {
                showToast("Preparing library export...");
                
                const tx = db.transaction(['songs', 'playlists', 'playHistory'], 'readonly');
                const [songsData, playlistsData, historyData] = await Promise.all([
                    promiseIDBRequest(tx.objectStore('songs').getAll()),
                    promiseIDBRequest(tx.objectStore('playlists').getAll()),
                    promiseIDBRequest(tx.objectStore('playHistory').getAll())
                ]);

                const exportObj = {
                    version: 1,
                    timestamp: Date.now(),
                    source: 'Streams',
                    songs: songsData,
                    playlists: playlistsData,
                    history: historyData
                };

                const blob = new Blob([JSON.stringify(exportObj)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `streams-library-${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showToast("Library exported successfully");
            } catch (e) {
                console.error("Export failed:", e);
                showToast("Export failed");
            }
        });

        document.getElementById('importLibraryBtn').addEventListener('click', () => {
            document.getElementById('importLibraryInput').click();
        });

document.getElementById('importLibraryInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (!await showConfirmDialog("Importing will REPLACE your current library. All existing data will be lost. Continue?")) {
                e.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    showToast("Importing data...");
                    const data = JSON.parse(event.target.result);
                    
                    if (!data.songs || !Array.isArray(data.songs)) {
                        throw new Error("Invalid library file format");
                    }

                    const tx = db.transaction(['songs', 'playlists', 'playHistory'], 'readwrite');
                    
                    // 1. Clear existing data
                    await Promise.all([
                        tx.objectStore('songs').clear(),
                        tx.objectStore('playlists').clear(),
                        tx.objectStore('playHistory').clear()
                    ]);

                    // 2. Import Songs
                    const songStore = tx.objectStore('songs');
                    for (const song of data.songs) {
                        songStore.put(song);
                    }

                    // 3. Import Playlists
                    if (data.playlists) {
                        const plStore = tx.objectStore('playlists');
                        for (const pl of data.playlists) {
                            plStore.put(pl);
                        }
                    }

                    // 4. Import History
                    if (data.history) {
                        const histStore = tx.objectStore('playHistory');
                        for (const h of data.history) {
                            histStore.put(h);
                        }
                    }

                    await tx.done;
                    
                    // Refresh memory and UI
                    await loadSongsAndPlaylists();
                    if (activeView === 'library') renderLibraryPage();
                    if (activeView === 'home') renderHomePage();
                    
                    // Update lookups
                    updateLocalSongLookup(data.songs, { clear: true });
                    isrcToLocalSongMap.clear();
                    data.songs.forEach(song => {
                        if(song.isrc) isrcToLocalSongMap.set(song.isrc, song);
                    });

                    showToast(`Library restored. Starting downloads...`);
                    
                    // 5. Trigger download for Tidal tracks
                    restoreTidalDownloads(data.songs);
                    
                    closeModal(manageFoldersModal);

                } catch (err) {
                    console.error("Import error:", err);
                    showToast("Failed to import library file");
                }
                e.target.value = '';
            };
            reader.readAsText(file);
        });

        const tidalSearchInput = document.getElementById('tidalSearchInput');
        tidalSearchInput.addEventListener('input', () => {
            const val = tidalSearchInput.value.trim();
            const browseContainer = document.getElementById('tidal-browse-container');
            const resultsGrid = document.getElementById('tidal-results-grid');
            const controlsWrapper = document.getElementById('tidal-controls');

            if (!val) {
                if (browseContainer) browseContainer.style.display = 'block';
                if (resultsGrid) resultsGrid.style.display = 'none';
                if (controlsWrapper) controlsWrapper.style.display = 'none'; // Hide
                renderDiscoverBrowse();
                return;
            } else {
                if (browseContainer) browseContainer.style.display = 'none';
                if (resultsGrid) resultsGrid.style.display = 'grid';
                if (controlsWrapper) controlsWrapper.style.display = 'flex'; // Show
            }

            clearTimeout(tidalSearchTimeout);
            tidalSearchTimeout = setTimeout(searchtidal, 300);
        });
        
        document.getElementById('tidal-results-grid').addEventListener('click', e => {
            if (e.target && e.target.id === 'loadMoreBtn') {
                e.target.innerHTML = 'Loading...';
                e.target.disabled = true;
                searchtidal({ loadMore: true });
                return;
            }

            const trackCard = e.target.closest('.item-card[data-track-id]');
            const cachedCard = e.target.closest('.music-item[data-cached-id]');
            const artistCard = e.target.closest('.item-card[data-artist-id]');
            const albumCard = e.target.closest('.item-card[data-album-id]');
            const playlistCard = e.target.closest('.item-card[data-playlist-id]');
        
            if (trackCard) {
                const playContext = lasttidalSearchResults.map(track => ({
                    id: track.id,
                    name: track.title,
                    artist: track.artist.name,
                    album: track.album.title,
                    albumArt: getHighResArtwork(track.album.cover),
                    storage: 'tidal'
                }));
                playtidalTrack(trackCard.dataset.trackId, playContext);
            } else if (cachedCard) {
                const trackId = parseFloat(cachedCard.dataset.cachedId);
                const contextNodes = document.querySelectorAll('#tidal-results-grid .music-item[data-cached-id]');
                const playContext = Array.from(contextNodes).map(node => {
                    return {
                        id: parseFloat(node.dataset.cachedId),
                        name: node.querySelector('.song-title').textContent,
                        artist: node.querySelector('.album-artist').textContent,
                        albumArt: node.querySelector('img').src,
                        storage: 'tidal'
                    };
                });
                playtidalTrack(trackId, playContext);
            } else if (artistCard) {
                const artistId = artistCard.dataset.artistId;
                const artistName = artistCard.dataset.artistName;
                openArtistView(artistId, artistName);
            } else if (albumCard) {
                const albumId = albumCard.dataset.albumId;
                const albumName = albumCard.dataset.albumName;
                const artistName = albumCard.dataset.albumArtistName;
                openAlbumView(albumId, albumName, artistName);
            } else if (playlistCard) {
                const playlistId = playlistCard.dataset.playlistId;
                const playlistTitle = playlistCard.dataset.playlistTitle;
                openPlaylistView(playlistId, playlistTitle);
            }
        });

        // Add right-click support for Tidal View items
        document.getElementById('tidal-results-grid').addEventListener('contextmenu', e => {
            const trackCard = e.target.closest('.item-card[data-track-id]');
            const cachedCard = e.target.closest('.music-item[data-cached-id]');
            
            if (trackCard) {
                e.preventDefault();
                const trackId = parseFloat(trackCard.dataset.trackId);
                openSongContextMenu(trackCard, trackId, true);
            } else if (cachedCard) {
                e.preventDefault();
                const trackId = parseFloat(cachedCard.dataset.cachedId);
                openSongContextMenu(cachedCard, trackId, true);
            }
        });
    
        // Add the new listener for the offline toggle
        document.getElementById('tidalOfflineToggle').addEventListener('click', () => {
            istidalOfflineMode = !istidalOfflineMode;
            rendertidalPage();
        });

        setupDrawerInteractions();
        setupSwipeGestures();

        // Player Handle Mouse Click Support
        const playerHandle = document.querySelector('.hitpoint-drawer-handle-player');
        if (playerHandle) {
            playerHandle.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering other touch events
                if (isPanelVisible) {
                    closePanel();
                } else {
                    setView(lastMainView); // Minimize player
                }
            });
        }
    } catch (error) {
        console.error('Failed to initialize application:', error);
    }
});

document.getElementById('uploadBtn').addEventListener('click', async () => {
    if ('showDirectoryPicker' in window) {
        try {
            const handle = await window.showDirectoryPicker();
            
            for (const existingHandle of directoryHandles) {
                if (await handle.isSameEntry(existingHandle)) {
                    showToast("This folder has already been added");
                    return;
                }
            }

            if (await verifyPermission(handle, true)) {
                directoryHandles.push(handle);
                const tx = db.transaction('config', 'readwrite');
                tx.objectStore('config').put({ key: 'directoryHandles', value: directoryHandles });
                await tx.done;
                await processDirectory(handle);
            }
        } catch (err) {
            if (err.name !== 'AbortError') console.error('Error picking directory:', err);
        }
    } else {
        document.getElementById('musicUpload').click();
    }
});

        musicUpload.addEventListener('change', (e) => {
            if (e.target.files.length > 0) addSongs(e.target.files, 'indexeddb');
        });
        
        async function processDirectory(handle) {
            const filesToAdd = [];
            const existingSongNames = new Set(songs.map(s => s.handleName));

            for await (const entry of handle.values()) {
                if (entry.kind === 'file' && isAudioFile({ name: entry.name }) && !existingSongNames.has(entry.name)) {
                    filesToAdd.push(entry);
                }
            }

            if (filesToAdd.length > 0) {
                showToast(`${filesToAdd.length} new songs added to Library`);
                await addSongs(filesToAdd, 'filesystem');
            } else {
                showToast('No new songs found in the selected directory');
            }
        }

        function toggleCrossfade() {
            crossfadeEnabled = !crossfadeEnabled;
            document.getElementById('crossfadeStatus').textContent = crossfadeEnabled ? 'On' : 'Off';
        }

        function setSleepTimer(minutes) {
            clearTimeout(sleepTimerId);
            if (minutes > 0) {
                sleepTimerId = setTimeout(() => {
                    audioPlayer.pause();
                    playPauseIcon.textContent = 'play_arrow';
                    playPauseBtn.classList.remove('playing');
                }, minutes * 60 * 1000);
                showToast(`Sleep timer set for ${minutes} minutes`);
            } else {
                showToast('Sleep timer cancelled');
            }
            closeModal(sleepTimerModal);
        }
        
async function loadSongsAndPlaylists() {
    try {
        const songTx = db.transaction('songs', 'readonly');
        const songRequest = songTx.objectStore('songs').getAll();
        const loadedSongs = await new Promise((resolve, reject) => {
            songRequest.onsuccess = () => resolve(songRequest.result);
            songRequest.onerror = () => reject(songRequest.error);
        });
        
        songs = Array.isArray(loadedSongs) ? loadedSongs : [];
        songs.forEach(song => { if (!song.dateAdded) song.dateAdded = song.id; });
        processAndSortSongs();
        updateLocalSongLookup(songs, { clear: true });

        isrcToLocalSongMap.clear();
        songs.forEach(song => {
            if (song.isrc) {
                isrcToLocalSongMap.set(song.isrc, song);
            }
        });

        const playlistTx = db.transaction('playlists', 'readonly');
        const playlistRequest = playlistTx.objectStore('playlists').getAll();
        const loadedPlaylists = await new Promise((resolve, reject) => {
            playlistRequest.onsuccess = () => resolve(playlistRequest.result);
            playlistRequest.onerror = () => reject(playlistRequest.error);
        });
        playlists = Array.isArray(loadedPlaylists) ? loadedPlaylists : [];
        
        console.log(`Loaded ${songs.length} songs and ${playlists.length} playlists.`);

    } catch (error) {
        console.error("Failed to load data from IndexedDB:", error);
        songs = []; playlists = [];
    }
}

        async function createPlaylistAndAddSong() {
            const newName = document.getElementById('newPlaylistName').value.trim();
            if (!newName) return;
            if (!currentSongId) return alert("Play an item first.");
        
            const newPlaylist = { name: newName, songIds: [currentSongId] };
            
            try {
                const tx = db.transaction('playlists', 'readwrite');
                const request = tx.objectStore('playlists').add(newPlaylist);
                await new Promise((resolve, reject) => {
                    request.onerror = () => reject(request.error);
                    tx.oncomplete = () => {
                        newPlaylist.id = request.result;
                        resolve();
                    };
                });
        
                playlists.push(newPlaylist);
                triggerAutoSync();
                document.getElementById('newPlaylistName').value = '';
                closeModal(playlistModal);
                showToast(`Added item to new playlist "${newName}"`);
            } catch (error) {
                console.error("Failed to create playlist:", error);
                alert(`Failed to create playlist`);
            }
        }

        async function addSongToPlaylist(playlistId) {
            const playlist = playlists.find(p => p.id === playlistId);
            if (!playlist || !currentlyPlayingSong) return;
        
            const songToAdd = currentlyPlayingSong;
            
            if (!playlist.songIds.includes(songToAdd.id)) {
                playlist.songIds.push(songToAdd.id);
                
                if (songToAdd.storage === 'tidal') {
                    const tx = db.transaction('tidalCache', 'readonly');
                    const checkReq = await promiseIDBRequest(tx.objectStore('tidalCache').get(songToAdd.id));
                    if (!checkReq) {
                        await processAndCachetidalTrack(songToAdd);
                    }
                }
                
                const writeTx = db.transaction('playlists', 'readwrite');
                writeTx.objectStore('playlists').put(playlist);
                await writeTx.done;
                triggerAutoSync();
                showToast(`Added to "${playlist.name}"`);
            } else {
                showToast(`Song is already in "${playlist.name}"`);
            }
            closeModal(playlistModal);
        }
    </script>
</body>
</html>
